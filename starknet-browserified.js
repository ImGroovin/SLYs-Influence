(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.BrowserStarknet = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":3,"get-intrinsic":7}],3:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":6,"get-intrinsic":7}],4:[function(require,module,exports){
'use strict';

var isCallable = require('is-callable');

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;

},{"is-callable":16}],5:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],6:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":5}],7:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":6,"has":13,"has-proto":9,"has-symbols":10}],8:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":7}],9:[function(require,module,exports){
'use strict';

var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};

},{}],10:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":11}],11:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],12:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":11}],13:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":6}],14:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],15:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":2,"has-tostringtag/shams":12}],16:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};

},{}],17:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":12}],18:[function(require,module,exports){
'use strict';

var whichTypedArray = require('which-typed-array');

module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};

},{"which-typed-array":24}],19:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],20:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],21:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],22:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":15,"is-generator-function":17,"is-typed-array":18,"which-typed-array":24}],23:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))
},{"./support/isBuffer":21,"./support/types":22,"_process":19,"inherits":14}],24:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBind = require('call-bind');
var callBound = require('call-bind/callBound');
var gOPD = require('gopd');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		cache['$' + typedArray] = callBind(arr.slice);
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var found = false;
	forEach(cache, function (getter, typedArray) {
		if (!found) {
			try {
				if ('$' + getter(value) === typedArray) {
					found = $slice(typedArray, 1);
				}
			} catch (e) { /**/ }
		}
	});
	return found;
};

var trySlices = function tryAllSlices(value) {
	var found = false;
	forEach(cache, function (getter, name) {
		if (!found) {
			try {
				getter(value);
				found = $slice(name, 1);
			} catch (e) { /**/ }
		}
	});
	return found;
};

module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"available-typed-arrays":1,"call-bind":3,"call-bind/callBound":2,"for-each":4,"gopd":8,"has-tostringtag/shams":12}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSessionRequest = exports.buildSessionAccount = exports.SessionDappService = exports.ArgentSessionService = exports.ALLOWED_METHOD_HASH = void 0;
exports.getOutsideCall = $;
exports.getOutsideExecutionCall = te;
exports.getOutsideExecutionTypedData = w;
exports.getSessionTypedData = exports.getSessionDomain = void 0;
exports.getTypedDataHash = ee;
exports.typesRev1 = exports.sessionTypes = exports.openSession = void 0;
var _index = require("../../../../src/index.js");
const P = "https://cloud.argent-api.com/v1";
class C extends Error {
  constructor(t, e) {
    super(t), this.cause = e, Error.captureStackTrace(this, this.constructor);
  }
}
class V {
  constructor(t, e, o = P) {
    this.pubkey = t, this.accountSessionSignature = e, this.argentSessionServiceBaseUrl = o;
  }
  async signTxAndSession(t, e, o, n, r) {
    const a = _index.transaction.getExecuteCalldata(t, e.cairoVersion),
      i = _index.typedData.getMessageHash(o, e.walletAddress),
      c = _index.stark.formatSignature(this.accountSessionSignature),
      l = {
        session: {
          sessionHash: i,
          sessionAuthorisation: c,
          cacheAuthorisation: r,
          sessionSignature: {
            type: "StarknetKey",
            signer: {
              publicKey: this.pubkey,
              r: n[0].toString(),
              s: n[1].toString()
            }
          }
        }
      };
    if (Object.values(_index.RPC.ETransactionVersion2).includes(e.version)) {
      const d = e;
      l.transaction = {
        contractAddress: d.walletAddress,
        calldata: a,
        maxFee: d.maxFee.toString(),
        nonce: d.nonce.toString(),
        version: _index.num.toBigInt(d.version).toString(10),
        chainId: _index.num.toBigInt(d.chainId).toString(10)
      };
    } else if (Object.values(_index.RPC.ETransactionVersion3).includes(e.version)) {
      const d = e;
      l.transaction = {
        sender_address: d.walletAddress,
        calldata: a,
        nonce: d.nonce.toString(),
        version: _index.num.toBigInt(d.version).toString(10),
        chainId: _index.num.toBigInt(d.chainId).toString(10),
        resource_bounds: {
          l1_gas: {
            max_amount: d.resourceBounds.l1_gas.max_amount.toString(),
            max_price_per_unit: d.resourceBounds.l1_gas.max_price_per_unit.toString()
          },
          l2_gas: {
            max_amount: d.resourceBounds.l1_gas.max_amount.toString(),
            max_price_per_unit: d.resourceBounds.l1_gas.max_price_per_unit.toString()
          }
        },
        tip: d.tip.toString(),
        paymaster_data: d.paymasterData.map(T => T.toString()),
        account_deployment_data: d.accountDeploymentData,
        nonce_data_availability_mode: d.nonceDataAvailabilityMode,
        fee_data_availability_mode: d.feeDataAvailabilityMode
      };
    } else throw Error("unsupported signTransaction version");
    const u = await fetch(`${this.argentSessionServiceBaseUrl}/cosigner/signSession`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(l)
    });
    if (!u.ok) {
      const d = await u.json();
      throw new C("Sign session error", d.status);
    }
    return (await u.json()).signature;
  }
  async signSessionEFO(t, e, o, n, r, a) {
    const i = _index.typedData.getMessageHash(A(t, a), e),
      c = _index.stark.formatSignature(this.accountSessionSignature),
      u = {
        session: {
          sessionHash: i,
          sessionAuthorisation: c,
          cacheAuthorisation: r,
          sessionSignature: {
            type: "StarknetKey",
            signer: {
              publicKey: this.pubkey,
              r: n[0].toString(),
              s: n[1].toString()
            }
          }
        },
        message: {
          type: "eip712",
          accountAddress: e,
          chain: "starknet",
          message: o
        }
      },
      g = JSON.stringify(u, (b, v) => typeof v == "bigint" ? v.toString() : v),
      d = await fetch(`${this.argentSessionServiceBaseUrl}/cosigner/signSessionEFO`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: g
      });
    if (!d.ok) {
      const b = await d.json();
      throw new C("Sign session error", b.status);
    }
    return (await d.json()).signature;
  }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
exports.ArgentSessionService = V;
BigInt(0);
BigInt(1);
BigInt(2);
function W(s) {
  return s instanceof Uint8Array || s != null && typeof s == "object" && s.constructor.name === "Uint8Array";
}
const U = /* @__PURE__ */Array.from({
  length: 256
}, (s, t) => t.toString(16).padStart(2, "0"));
function L(s) {
  if (!W(s)) throw new Error("Uint8Array expected");
  let t = "";
  for (let e = 0; e < s.length; e++) t += U[s[e]];
  return t;
}
const J = exports.typesRev1 = {
  StarknetDomain: [{
    name: "name",
    type: "shortstring"
  }, {
    name: "version",
    type: "shortstring"
  }, {
    name: "chainId",
    type: "shortstring"
  }, {
    name: "revision",
    type: "shortstring"
  }],
  OutsideExecution: [{
    name: "Caller",
    type: "ContractAddress"
  }, {
    name: "Nonce",
    type: "felt"
  }, {
    name: "Execute After",
    type: "u128"
  }, {
    name: "Execute Before",
    type: "u128"
  }, {
    name: "Calls",
    type: "Call*"
  }],
  Call: [{
    name: "To",
    type: "ContractAddress"
  }, {
    name: "Selector",
    type: "selector"
  }, {
    name: "Calldata",
    type: "felt*"
  }]
};
function G(s) {
  return {
    name: "Account.execute_from_outside",
    version: "1",
    chainId: s,
    revision: "1"
  };
}
function $(s) {
  return {
    to: s.contractAddress,
    selector: _index.hash.getSelectorFromName(s.entrypoint),
    calldata: s.calldata ?? []
  };
}
function ee(s, t, e) {
  return _index.typedData.getMessageHash(w(s, e), t);
}
function w(s, t) {
  return {
    types: J,
    primaryType: "OutsideExecution",
    domain: G(t),
    message: {
      Caller: s.caller,
      Nonce: s.nonce,
      "Execute After": s.execute_after,
      "Execute Before": s.execute_before,
      Calls: s.calls.map(e => ({
        To: e.to,
        Selector: e.selector,
        Calldata: e.calldata
      }))
    }
  };
}
async function te(s, t, e, o, n) {
  n = n ?? (await o.getChainId());
  const r = w(s, n),
    a = await e.signMessage(r, t);
  return {
    contractAddress: t,
    entrypoint: "execute_from_outside_v2",
    calldata: _index.CallData.compile({
      ...s,
      signature: a
    })
  };
}
var h = /* @__PURE__ */(s => (s[s.Starknet = 0] = "Starknet", s[s.Secp256k1 = 1] = "Secp256k1", s[s.Secp256r1 = 2] = "Secp256r1", s[s.Eip191 = 3] = "Eip191", s[s.Webauthn = 4] = "Webauthn", s))(h || {});
const Y = (s, t) => {
    const e = {
      Starknet: void 0,
      Secp256k1: void 0,
      Secp256r1: void 0,
      Eip191: void 0,
      Webauthn: void 0
    };
    if (s === h.Starknet) e.Starknet = t;else if (s === h.Secp256k1) e.Secp256k1 = t;else if (s === h.Secp256r1) e.Secp256r1 = t;else if (s === h.Eip191) e.Eip191 = t;else if (s === h.Webauthn) e.Webauthn = t;else throw new Error("Unknown SignerType");
    return new _index.CairoCustomEnum(e);
  },
  D = _index.shortString.encodeShortString("session-token");
class z extends _index.Signer {
  constructor(t) {
    super(), this.signTransactionCallback = t;
  }
  async signRaw(t) {
    throw new Error("Method not implemented.");
  }
  async signTransaction(t, e) {
    return this.signTransactionCallback(t, e);
  }
}
class Q {
  constructor(t, e, o) {
    this.argentSessionService = t, this.chainId = e, this.dappKey = o;
  }
  getAccountWithSessionSigner(t, e, o, n, r = !1) {
    const a = new z((i, c) => this.signTransaction(n, o, i, c, r));
    return new _index.Account(t, e, a);
  }
  async signTransaction(t, e, o, n, r) {
    const a = _index.transaction.getExecuteCalldata(o, n.cairoVersion);
    let i;
    if (Object.values(_index.RPC.ETransactionVersion2).includes(n.version)) {
      const c = n;
      i = _index.hash.calculateInvokeTransactionHash({
        ...c,
        senderAddress: c.walletAddress,
        compiledCalldata: a,
        version: c.version
      });
    } else if (Object.values(_index.RPC.ETransactionVersion3).includes(n.version)) {
      const c = n;
      i = _index.hash.calculateInvokeTransactionHash({
        ...c,
        senderAddress: c.walletAddress,
        compiledCalldata: a,
        version: c.version,
        nonceDataAvailabilityMode: _index.stark.intDAM(c.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: _index.stark.intDAM(c.feeDataAvailabilityMode)
      });
    } else throw Error("unsupported signTransaction version");
    return this.getSessionSignatureForTransaction(t, e, i, o, n.walletAddress, n, r);
  }
  async getSessionSignatureForTransaction(t, e, o, n, r, a, i) {
    const c = this.compileSessionHelper(e),
      p = A(e, this.chainId),
      l = await this.signTxAndSession(o, r, p, i),
      u = await this.argentSessionService.signTxAndSession(n, a, p, l, i),
      g = await this.compileSessionTokenHelper(c, e, n, l, t, u, i);
    return [D, ..._index.CallData.compile(g)];
  }
  async signTxAndSession(t, e, o, n) {
    const r = _index.typedData.getMessageHash(o, e),
      a = _index.hash.computePoseidonHashOnElements([t, r, +n]),
      i = _index.ec.starkCurve.sign(a, this.dappKey.privateKey);
    return [i.r, i.s];
  }
  buildMerkleTree(t) {
    const e = t.allowed_methods.map(o => _index.hash.computePoseidonHashOnElements([X, o["Contract Address"], _index.selector.getSelectorFromName(o.selector)]));
    return new _index.merkle.MerkleTree(e, _index.hash.computePoseidonHash);
  }
  getSessionProofs(t, e) {
    const o = this.buildMerkleTree(t);
    return e.map(n => {
      const r = t.allowed_methods.findIndex(a => _index.num.hexToDecimalString(a["Contract Address"]) === _index.num.hexToDecimalString(n.contractAddress) && a.selector == n.entrypoint);
      return o.getProof(o.leaves[r], o.leaves);
    });
  }
  compileSessionHelper(t) {
    const e = _index.byteArray.byteArrayFromString(t.metadata),
      o = [e.data.length, ...e.data, e.pending_word, e.pending_word_len],
      n = _index.hash.computePoseidonHashOnElements(o);
    return {
      expires_at: t.expires_at,
      allowed_methods_root: this.buildMerkleTree(t).root.toString(),
      metadata_hash: n,
      session_key_guid: t.session_key_guid
    };
  }
  async compileSessionTokenHelper(t, e, o, n, r, a, i) {
    return {
      session: t,
      cache_authorization: i,
      session_authorization: r,
      sessionSignature: this.getStarknetSignatureType(this.dappKey.publicKey, n),
      guardianSignature: this.getStarknetSignatureType(a.publicKey, [a.r, a.s]),
      proofs: this.getSessionProofs(e, o)
    };
  }
  // function needed as starknetSignatureType is already compiled
  getStarknetSignatureType(t, e) {
    return Y(h.Starknet, {
      pubkey: t,
      r: e[0],
      s: e[1]
    });
  }
  buildOutsideExecution(t, e, o, n, r) {
    const a = _index.shortString.encodeShortString("ANY_CALLER"),
      i = _index.encode.addHexPrefix(L(_index.ec.starkCurve.utils.randomPrivateKey())),
      c = Date.now(),
      p = Math.floor((c + 6e4 * 20) / 1e3),
      l = Math.floor((c - 6e4 * 10) / 1e3);
    return {
      caller: e || a,
      nonce: r || i,
      execute_after: o || l,
      execute_before: n || p,
      calls: t.map(u => $(u))
    };
  }
  buildOutsideExecutionTypedData(t, e, o, n, r, a) {
    const i = this.buildOutsideExecution(e, o, n, r, a);
    return w(i, t);
  }
  async getOutsideExecutionCall(t, e, o, n, r, a, i, c, p) {
    const l = this.buildOutsideExecution(n, a, i, c, p),
      u = w(l, this.chainId),
      g = await this.getSessionSignatureForOutsideExecutionTypedData(e, t, n, r, u, o);
    return {
      contractAddress: r,
      entrypoint: "execute_from_outside_v2",
      calldata: _index.CallData.compile({
        ...l,
        signature: g
      })
    };
  }
  async getSessionSignatureForOutsideExecutionTypedData(t, e, o, n, r, a) {
    const i = this.compileSessionHelper(e),
      c = A(e, this.chainId),
      p = _index.typedData.getMessageHash(r, n),
      l = await this.signTxAndSession(p, n, c, a),
      u = await this.argentSessionService.signSessionEFO(e, n, r, l, a, this.chainId),
      g = await this.compileSessionTokenHelper(i, e, o, l, t, u, a);
    return [D, ..._index.CallData.compile(g)];
  }
  async getOutsideExecutionTypedData(t, e, o, n, r, a, i, c, p) {
    const l = this.buildOutsideExecutionTypedData(this.chainId, n, a, i, c, p),
      u = await this.getSessionSignatureForOutsideExecutionTypedData(e, t, n, r, l, o);
    return {
      outsideExecutionTypedData: l,
      signature: u
    };
  }
}
exports.SessionDappService = Q;
const H = exports.sessionTypes = {
    StarknetDomain: [{
      name: "name",
      type: "shortstring"
    }, {
      name: "version",
      type: "shortstring"
    }, {
      name: "chainId",
      type: "shortstring"
    }, {
      name: "revision",
      type: "shortstring"
    }],
    "Allowed Method": [{
      name: "Contract Address",
      type: "ContractAddress"
    }, {
      name: "selector",
      type: "selector"
    }],
    Session: [{
      name: "Expires At",
      type: "timestamp"
    }, {
      name: "Allowed Methods",
      type: "merkletree",
      contains: "Allowed Method"
    }, {
      name: "Metadata",
      type: "string"
    }, {
      name: "Session Key",
      type: "felt"
    }]
  },
  X = exports.ALLOWED_METHOD_HASH = _index.typedData.getTypeHash(H, "Allowed Method", _index.typedData.TypedDataRevision.Active),
  Z = s => ({
    name: "SessionAccount.session",
    version: _index.shortString.encodeShortString("1"),
    chainId: s,
    revision: "1"
  }),
  A = (s, t) => ({
    types: H,
    primaryType: "Session",
    domain: Z(t),
    message: {
      "Expires At": s.expires_at,
      "Allowed Methods": s.allowed_methods,
      Metadata: s.metadata,
      "Session Key": s.session_key_guid
    }
  }),
  R = (s, t, e, o) => ({
    expires_at: Number(t),
    allowed_methods: s,
    metadata: JSON.stringify(e),
    session_key_guid: _index.hash.computePoseidonHash(_index.shortString.encodeShortString("Starknet Signer"), o)
  }),
  se = async ({
    useCacheAuthorisation: s,
    accountSessionSignature: t,
    sessionRequest: e,
    provider: o,
    chainId: n,
    address: r,
    dappKey: a,
    argentSessionServiceBaseUrl: i
  }) => {
    const c = new V(a.publicKey, t, i);
    return new Q(c, n, a).getAccountWithSessionSigner(o, r, e, t, s);
  },
  ne = async ({
    wallet: s,
    sessionParams: t,
    chainId: e
  }) => {
    const {
      allowedMethods: o,
      expiry: n = BigInt(Date.now()) + 10000n,
      publicDappKey: r,
      metaData: a
    } = t;
    if (!r) throw new Error("publicDappKey is required");
    const i = R(o, n, a, r),
      c = A(i, e);
    return await s.request({
      type: "wallet_signTypedData",
      params: c
    });
  };
exports.openSession = ne;
exports.buildSessionAccount = se;
exports.createSessionRequest = R;
exports.getSessionTypedData = A;
exports.getSessionDomain = Z;

},{"../../../../src/index.js":107}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = require("@noble/hashes/hmac");
const utils_1 = require("@noble/hashes/utils");
const weierstrass_js_1 = require("./abstract/weierstrass.js");
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
exports.createCurve = createCurve;

},{"./abstract/weierstrass.js":32,"@noble/hashes/hmac":38,"@noble/hashes/utils":41}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = require("./modular.js");
const utils_js_1 = require("./utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
exports.validateBasic = validateBasic;

},{"./modular.js":29,"./utils.js":31}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
const modular_js_1 = require("./modular.js");
const utils_js_1 = require("./utils.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_js_1.abytes)(msg);
    (0, utils_js_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    (0, utils_js_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === 'string' ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
exports.createHasher = createHasher;

},{"./modular.js":29,"./utils.js":31}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = require("./utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P  9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;

},{"./utils.js":31}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.poseidon = exports.splitConstants = exports.validateOpts = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Poseidon Hash: https://eprint.iacr.org/2019/458.pdf, https://www.poseidon-hash.info
const modular_js_1 = require("./modular.js");
function validateOpts(opts) {
    const { Fp, mds, reversePartialPowIdx: rev, roundConstants: rc } = opts;
    const { roundsFull, roundsPartial, sboxPower, t } = opts;
    (0, modular_js_1.validateField)(Fp);
    for (const i of ['t', 'roundsFull', 'roundsPartial']) {
        if (typeof opts[i] !== 'number' || !Number.isSafeInteger(opts[i]))
            throw new Error(`Poseidon: invalid param ${i}=${opts[i]} (${typeof opts[i]})`);
    }
    // MDS is TxT matrix
    if (!Array.isArray(mds) || mds.length !== t)
        throw new Error('Poseidon: wrong MDS matrix');
    const _mds = mds.map((mdsRow) => {
        if (!Array.isArray(mdsRow) || mdsRow.length !== t)
            throw new Error(`Poseidon MDS matrix row: ${mdsRow}`);
        return mdsRow.map((i) => {
            if (typeof i !== 'bigint')
                throw new Error(`Poseidon MDS matrix value=${i}`);
            return Fp.create(i);
        });
    });
    if (rev !== undefined && typeof rev !== 'boolean')
        throw new Error(`Poseidon: invalid param reversePartialPowIdx=${rev}`);
    if (roundsFull % 2 !== 0)
        throw new Error(`Poseidon roundsFull is not even: ${roundsFull}`);
    const rounds = roundsFull + roundsPartial;
    if (!Array.isArray(rc) || rc.length !== rounds)
        throw new Error('Poseidon: wrong round constants');
    const roundConstants = rc.map((rc) => {
        if (!Array.isArray(rc) || rc.length !== t)
            throw new Error(`Poseidon wrong round constants: ${rc}`);
        return rc.map((i) => {
            if (typeof i !== 'bigint' || !Fp.isValid(i))
                throw new Error(`Poseidon wrong round constant=${i}`);
            return Fp.create(i);
        });
    });
    if (!sboxPower || ![3, 5, 7].includes(sboxPower))
        throw new Error(`Poseidon wrong sboxPower=${sboxPower}`);
    const _sboxPower = BigInt(sboxPower);
    let sboxFn = (n) => (0, modular_js_1.FpPow)(Fp, n, _sboxPower);
    // Unwrapped sbox power for common cases (195->142s)
    if (sboxPower === 3)
        sboxFn = (n) => Fp.mul(Fp.sqrN(n), n);
    else if (sboxPower === 5)
        sboxFn = (n) => Fp.mul(Fp.sqrN(Fp.sqrN(n)), n);
    return Object.freeze({ ...opts, rounds, sboxFn, roundConstants, mds: _mds });
}
exports.validateOpts = validateOpts;
function splitConstants(rc, t) {
    if (typeof t !== 'number')
        throw new Error('poseidonSplitConstants: wrong t');
    if (!Array.isArray(rc) || rc.length % t)
        throw new Error('poseidonSplitConstants: wrong rc');
    const res = [];
    let tmp = [];
    for (let i = 0; i < rc.length; i++) {
        tmp.push(rc[i]);
        if (tmp.length === t) {
            res.push(tmp);
            tmp = [];
        }
    }
    return res;
}
exports.splitConstants = splitConstants;
function poseidon(opts) {
    const _opts = validateOpts(opts);
    const { Fp, mds, roundConstants, rounds, roundsPartial, sboxFn, t } = _opts;
    const halfRoundsFull = _opts.roundsFull / 2;
    const partialIdx = _opts.reversePartialPowIdx ? t - 1 : 0;
    const poseidonRound = (values, isFull, idx) => {
        values = values.map((i, j) => Fp.add(i, roundConstants[idx][j]));
        if (isFull)
            values = values.map((i) => sboxFn(i));
        else
            values[partialIdx] = sboxFn(values[partialIdx]);
        // Matrix multiplication
        values = mds.map((i) => i.reduce((acc, i, j) => Fp.add(acc, Fp.mulN(i, values[j])), Fp.ZERO));
        return values;
    };
    const poseidonHash = function poseidonHash(values) {
        if (!Array.isArray(values) || values.length !== t)
            throw new Error(`Poseidon: wrong values (expected array of bigints with length ${t})`);
        values = values.map((i) => {
            if (typeof i !== 'bigint')
                throw new Error(`Poseidon: wrong value=${i} (${typeof i})`);
            return Fp.create(i);
        });
        let round = 0;
        // Apply r_f/2 full rounds.
        for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
        // Apply r_p partial rounds.
        for (let i = 0; i < roundsPartial; i++)
            values = poseidonRound(values, false, round++);
        // Apply r_f/2 full rounds.
        for (let i = 0; i < halfRoundsFull; i++)
            values = poseidonRound(values, true, round++);
        if (round !== rounds)
            throw new Error(`Poseidon: wrong number of rounds: last round=${round}, total=${rounds}`);
        return values;
    };
    // For verification in tests
    poseidonHash.roundConstants = roundConstants;
    return poseidonHash;
}
exports.poseidon = poseidon;

},{"./modular.js":29}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.abytes = exports.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
exports.isBytes = isBytes;
function abytes(item) {
    if (!isBytes(item))
        throw new Error('Uint8Array expected');
}
exports.abytes = abytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

},{}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y = x + ax + b
const mod = require("./modular.js");
const ut = require("./utils.js");
const utils_js_1 = require("./utils.js");
const curve_js_1 = require("./curve.js");
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key))
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y
            const right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y;
                try {
                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                }
                catch (sqrtError) {
                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;

},{"./curve.js":27,"./modular.js":29,"./utils.js":31}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const modular_js_1 = require("./abstract/modular.js");
const weierstrass_js_1 = require("./abstract/weierstrass.js");
const utils_js_1 = require("./abstract/utils.js");
const hash_to_curve_js_1 = require("./abstract/hash-to-curve.js");
const _shortw_utils_js_1 = require("./_shortw_utils.js");
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0), // equation params: a, b
    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: secp256k1N, // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1), // Cofactor
    lowS: true, // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!fe(r))
            return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!ge(s))
            return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod,
    },
}))();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();

},{"./_shortw_utils.js":26,"./abstract/hash-to-curve.js":28,"./abstract/modular.js":29,"./abstract/utils.js":31,"./abstract/weierstrass.js":32,"@noble/hashes/sha256":39,"@noble/hashes/utils":41}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`boolean expected, not ${b}`);
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
exports.isBytes = isBytes;
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(h.outputLen);
    number(h.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports.default = assert;

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashMD = exports.Maj = exports.Chi = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
exports.Chi = Chi;
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.HashMD = HashMD;

},{"./_assert.js":34,"./utils.js":41}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);

},{"./_assert.js":34,"./utils.js":41}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _md_js_1 = require("./_md.js");
const utils_js_1 = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1.HashMD {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());

},{"./_md.js":35,"./utils.js":41}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        if (!utils_js_1.isLE)
            (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
            (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

},{"./_assert.js":34,"./_u64.js":36,"./utils.js":41}],41:[function(require,module,exports){
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("@noble/hashes/crypto");
const _assert_js_1 = require("./_assert.js");
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
exports.isBytes = isBytes;
// Cast array to different type
const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = word => word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? n => n : n => (0, exports.byteSwap)(n);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = (0, exports.byteSwap)(arr[i]);
  }
}
exports.byteSwap32 = byteSwap32;
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */Array.from({
  length: 256
}, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  (0, _assert_js_1.bytes)(bytes);
  // pre-caching improves the speed 6x
  let hex = '';
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
const asciis = {
  _0: 48,
  _9: 57,
  _A: 65,
  _F: 70,
  _a: 97,
  _f: 102
};
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
  return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => {};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick) continue;
    await (0, exports.nextTick)();
    ts += diff;
  }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  (0, _assert_js_1.bytes)(data);
  return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    (0, _assert_js_1.bytes)(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
  const merged = Object.assign(defaults, opts);
  return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
  const hashC = msg => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = opts => hashCons(opts);
  return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = opts => hashCons(opts);
  return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;

},{"./_assert.js":34,"@noble/hashes/crypto":37}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertNumber = assertNumber;
exports.utils = exports.utf8 = exports.stringToBytes = exports.str = exports.hex = exports.createBase58check = exports.bytesToString = exports.bytes = exports.bech32m = exports.bech32 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base58xrp = exports.base58xmr = exports.base58flickr = exports.base58check = exports.base58 = exports.base32hex = exports.base32crockford = exports.base32 = exports.base16 = void 0;
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities
/**
 * @__NO_SIDE_EFFECTS__
 */
function assertNumber(n) {
  if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
  const id = a => a;
  // Wrap call in closure so JIT can inline calls
  const wrap = (a, b) => c => a(b(c));
  // Construct chain of args[-1].encode(args[-2].encode([...]))
  const encode = args.map(x => x.encode).reduceRight(wrap, id);
  // Construct chain of args[0].decode(args[1].decode(...))
  const decode = args.map(x => x.decode).reduce(wrap, id);
  return {
    encode,
    decode
  };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(alphabet) {
  return {
    encode: digits => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');
      return digits.map(i => {
        assertNumber(i);
        if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
        return alphabet[i];
      });
    },
    decode: input => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');
      return input.map(letter => {
        if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet.indexOf(letter);
        if (index === -1) throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
        return index;
      });
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
  if (typeof separator !== 'string') throw new Error('join separator should be string');
  return {
    encode: from => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');
      for (let i of from) if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);
      return from.join(separator);
    },
    decode: to => {
      if (typeof to !== 'string') throw new Error('join.decode input should be string');
      return to.split(separator);
    }
  };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
  assertNumber(bits);
  if (typeof chr !== 'string') throw new Error('padding chr should be string');
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');
      for (let i of data) if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);
      while (data.length * bits % 8) data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');
      for (let i of input) if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);
      let end = input.length;
      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');
      }
      return input.slice(0, end);
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
  if (typeof fn !== 'function') throw new Error('normalize fn should be function');
  return {
    encode: from => from,
    decode: to => fn(to)
  };
}
/**
 * Slow: O(n^2) time complexity
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix(data, from, to) {
  // base 1 is impossible
  if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');
  if (!data.length) return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach(d => {
    assertNumber(d);
    if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error('convertRadix: carry overflow');
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
      if (!done) continue;else if (!rounded) pos = i;else done = false;
    }
    res.push(carry);
    if (done) break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);
  return res.reverse();
}
const gcd = /* @__NO_SIDE_EFFECTS__ */(a, b) => !b ? a : gcd(b, a % b);
const radix2carry = /*@__NO_SIDE_EFFECTS__ */(from, to) => from + (to - gcd(from, to));
/**
 * Implemented with numbers, because BigInt is 5x slower
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix2(data, from, to, padding) {
  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');
  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0; // bitwise position in current element
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow
  }
  carry = carry << to - pos & mask;
  if (!padding && pos >= from) throw new Error('Excess padding');
  if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);
  if (padding && pos > 0) res.push(carry >>> 0);
  return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
  assertNumber(num);
  return {
    encode: bytes => {
      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
      return convertRadix(Array.from(bytes), 2 ** 8, num);
    },
    decode: digits => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of numbers');
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
  return {
    encode: bytes => {
      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: digits => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of numbers');
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function unsafeWrapper(fn) {
  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');
  return function (...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {}
  };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== 'function') throw new Error('checksum fn should be function');
  return {
    encode(data) {
      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
      const checksum = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
      return payload;
    }
  };
}
// prettier-ignore
const utils = exports.utils = {
  alphabet,
  chain,
  checksum,
  convertRadix,
  convertRadix2,
  radix,
  radix2,
  join,
  padding
};
// RFC 4648 aka RFC 3548
// ---------------------
const base16 = exports.base16 = /* @__PURE__ */chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
const base32 = exports.base32 = /* @__PURE__ */chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
const base32hex = exports.base32hex = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
const base32crockford = exports.base32crockford = /* @__PURE__ */chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(s => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
const base64 = exports.base64 = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64nopad = exports.base64nopad = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
const base64url = exports.base64url = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const base64urlnopad = exports.base64urlnopad = /* @__PURE__ */chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = abc => chain(radix(58), alphabet(abc), join(''));
const base58 = exports.base58 = /* @__PURE__ */genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const base58flickr = exports.base58flickr = /* @__PURE__ */genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
const base58xrp = exports.base58xrp = /* @__PURE__ */genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
// Block encoding significantly reduces quadratic complexity of base58.
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
const base58xmr = exports.base58xmr = {
  encode(data) {
    let res = '';
    for (let i = 0; i < data.length; i += 8) {
      const block = data.subarray(i, i + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i = 0; i < str.length; i += 11) {
      const slice = str.slice(i, i + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      const block = base58.decode(slice);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
const createBase58check = /* @__PURE__ */sha256 => chain(checksum(4, data => sha256(sha256(data))), base58);
// legacy export, bad name
exports.createBase58check = createBase58check;
const base58check = exports.base58check = createBase58check;
const BECH_ALPHABET = /* @__PURE__ */chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
/**
 * @__NO_SIDE_EFFECTS__
 */
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 0x1ffffff) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
  for (let v of words) chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0) throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    // don't allow mixed case
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf('1');
    if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6) throw new Error('Data must be at least 6 characters long');
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return {
      prefix,
      words
    };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const {
      prefix,
      words
    } = decode(str, false);
    return {
      prefix,
      words,
      bytes: fromWords(words)
    };
  }
  return {
    encode,
    decode,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
const bech32 = exports.bech32 = /* @__PURE__ */genBech32('bech32');
const bech32m = exports.bech32m = /* @__PURE__ */genBech32('bech32m');
const utf8 = exports.utf8 = {
  encode: data => new TextDecoder().decode(data),
  decode: str => new TextEncoder().encode(str)
};
const hex = exports.hex = /* @__PURE__ */chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(s => {
  if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes) => {
  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
  return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
const str = exports.str = bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str) => {
  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
  return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
const bytes = exports.bytes = stringToBytes;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.poseidonHashMany = exports.poseidonHashSingle = exports.poseidonHashFunc = exports.poseidonHash = exports.poseidonSmall = exports.poseidonCreate = exports.poseidonBasic = exports._poseidonMDS = exports.Fp251 = exports.keccak = exports.computeHashOnElements = exports.pedersen = exports.getAccountPath = exports.ethSigToPrivate = exports.getStarkKey = exports.grindKey = exports.utils = exports.Signature = exports.ProjectivePoint = exports.CURVE = exports.verify = exports.sign = exports.getSharedSecret = exports.getPublicKey = exports._starkCurve = exports.MAX_VALUE = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const modular_1 = require("@noble/curves/abstract/modular");
const poseidon_1 = require("@noble/curves/abstract/poseidon");
const weierstrass_1 = require("@noble/curves/abstract/weierstrass");
const u = require("@noble/curves/abstract/utils");
const _shortw_utils_1 = require("@noble/curves/_shortw_utils");
const CURVE_ORDER = BigInt('3618502788666131213697322783095070105526743751716087489154079457884512865583');
exports.MAX_VALUE = BigInt('0x800000000000000000000000000000000000000000000000000000000000000');
const nBitLength = 252;
function bits2int(bytes) {
    while (bytes[0] === 0)
        bytes = bytes.subarray(1);
    const delta = bytes.length * 8 - nBitLength;
    const num = u.bytesToNumberBE(bytes);
    return delta > 0 ? num >> BigInt(delta) : num;
}
function hex0xToBytes(hex) {
    if (typeof hex === 'string') {
        hex = strip0x(hex);
        if (hex.length & 1)
            hex = '0' + hex;
    }
    return u.hexToBytes(hex);
}
const curve = (0, weierstrass_1.weierstrass)({
    a: BigInt(1),
    b: BigInt('3141592653589793238462643383279502884197169399375105820974944592307816406665'),
    Fp: (0, modular_1.Field)(BigInt('0x800000000000011000000000000000000000000000000000000000000000001')),
    n: CURVE_ORDER,
    nBitLength,
    Gx: BigInt('874739451078007766457464989774322083649278607533249481151382481072868806602'),
    Gy: BigInt('152666792071518830868575557812948353041420400780739481342941381225525861407'),
    h: BigInt(1),
    lowS: false,
    ...(0, _shortw_utils_1.getHash)(sha256_1.sha256),
    bits2int,
    bits2int_modN: (bytes) => {
        const hex = u.bytesToNumberBE(bytes).toString(16);
        if (hex.length === 63)
            bytes = hex0xToBytes(hex + '0');
        return (0, modular_1.mod)(bits2int(bytes), CURVE_ORDER);
    },
});
exports._starkCurve = curve;
function ensureBytes(hex) {
    return u.ensureBytes('', typeof hex === 'string' ? hex0xToBytes(hex) : hex);
}
function normPrivKey(privKey) {
    return u.bytesToHex(ensureBytes(privKey)).padStart(64, '0');
}
function getPublicKey(privKey, isCompressed = false) {
    return curve.getPublicKey(normPrivKey(privKey), isCompressed);
}
exports.getPublicKey = getPublicKey;
function getSharedSecret(privKeyA, pubKeyB) {
    return curve.getSharedSecret(normPrivKey(privKeyA), pubKeyB);
}
exports.getSharedSecret = getSharedSecret;
function checkSignature(signature) {
    const { r, s } = signature;
    if (r < 0n || r >= exports.MAX_VALUE)
        throw new Error(`Signature.r should be [1, ${exports.MAX_VALUE})`);
    const w = (0, modular_1.invert)(s, CURVE_ORDER);
    if (w < 0n || w >= exports.MAX_VALUE)
        throw new Error(`inv(Signature.s) should be [1, ${exports.MAX_VALUE})`);
}
function checkMessage(msgHash) {
    const bytes = ensureBytes(msgHash);
    const num = u.bytesToNumberBE(bytes);
    if (num >= exports.MAX_VALUE)
        throw new Error(`msgHash should be [0, ${exports.MAX_VALUE})`);
    return bytes;
}
function sign(msgHash, privKey, opts) {
    const sig = curve.sign(checkMessage(msgHash), normPrivKey(privKey), opts);
    checkSignature(sig);
    return sig;
}
exports.sign = sign;
function verify(signature, msgHash, pubKey) {
    if (!(signature instanceof Signature)) {
        const bytes = ensureBytes(signature);
        try {
            signature = Signature.fromDER(bytes);
        }
        catch (derError) {
            if (!(derError instanceof weierstrass_1.DER.Err))
                throw derError;
            signature = Signature.fromCompact(bytes);
        }
    }
    checkSignature(signature);
    return curve.verify(signature, checkMessage(msgHash), ensureBytes(pubKey));
}
exports.verify = verify;
const { CURVE, ProjectivePoint, Signature, utils } = curve;
exports.CURVE = CURVE;
exports.ProjectivePoint = ProjectivePoint;
exports.Signature = Signature;
exports.utils = utils;
function extractX(bytes) {
    const hex = u.bytesToHex(bytes.subarray(1));
    const stripped = hex.replace(/^0+/gm, '');
    return `0x${stripped}`;
}
function strip0x(hex) {
    return hex.replace(/^0x/i, '');
}
function grindKey(seed) {
    const _seed = ensureBytes(seed);
    const sha256mask = 2n ** 256n;
    const limit = sha256mask - (0, modular_1.mod)(sha256mask, CURVE_ORDER);
    for (let i = 0;; i++) {
        const key = sha256Num(u.concatBytes(_seed, u.numberToVarBytesBE(BigInt(i))));
        if (key < limit)
            return (0, modular_1.mod)(key, CURVE_ORDER).toString(16);
        if (i === 100000)
            throw new Error('grindKey is broken: tried 100k vals');
    }
}
exports.grindKey = grindKey;
function getStarkKey(privateKey) {
    return extractX(getPublicKey(privateKey, true));
}
exports.getStarkKey = getStarkKey;
function ethSigToPrivate(signature) {
    signature = strip0x(signature);
    if (signature.length !== 130)
        throw new Error('Wrong ethereum signature');
    return grindKey(signature.substring(0, 64));
}
exports.ethSigToPrivate = ethSigToPrivate;
const MASK_31 = 2n ** 31n - 1n;
const int31 = (n) => Number(n & MASK_31);
function getAccountPath(layer, application, ethereumAddress, index) {
    const layerNum = int31(sha256Num(layer));
    const applicationNum = int31(sha256Num(application));
    const eth = u.hexToNumber(strip0x(ethereumAddress));
    return `m/2645'/${layerNum}'/${applicationNum}'/${int31(eth)}'/${int31(eth >> 31n)}'/${index}`;
}
exports.getAccountPath = getAccountPath;
const PEDERSEN_POINTS = [
    new ProjectivePoint(2089986280348253421170679821480865132823066470938446095505822317253594081284n, 1713931329540660377023406109199410414810705867260802078187082345529207694986n, 1n),
    new ProjectivePoint(996781205833008774514500082376783249102396023663454813447423147977397232763n, 1668503676786377725805489344771023921079126552019160156920634619255970485781n, 1n),
    new ProjectivePoint(2251563274489750535117886426533222435294046428347329203627021249169616184184n, 1798716007562728905295480679789526322175868328062420237419143593021674992973n, 1n),
    new ProjectivePoint(2138414695194151160943305727036575959195309218611738193261179310511854807447n, 113410276730064486255102093846540133784865286929052426931474106396135072156n, 1n),
    new ProjectivePoint(2379962749567351885752724891227938183011949129833673362440656643086021394946n, 776496453633298175483985398648758586525933812536653089401905292063708816422n, 1n),
];
function pedersenPrecompute(p1, p2) {
    const out = [];
    let p = p1;
    for (let i = 0; i < 248; i++) {
        out.push(p);
        p = p.double();
    }
    p = p2;
    for (let i = 0; i < 4; i++) {
        out.push(p);
        p = p.double();
    }
    return out;
}
const PEDERSEN_POINTS1 = pedersenPrecompute(PEDERSEN_POINTS[1], PEDERSEN_POINTS[2]);
const PEDERSEN_POINTS2 = pedersenPrecompute(PEDERSEN_POINTS[3], PEDERSEN_POINTS[4]);
function pedersenArg(arg) {
    let value;
    if (typeof arg === 'bigint') {
        value = arg;
    }
    else if (typeof arg === 'number') {
        if (!Number.isSafeInteger(arg))
            throw new Error(`Invalid pedersenArg: ${arg}`);
        value = BigInt(arg);
    }
    else {
        value = u.bytesToNumberBE(ensureBytes(arg));
    }
    if (!(0n <= value && value < curve.CURVE.Fp.ORDER))
        throw new Error(`PedersenArg should be 0 <= value < CURVE.P: ${value}`);
    return value;
}
function pedersenSingle(point, value, constants) {
    let x = pedersenArg(value);
    for (let j = 0; j < 252; j++) {
        const pt = constants[j];
        if (pt.equals(point))
            throw new Error('Same point');
        if ((x & 1n) !== 0n)
            point = point.add(pt);
        x >>= 1n;
    }
    return point;
}
function pedersen(x, y) {
    let point = PEDERSEN_POINTS[0];
    point = pedersenSingle(point, x, PEDERSEN_POINTS1);
    point = pedersenSingle(point, y, PEDERSEN_POINTS2);
    return extractX(point.toRawBytes(true));
}
exports.pedersen = pedersen;
const computeHashOnElements = (data, fn = pedersen) => [0, ...data, data.length].reduce((x, y) => fn(x, y));
exports.computeHashOnElements = computeHashOnElements;
const MASK_250 = u.bitMask(250);
const keccak = (data) => u.bytesToNumberBE((0, sha3_1.keccak_256)(data)) & MASK_250;
exports.keccak = keccak;
const sha256Num = (data) => u.bytesToNumberBE((0, sha256_1.sha256)(data));
exports.Fp251 = (0, modular_1.Field)(BigInt('3618502788666131213697322783095070105623107215331596699973092056135872020481'));
function poseidonRoundConstant(Fp, name, idx) {
    const val = Fp.fromBytes((0, sha256_1.sha256)((0, utils_1.utf8ToBytes)(`${name}${idx}`)));
    return Fp.create(val);
}
function _poseidonMDS(Fp, name, m, attempt = 0) {
    const x_values = [];
    const y_values = [];
    for (let i = 0; i < m; i++) {
        x_values.push(poseidonRoundConstant(Fp, `${name}x`, attempt * m + i));
        y_values.push(poseidonRoundConstant(Fp, `${name}y`, attempt * m + i));
    }
    if (new Set([...x_values, ...y_values]).size !== 2 * m)
        throw new Error('X and Y values are not distinct');
    return x_values.map((x) => y_values.map((y) => Fp.inv(Fp.sub(x, y))));
}
exports._poseidonMDS = _poseidonMDS;
const MDS_SMALL = [
    [3, 1, 1],
    [1, -1, 1],
    [1, 1, -2],
].map((i) => i.map(BigInt));
function poseidonBasic(opts, mds) {
    (0, modular_1.validateField)(opts.Fp);
    if (!Number.isSafeInteger(opts.rate) || !Number.isSafeInteger(opts.capacity))
        throw new Error(`Wrong poseidon opts: ${opts}`);
    const m = opts.rate + opts.capacity;
    const rounds = opts.roundsFull + opts.roundsPartial;
    const roundConstants = [];
    for (let i = 0; i < rounds; i++) {
        const row = [];
        for (let j = 0; j < m; j++)
            row.push(poseidonRoundConstant(opts.Fp, 'Hades', m * i + j));
        roundConstants.push(row);
    }
    const res = (0, poseidon_1.poseidon)({
        ...opts,
        t: m,
        sboxPower: 3,
        reversePartialPowIdx: true,
        mds,
        roundConstants,
    });
    res.m = m;
    res.rate = opts.rate;
    res.capacity = opts.capacity;
    return res;
}
exports.poseidonBasic = poseidonBasic;
function poseidonCreate(opts, mdsAttempt = 0) {
    const m = opts.rate + opts.capacity;
    if (!Number.isSafeInteger(mdsAttempt))
        throw new Error(`Wrong mdsAttempt=${mdsAttempt}`);
    return poseidonBasic(opts, _poseidonMDS(opts.Fp, 'HadesMDS', m, mdsAttempt));
}
exports.poseidonCreate = poseidonCreate;
exports.poseidonSmall = poseidonBasic({ Fp: exports.Fp251, rate: 2, capacity: 1, roundsFull: 8, roundsPartial: 83 }, MDS_SMALL);
function poseidonHash(x, y, fn = exports.poseidonSmall) {
    return fn([x, y, 2n])[0];
}
exports.poseidonHash = poseidonHash;
function poseidonHashFunc(x, y, fn = exports.poseidonSmall) {
    return u.numberToVarBytesBE(poseidonHash(u.bytesToNumberBE(x), u.bytesToNumberBE(y), fn));
}
exports.poseidonHashFunc = poseidonHashFunc;
function poseidonHashSingle(x, fn = exports.poseidonSmall) {
    return fn([x, 0n, 1n])[0];
}
exports.poseidonHashSingle = poseidonHashSingle;
function poseidonHashMany(values, fn = exports.poseidonSmall) {
    const { m, rate } = fn;
    if (!Array.isArray(values))
        throw new Error('bigint array expected in values');
    const padded = Array.from(values);
    padded.push(1n);
    while (padded.length % rate !== 0)
        padded.push(0n);
    let state = new Array(m).fill(0n);
    for (let i = 0; i < padded.length; i += rate) {
        for (let j = 0; j < rate; j++)
            state[j] += padded[i + j];
        state = fn(state);
    }
    return state[0];
}
exports.poseidonHashMany = poseidonHashMany;

},{"@noble/curves/_shortw_utils":44,"@noble/curves/abstract/modular":46,"@noble/curves/abstract/poseidon":47,"@noble/curves/abstract/utils":48,"@noble/curves/abstract/weierstrass":49,"@noble/hashes/sha256":55,"@noble/hashes/sha3":56,"@noble/hashes/utils":57}],44:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"./abstract/weierstrass.js":49,"@noble/hashes/hmac":54,"@noble/hashes/utils":57,"dup":26}],45:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./modular.js":46,"./utils.js":48,"dup":27}],46:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./utils.js":48,"dup":29}],47:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"./modular.js":46,"dup":30}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = exports.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
exports.isBytes = isBytes;
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!isBytes(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!isBytes(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
            throw new Error('Uint8Array expected');
        sum += a.length;
    }
    let res = new Uint8Array(sum);
    let pad = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n : _0n) << BigInt(pos));
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y = x + ax + b
const mod = require("./modular.js");
const ut = require("./utils.js");
const utils_js_1 = require("./utils.js");
const curve_js_1 = require("./curve.js");
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!ut.isBytes(data))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key))
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y
            const right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;

},{"./curve.js":45,"./modular.js":46,"./utils.js":48}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports.default = assert;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

},{"./_assert.js":50,"./utils.js":57}],52:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36}],53:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],54:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./_assert.js":50,"./utils.js":57,"dup":38}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());

},{"./_sha2.js":51,"./utils.js":57}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

},{"./_assert.js":50,"./_u64.js":52,"./utils.js":57}],57:[function(require,module,exports){
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';
}
// Cast array to view
const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => word << 32 - shift | word >>> shift;
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
// Other libraries would silently corrupt the data instead of throwing an error,
// when they don't support it.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE) throw new Error('Non little-endian hardware is not supported');
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */Array.from({
  length: 256
}, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  if (!isBytes(bytes)) throw new Error('Uint8Array expected');
  // pre-caching improves the speed 6x
  let hex = '';
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
const asciis = {
  _0: 48,
  _9: 57,
  _A: 65,
  _F: 70,
  _a: 97,
  _f: 102
};
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
  return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => {};
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick) continue;
    await (0, exports.nextTick)();
    ts += diff;
  }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes(a)) throw new Error('Uint8Array expected');
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
  const merged = Object.assign(defaults, opts);
  return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
  const hashC = msg => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = opts => hashCons(opts);
  return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = opts => hashCons(opts);
  return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;

},{"@noble/hashes/crypto":53}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchCookie;
var tough = _interopRequireWildcard(require("tough-cookie"));
var _setCookieParser = require("set-cookie-parser");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function isDomainOrSubdomain(destination, original) {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
}
const referrerPolicy = /* @__PURE__ */new Set(["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"]);
function parseReferrerPolicy(policyHeader) {
  const policyTokens = policyHeader.split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token !== "" && referrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
function doNothing(init, name) {}
function callDeleteMethod(init, name) {
  init.headers.delete(name);
}
function deleteFromObject(init, name) {
  const headers = init.headers;
  for (const key of Object.keys(headers)) {
    if (key.toLowerCase() === name) {
      delete headers[key];
    }
  }
}
function identifyDeleteHeader(init) {
  if (init.headers == null) {
    return doNothing;
  }
  if (typeof init.headers.delete === "function") {
    return callDeleteMethod;
  }
  return deleteFromObject;
}
const redirectStatus = /* @__PURE__ */new Set([301, 302, 303, 307, 308]);
function isRedirect(status) {
  return redirectStatus.has(status);
}
async function handleRedirect(fetchImpl, init, response) {
  switch (init.redirect ?? "follow") {
    case "error":
      throw new TypeError(`URI requested responded with a redirect and redirect mode is set to error: ${response.url}`);
    case "manual":
      return response;
    case "follow":
      break;
    default:
      throw new TypeError(`Invalid redirect option: ${init.redirect}`);
  }
  const locationUrl = response.headers.get("location");
  if (locationUrl === null) {
    return response;
  }
  const requestUrl = response.url;
  const redirectUrl = new URL(locationUrl, requestUrl).toString();
  const redirectCount = init.redirectCount ?? 0;
  const maxRedirect = init.maxRedirect ?? 20;
  if (redirectCount >= maxRedirect) {
    throw new TypeError(`Reached maximum redirect of ${maxRedirect} for URL: ${requestUrl}`);
  }
  init = {
    ...init,
    redirectCount: redirectCount + 1
  };
  const deleteHeader = identifyDeleteHeader(init);
  if (!isDomainOrSubdomain(requestUrl, redirectUrl)) {
    for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
      deleteHeader(init, name);
    }
  }
  const maybeNodeStreamBody = init.body;
  const maybeStreamBody = init.body;
  if (response.status !== 303 && init.body != null && (typeof maybeNodeStreamBody.pipe === "function" || typeof maybeStreamBody.pipeTo === "function")) {
    throw new TypeError("Cannot follow redirect with body being a readable stream");
  }
  if (response.status === 303 || (response.status === 301 || response.status === 302) && init.method === "POST") {
    init.method = "GET";
    init.body = void 0;
    deleteHeader(init, "content-length");
  }
  if (response.headers.has("referrer-policy")) {
    init.referrerPolicy = parseReferrerPolicy(response.headers.get("referrer-policy"));
  }
  return await fetchImpl(redirectUrl, init);
}
function addCookiesToRequest(input, init, cookie) {
  if (cookie === "") {
    return init;
  }
  const maybeRequest = input;
  const maybeHeaders = init.headers;
  if (maybeRequest.headers && typeof maybeRequest.headers.append === "function") {
    maybeRequest.headers.append("cookie", cookie);
  } else if (maybeHeaders && typeof maybeHeaders.append === "function") {
    maybeHeaders.append("cookie", cookie);
  } else {
    init = {
      ...init,
      headers: {
        ...init.headers,
        cookie
      }
    };
  }
  return init;
}
function getCookiesFromResponse(response) {
  const maybeNodeFetchHeaders = response.headers;
  if (typeof maybeNodeFetchHeaders.getAll === "function") {
    return maybeNodeFetchHeaders.getAll("set-cookie");
  }
  if (typeof maybeNodeFetchHeaders.raw === "function") {
    const headers = maybeNodeFetchHeaders.raw();
    if (Array.isArray(headers["set-cookie"])) {
      return headers["set-cookie"];
    }
    return [];
  }
  const cookieString = response.headers.get("set-cookie");
  if (cookieString !== null) {
    return (0, _setCookieParser.splitCookiesString)(cookieString);
  }
  return [];
}
function fetchCookie(fetch, jar, ignoreError = true) {
  const actualFetch = fetch;
  const actualJar = jar ?? new tough.CookieJar();
  async function fetchCookieWrapper(input, init) {
    const originalInit = init ?? {};
    init = {
      ...init,
      redirect: "manual"
    };
    const requestUrl = typeof input === "string" ? input : input.url ?? input.href;
    const cookie = await actualJar.getCookieString(requestUrl);
    init = addCookiesToRequest(input, init, cookie);
    const response = await actualFetch(input, init);
    const cookies = getCookiesFromResponse(response);
    await Promise.all(cookies.map(async cookie2 => await actualJar.setCookie(cookie2, response.url, {
      ignoreError
    })));
    if ((init.redirectCount ?? 0) > 0) {
      Object.defineProperty(response, "redirected", {
        value: true
      });
    }
    if (!isRedirect(response.status)) {
      return response;
    }
    return await handleRedirect(fetchCookieWrapper, originalInit, response);
  }
  fetchCookieWrapper.toughCookie = tough;
  return fetchCookieWrapper;
}
fetchCookie.toughCookie = tough;

},{"set-cookie-parser":67,"tough-cookie":82}],59:[function(require,module,exports){
"use strict";

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

},{"whatwg-fetch":95}],60:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).LosslessJSON={})}(this,(function(t){"use strict";function e(t){return r.test(t)}const r=/^-?[0-9]+$/;function n(t){return o.test(t)}const o=/^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?$/;function i(t,r){const n=parseFloat(t),o=String(n),i=a(t),c=a(o);if(i===c)return!0;if(!0===r?.approx){const r=14;if(!e(t)&&c.length>=r&&i.startsWith(c.substring(0,r)))return!0}return!1}let c=function(t){return t.underflow="underflow",t.overflow="overflow",t.truncate_integer="truncate_integer",t.truncate_float="truncate_float",t}({});function u(t){if(i(t,{approx:!1}))return;if(e(t))return c.truncate_integer;const r=parseFloat(t);return isFinite(r)?0===r?c.underflow:c.truncate_float:c.overflow}function a(t){return t.replace(f,"").replace(l,"").replace(d,"").replace(s,"")}const f=/[eE][+-]?\d+$/,s=/^-?(0*)?/,l=/\./,d=/0+$/;class h{isLosslessNumber=!0;constructor(t){if(!n(t))throw new Error('Invalid number (value: "'+t+'")');this.value=t}valueOf(){const t=u(this.value);if(void 0===t||t===c.truncate_float)return parseFloat(this.value);if(e(this.value))return BigInt(this.value);throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${t} and become ${parseFloat(this.value)}`)}toString(){return this.value}}function p(t){return t&&"object"==typeof t&&!0===t.isLosslessNumber||!1}function y(t){return new h(t)}function w(t,e,r,n){return Array.isArray(r)?n.call(t,e,function(t,e){for(let r=0;r<t.length;r++)t[r]=w(t,r+"",t[r],e);return t}(r,n)):r&&"object"==typeof r&&!p(r)?n.call(t,e,function(t,e){return Object.keys(t).forEach((r=>{const n=w(t,r,t[r],e);void 0!==n?t[r]=n:delete t[r]})),t}(r,n)):n.call(t,e,r)}function b(t){return t>=J&&t<=B||t>=Q&&t<=Z||t>=U&&t<=q}function g(t){return t>=J&&t<=B}function v(t,e){if(t===e)return!0;if(Array.isArray(t)&&Array.isArray(e))return t.length===e.length&&t.every(((t,r)=>v(t,e[r])));if(A(t)&&A(e)){return[...new Set([...Object.keys(t),...Object.keys(e)])].every((r=>v(t[r],e[r])))}return!1}function A(t){return"object"==typeof t&&null!==t}const m={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},C=92,$=123,S=125,x=91,E=93,N=32,O=10,I=9,j=13,k=34,_=43,F=45,J=48,L=49,B=57,D=44,T=46,R=58,Q=65,U=97,P=69,W=101,Z=70,q=102;const z=/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/;t.LosslessNumber=h,t.UnsafeNumberReason=c,t.config=function(t){throw new Error("config is deprecated, support for circularRefs is removed from the library. If you encounter circular references in your data structures, please rethink your datastructures: better prevent circular references in the first place.")},t.getUnsafeNumberReason=u,t.isInteger=e,t.isLosslessNumber=p,t.isNumber=n,t.isSafeNumber=i,t.parse=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:y,n=0;const o=u();return function(t){if(void 0===t)throw new SyntaxError(`JSON value expected ${H()}`)}(o),function(){if(n<t.length)throw new SyntaxError(`Expected end of input ${H()}`)}(),e?function(t,e){return w({"":t},"",t,e)}(o,e):o;function i(){if(t.charCodeAt(n)===$){n++,f();const e={};let r=!0;for(;n<t.length&&t.charCodeAt(n)!==S;){r?r=!1:(l(),f());const t=n,o=s();if(void 0===o)return void A();f(),d();const i=u();if(void 0===i)return void q();Object.prototype.hasOwnProperty.call(e,o)&&!v(i,e[o])&&Q(o,t+1),e[o]=i}return t.charCodeAt(n)!==S&&function(){throw new SyntaxError(`Quoted object key or end of object '}' expected ${H()}`)}(),n++,e}}function c(){if(t.charCodeAt(n)===x){n++,f();const e=[];let r=!0;for(;n<t.length&&t.charCodeAt(n)!==E;){r?r=!1:l();const t=u();h(t),e.push(t)}return t.charCodeAt(n)!==E&&function(){throw new SyntaxError(`Array item or end of array ']' expected ${H()}`)}(),n++,e}}function u(){f();const e=s()??function(){const e=n;t.charCodeAt(n)===F&&(n++,p(e));if(t.charCodeAt(n)===J)n++;else if(o=t.charCodeAt(n),o>=L&&o<=B)for(n++;g(t.charCodeAt(n));)n++;var o;if(t.charCodeAt(n)===T)for(n++,p(e);g(t.charCodeAt(n));)n++;if(t.charCodeAt(n)===W||t.charCodeAt(n)===P)for(n++,t.charCodeAt(n)!==F&&t.charCodeAt(n)!==_||n++,p(e);g(t.charCodeAt(n));)n++;if(n>e)return r(t.slice(e,n))}()??i()??c()??a("true",!0)??a("false",!1)??a("null",null);return f(),e}function a(e,r){if(t.slice(n,n+e.length)===e)return n+=e.length,r}function f(){for(;(e=t.charCodeAt(n))===N||e===O||e===I||e===j;)n++;var e}function s(){if(t.charCodeAt(n)===k){n++;let r="";for(;n<t.length&&t.charCodeAt(n)!==k;){if(t.charCodeAt(n)===C){const e=t[n+1],o=m[e];void 0!==o?(r+=o,n++):"u"===e?b(t.charCodeAt(n+2))&&b(t.charCodeAt(n+3))&&b(t.charCodeAt(n+4))&&b(t.charCodeAt(n+5))?(r+=String.fromCharCode(parseInt(t.slice(n+2,n+6),16)),n+=5):z(n):Z(n)}else(e=t.charCodeAt(n))>=32&&e<=1114111?r+=t[n]:U(t[n]);n++}return function(){if(t.charCodeAt(n)!==k)throw new SyntaxError(`End of string '"' expected ${H()}`)}(),n++,r}var e}function l(){if(t.charCodeAt(n)!==D)throw new SyntaxError(`Comma ',' expected after value ${H()}`);n++}function d(){if(t.charCodeAt(n)!==R)throw new SyntaxError(`Colon ':' expected after property name ${H()}`);n++}function h(t){if(void 0===t)throw new SyntaxError(`Array item expected ${H()}`)}function p(e){if(!g(t.charCodeAt(n))){const r=t.slice(e,n);throw new SyntaxError(`Invalid number '${r}', expecting a digit ${H()}`)}}function A(){throw new SyntaxError(`Quoted object key expected ${H()}`)}function Q(t,e){throw new SyntaxError(`Duplicate key '${t}' encountered at position ${e}`)}function U(t){throw new SyntaxError(`Invalid character '${t}' ${G()}`)}function Z(e){const r=t.slice(e,e+2);throw new SyntaxError(`Invalid escape character '${r}' ${G()}`)}function q(){throw new SyntaxError(`Object value expected after ':' ${G()}`)}function z(e){const r=t.slice(e,e+6);throw new SyntaxError(`Invalid unicode character '${r}' ${G()}`)}function G(){return`at position ${n}`}function H(){return(n<t.length?`but got '${t[n]}'`:"but reached end of input")+" "+G()}},t.parseLosslessNumber=y,t.parseNumberAndBigInt=function(t){return e(t)?BigInt(t):parseFloat(t)},t.reviveDate=function(t,e){return"string"==typeof e&&z.test(e)?new Date(e):e},t.stringify=function t(e,r,o,i){const c=function(t){if("number"==typeof t)return" ".repeat(t);if("string"==typeof t&&""!==t)return t;return}(o);return u("function"==typeof r?r.call({"":e},"",e):e,"");function u(e,a){if(Array.isArray(i)){const t=i.find((t=>t.test(e)));if(t){const r=t.stringify(e);if("string"!=typeof r||!n(r))throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${r})`);return r}}return"boolean"==typeof e||"number"==typeof e||"string"==typeof e||null===e||e instanceof Date||e instanceof Boolean||e instanceof Number||e instanceof String?JSON.stringify(e):e&&e.isLosslessNumber||"bigint"==typeof e?e.toString():Array.isArray(e)?function(t,e){if(0===t.length)return"[]";const n=c?e+c:void 0;let o=c?"[\n":"[";for(let e=0;e<t.length;e++){const i="function"==typeof r?r.call(t,String(e),t[e]):t[e];c&&(o+=n),o+=void 0!==i&&"function"!=typeof i?u(i,n):"null",e<t.length-1&&(o+=c?",\n":",")}return o+=c?"\n"+e+"]":"]",o}(e,a):e&&"object"==typeof e?function(e,n){if("function"==typeof e.toJSON)return t(e.toJSON(),r,o,void 0);const i=Array.isArray(r)?r.map(String):Object.keys(e);if(0===i.length)return"{}";const a=c?n+c:void 0;let f=!0,s=c?"{\n":"{";return i.forEach((t=>{const n="function"==typeof r?r.call(e,t,e[t]):e[t];if(function(t,e){return void 0!==e&&"function"!=typeof e&&"symbol"!=typeof e}(0,n)){f?f=!1:s+=c?",\n":",";const e=JSON.stringify(t);s+=c?a+e+": ":e+":",s+=u(n,a)}})),s+=c?"\n"+n+"}":"}",s}(e,a):void 0}},t.toLosslessNumber=function(t){if(a(t+"").length>15)throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${t})`);if(isNaN(t))throw new Error("Invalid number: NaN");if(!isFinite(t))throw new Error("Invalid number: "+t);return new h(String(t))},t.toSafeNumberOrThrow=function(t,e){const r=parseFloat(t),n=u(t);if(!0===e?.approx?n&&n!==c.truncate_float:n){const e=n?.replace(/_\w+$/,"");throw new Error(`Cannot safely convert to number: the value '${t}' would ${e} and become ${r}`)}return r}}));

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ungzip = exports.inflateRaw = exports.inflate = exports.gzip = exports.deflateRaw = exports.deflate = exports.default = exports.constants = exports.Inflate = exports.Deflate = void 0;
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/

//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1 = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY = 0;
const Z_TEXT = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1 = 2;

/*============================================================================*/

function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
/* The three kinds of block type */

const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1 = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1 = 256;
/* number of literal bytes 0..255 */

const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1 = 30;
/* number of distance codes */

const BL_CODES$1 = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1 = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK = 256;
/* end of block literal code */

const REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits = /* extra bits for each length code */
new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
const extra_dbits = /* extra bits for each distance code */
new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
const extra_blbits = /* extra bits for each bit length code */
new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree; /* static tree or NULL */
  this.extra_bits = extra_bits; /* extra bits for each code or NULL */
  this.extra_base = extra_base; /* base index for extra_bits */
  this.elems = elems; /* max number of elements in the tree */
  this.max_length = max_length; /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree; /* the dynamic tree */
  this.max_code = 0; /* largest code with non zero frequency */
  this.stat_desc = stat_desc; /* the corresponding static tree */
}
const d_code = dist => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
};

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/);
};

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = s => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc;    /* the tree descriptor */

  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h; /* heap index */
  let n, m; /* iterate over the tree elements */
  let bits; /* bit length */
  let xbits; /* extra bits */
  let f; /* frequency */
  let overflow = 0; /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] /*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2] /*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--; /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] /*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1] /*.Len*/) * tree[m * 2] /*.Freq*/;
        tree[m * 2 + 1] /*.Len*/ = bits;
      }
      n--;
    }
  }
};

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
  //    ct_data *tree;             /* the tree to decorate */
  //    int max_code;              /* largest code with non zero frequency */
  //    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0; /* running code value */
  let bits; /* bit index */
  let n; /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1] /*.Len*/;
    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */
    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {
  let n; /* iterates over tree elements */
  let bits; /* bit counter */
  let length; /* length value */
  let code; /* code value */
  let dist; /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] /*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] /*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] /*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] /*.Len*/ = 5;
    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};

/* ===========================================================================
 * Initialize a new block.
 */
const init_block = s => {
  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] /*.Freq*/ = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] /*.Freq*/ = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = s => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ || tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m];
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
  //    deflate_state *s;
  //    ct_data *tree;  /* the tree to restore */
  //    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1; /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};

// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
  //    deflate_state *s;
  //    const ct_data *ltree; /* literal tree */
  //    const ct_data *dtree; /* distance tree */

  let dist; /* distance of matched string */
  let lc; /* match length or unmatched char (if dist == 0) */
  let sx = 0; /* running index in sym_buf */
  let code; /* the code to send */
  let extra; /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra); /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree); /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra); /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc; /* the tree descriptor */

  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m; /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node; /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] /*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] /*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] /*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1] /*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems; /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1 /*SMALLEST*/];
    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1 /*SMALLEST*/);
    /***/

    m = s.heap[1 /*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1 /*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1 /*SMALLEST*/);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree;   /* the tree to be scanned */
  //    int max_code;    /* and its largest code of non zero frequency */

  let n; /* iterates over all tree elements */
  let prevlen = -1; /* last emitted length */
  let curlen; /* length of current code */

  let nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  let count = 0; /* repeat count of the current code */
  let max_count = 7; /* max repeat count */
  let min_count = 4; /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] /*.Freq*/ += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }
      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree; /* the tree to be scanned */
  //    int max_code;       /* and its largest code of non zero frequency */

  let n; /* iterates over all tree elements */
  let prevlen = -1; /* last emitted length */
  let curlen; /* length of current code */

  let nextlen = tree[0 * 2 + 1] /*.Len*/; /* length of next code */

  let count = 0; /* repeat count of the current code */
  let max_count = 7; /* max repeat count */
  let min_count = 4; /* min repeat count */

  /* tree[max_code+1].Len = -1; */ /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/;
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = s => {
  let max_blindex; /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  //    deflate_state *s;
  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank; /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = s => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 || s.dyn_ltree[13 * 2] /*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};
let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = s => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};

/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */
  bi_windup(s); /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = s => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block, or NULL if too old */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb; /* opt_len and static_len in bytes */
  let max_blindex = 0; /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);
  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
  //    deflate_state *s;
  //    unsigned dist;  /* distance of matched string */
  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--; /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 0xffff | 0,
    s2 = adler >>> 16 & 0xffff | 0,
    n = 0;
  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c,
    table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }
  return crc ^ -1; // >>> 0;
};
var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2: 'need dictionary',
  /* Z_NEED_DICT       2  */
  1: 'stream end',
  /* Z_STREAM_END      1  */
  0: '',
  /* Z_OK              0  */
  '-1': 'file error',
  /* Z_ERRNO         (-1) */
  '-2': 'stream error',
  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',
  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',
  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',
  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const {
  _tr_init,
  _tr_stored_block,
  _tr_flush_block,
  _tr_tally,
  _tr_align
} = trees;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/

const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS = 256;
/* number of literal bytes 0..255 */
const L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES = 30;
/* number of distance codes */
const BL_CODES = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 0x20;
const INIT_STATE = 42; /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE = 57; /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE = 69; /* gzip extra block -> NAME_STATE */
const NAME_STATE = 73; /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE = 91; /* gzip comment -> HCRC_STATE */
const HCRC_STATE = 103; /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE = 113; /* deflate -> FINISH_STATE */
const FINISH_STATE = 666; /* stream complete */

const BS_NEED_MORE = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = f => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = buf => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = s => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  //#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
  //#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = strm => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length; /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match; /* matched string */
  let len; /* length of current match */
  let best_len = s.prev_length; /* best match length so far */
  let nice_match = s.nice_match; /* stop if match long enough */
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/;
  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = s => {
  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    const curr = s.strstart + s.lookahead;
  //    let init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {
  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len,
    left,
    have,
    last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535 /* MAX_STORED */; /* maximum deflate stored block length */
    have = s.bi_valid + 42 >> 3; /* number of header bytes */
    if (s.strm.avail_out < have) {
      /* need room for header */
      break;
    }
    /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start; /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in; /* limit len to the input */
    }
    if (len > have) {
      len = have; /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

    //#ifdef ZLIB_DEBUG
    //    /* Update debugging counts for the data about to be copied. */
    //    s->compressed_len += len << 3;
    //    s->bits_sent += len << 3;
    //#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in; /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {
      /* supplant the previous history */
      s.matches = 2; /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++; /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++; /* add a pending slide_hash() */
    }
    have += s.w_size; /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = s.bi_valid + 42 >> 3; /* number of header bytes */
  /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535 /* MAX_STORED */ ? 65535 /* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {
  let hash_head; /* head of the hash chain */
  let bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0 /*NIL*/ && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match /*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

        //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {
  let hash_head; /* head of hash chain */
  let bflush; /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0 /*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 /*NIL*/ && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/)) {
        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {
  let bflush; /* set if current block must be flushed */
  let prev; /* byte at distance one to match */
  let scan, strend; /* scan goes up to strend for length of run */

  const _win = s.window;
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {
  let bflush; /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break; /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored), /* 0 store only */
new Config(4, 4, 8, 4, deflate_fast), /* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast), /* 2 */
new Config(4, 6, 32, 32, deflate_fast), /* 3 */

new Config(4, 4, 16, 16, deflate_slow), /* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow), /* 5 */
new Config(8, 16, 128, 128, deflate_slow), /* 6 */
new Config(8, 32, 128, 256, deflate_slow), /* 7 */
new Config(32, 128, 258, 1024, deflate_slow), /* 8 */
new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */];

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = s => {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.status = 0; /* as the name implies */
  this.pending_buf = null; /* output still pending */
  this.pending_buf_size = 0; /* size of pending_buf */
  this.pending_out = 0; /* next pending byte to output to the stream */
  this.pending = 0; /* nb of bytes in the pending buffer */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null; /* gzip header information to write */
  this.gzindex = 0; /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1; /* value of flush param for previous deflate call */

  this.w_size = 0; /* LZ77 window size (32K by default) */
  this.w_bits = 0; /* log2(w_size)  (8..16) */
  this.w_mask = 0; /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null; /* Heads of the hash chains or NIL. */

  this.ins_h = 0; /* hash index of string to be inserted */
  this.hash_size = 0; /* number of elements in hash table */
  this.hash_bits = 0; /* log2(hash_size) */
  this.hash_mask = 0; /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0; /* length of best match */
  this.prev_match = 0; /* previous match */
  this.match_available = 0; /* set if previous match exists */
  this.strstart = 0; /* start of string to insert */
  this.match_start = 0; /* start of matching string */
  this.lookahead = 0; /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0; /* compression level (1..9) */
  this.strategy = 0; /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null; /* desc. for literal tree */
  this.d_desc = null; /* desc. for distance tree */
  this.bl_desc = null; /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1); /* heap used to build the Huffman trees */
  zero(this.heap);
  this.heap_len = 0; /* number of elements in the heap */
  this.heap_max = 0; /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0; /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0; /* running index in sym_buf */
  this.sym_end = 0; /* symbol table full when sym_next reaches this */

  this.opt_len = 0; /* bit length of current block with optimal trees */
  this.static_len = 0; /* bit length of current block with static trees */
  this.matches = 0; /* number of string matches in current block */
  this.insert = 0; /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = strm => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE &&
  //#ifdef GZIP
  s.status !== GZIP_STATE &&
  //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = strm => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
  //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE :
  //#endif
  s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = strm => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2; /* write gzip wrapper instead */
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE; /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};

/* ========================================================================= */
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  //#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0; //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, s.gzhead.time >> 8 & 0xff);
      put_byte(s, s.gzhead.time >> 16 & 0xff);
      put_byte(s, s.gzhead.time >> 24 & 0xff);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment /* != Z_NULL*/) {
      let beg = s.pending; /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, strm.adler >> 8 & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  //#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/ /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }
  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = strm => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};

/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0; /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo: deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};

// Join array of chunks to single array.
var flattenChunks = chunks => {
  // calculate data length
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign: assign,
  flattenChunks: flattenChunks
};

// String encode/decode helpers

// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = str => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf,
    c,
    c2,
    m_pos,
    i,
    str_len = str.length,
    buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | c >>> 6;
      buf[i++] = 0x80 | c & 0x3f;
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | c >>> 12;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | c >>> 18;
      buf[i++] = 0x80 | c >>> 12 & 0x3f;
      buf[i++] = 0x80 | c >>> 6 & 0x3f;
      buf[i++] = 0x80 | c & 0x3f;
    }
  }
  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};

// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) {
      utf16buf[out++] = 0xfffd;
      i += c_len - 1;
      continue;
    }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 0x3f;
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) {
      utf16buf[out++] = 0xfffd;
      continue;
    }
    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;
      utf16buf[out++] = 0xdc00 | c & 0x3ff;
    }
  }
  return buf2binstring(utf16buf, out);
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
    pos--;
  }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) {
    return max;
  }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf: string2buf,
  buf2string: buf2string,
  utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = '' /*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2 /*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/

/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/

/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};

/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}

/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}

/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209; /* got a data error -- remain here until reset */
const TYPE$1 = 16191; /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in; /* local strm.input */
  let last; /* have enough input while in < last */
  let _out; /* local strm.output */
  let beg; /* inflate()'s initial strm.output */
  let end; /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
  let dmax; /* maximum distance from zlib header */
  //#endif
  let wsize; /* window size or zero if not using window */
  let whave; /* valid bytes in the window */
  let wnext; /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window; /* allocated sliding window, if wsize != 0 */
  let hold; /* local strm.hold */
  let bits; /* local strm.bits */
  let lcode; /* local strm.lencode */
  let dcode; /* local strm.distcode */
  let lmask; /* mask for first level of length codes */
  let dmask; /* mask for first level of distance codes */
  let here; /* retrieved table entry */
  let op; /* code bits, operation, extra bits, or */
  /*  window position, window bytes to copy */
  let len; /* match length, unused bytes */
  let dist; /* match distance */
  let from; /* where to copy match from */
  let from_source;
  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
  dmax = state.dmax;
  //#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;

  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24 /*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff /*here.op*/;
      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff /*here.val*/;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff /*here.val*/;
        op &= 15; /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (;;) {
          // goto emulation
          op = here >>> 24 /*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff /*here.op*/;
          if (op & 16) {
            /* distance base */
            dist = here & 0xffff /*here.val*/;
            op &= 15; /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            //#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
            //#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg; /* max distance in output */
            if (dist > op) {
              /* see if copy from window */
              op = dist - op; /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {
                /* very common case */
                from += wsize - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist; /* rest from output */
                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;
                if (op < len) {
                  /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist; /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist; /* copy direct from output */
              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }
          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff /*here.val*/) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }
      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
const lext = new Uint8Array([/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
const dbase = new Uint16Array([/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
const dext = new Uint8Array([/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  //here = opts.here; /* table entry for duplication */

  let len = 0; /* a code's length in bits */
  let sym = 0; /* index of code symbols */
  let min = 0,
    max = 0; /* minimum and maximum code lengths */
  let root = 0; /* number of index bits for root table */
  let curr = 0; /* number of index bits for current table */
  let drop = 0; /* code bits to drop for sub-table */
  let left = 0; /* number of prefix codes available */
  let used = 0; /* code entries in table used */
  let huff = 0; /* Huffman code */
  let incr; /* for incrementing code, index */
  let fill; /* index for replicating entries */
  let low; /* low bits for current root entry */
  let mask; /* mask for low root bits */
  let next; /* next available space in table */
  let base = null; /* base value table to use */
  //  let shoextra;    /* extra bits table to use */
  let match; /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;

    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0; /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    } /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1; /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work; /* dummy value--not used */
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0; /* starting code */
  sym = 0; /* starting code symbol */
  len = min; /* starting code length */
  next = table_index; /* current table to fill in */
  curr = root; /* current table index bits */
  drop = 0; /* current bits to drop from code for index */
  low = -1; /* trigger new sub-table when len > root */
  used = 1 << root; /* use root table entries */
  mask = used - 1; /* mask for comparing low */

  /* check available table space */
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64; /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill; /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min; /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;

/* STATES ====================================================================*/
/* ===========================================================================*/

const HEAD = 16180; /* i: waiting for magic header */
const FLAGS = 16181; /* i: waiting for method and flags (gzip) */
const TIME = 16182; /* i: waiting for modification time (gzip) */
const OS = 16183; /* i: waiting for extra flags and operating system (gzip) */
const EXLEN = 16184; /* i: waiting for extra length (gzip) */
const EXTRA = 16185; /* i: waiting for extra bytes (gzip) */
const NAME = 16186; /* i: waiting for end of file name (gzip) */
const COMMENT = 16187; /* i: waiting for end of comment (gzip) */
const HCRC = 16188; /* i: waiting for header crc (gzip) */
const DICTID = 16189; /* i: waiting for dictionary check value */
const DICT = 16190; /* waiting for inflateSetDictionary() call */
const TYPE = 16191; /* i: waiting for type bits, including last-flag bit */
const TYPEDO = 16192; /* i: same, but skip check to exit inflate on new block */
const STORED = 16193; /* i: waiting for stored size (length and complement) */
const COPY_ = 16194; /* i/o: same as COPY below, but only first time in */
const COPY = 16195; /* i/o: waiting for input or output to copy stored block */
const TABLE = 16196; /* i: waiting for dynamic block table lengths */
const LENLENS = 16197; /* i: waiting for code length code lengths */
const CODELENS = 16198; /* i: waiting for length/lit and distance code lengths */
const LEN_ = 16199; /* i: same as LEN below, but only first time in */
const LEN = 16200; /* i: waiting for length/lit/eob code */
const LENEXT = 16201; /* i: waiting for length extra bits */
const DIST = 16202; /* i: waiting for distance code */
const DISTEXT = 16203; /* i: waiting for distance extra bits */
const MATCH = 16204; /* o: waiting for output space to copy string */
const LIT = 16205; /* o: waiting for output space to write literal */
const CHECK = 16206; /* i: waiting for 32-bit check value */
const LENGTH = 16207; /* i: waiting for 32-bit length (gzip) */
const DONE = 16208; /* finished check, done -- remain here until reset */
const BAD = 16209; /* got a data error -- remain here until reset */
const MEM = 16210; /* got an inflate() memory error -- remain here until reset */
const SYNC = 16211; /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;
const zswap32 = q => {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
};
function InflateState() {
  this.strm = null; /* pointer back to this zlib stream */
  this.mode = 0; /* current inflate mode */
  this.last = false; /* true if processing last block */
  this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip,
                    bit 2 true to validate check value */
  this.havedict = false; /* true if dictionary provided */
  this.flags = 0; /* gzip header method and flags (0 if zlib), or
                     -1 if raw or no header yet */
  this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0; /* protected copy of check value */
  this.total = 0; /* protected copy of output count */
  // TODO: may be {}
  this.head = null; /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0; /* log base 2 of requested window size */
  this.wsize = 0; /* window size or zero if not using window */
  this.whave = 0; /* valid bytes in the window */
  this.wnext = 0; /* window write index */
  this.window = null; /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0; /* input bit accumulator */
  this.bits = 0; /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0; /* literal or length of data to copy */
  this.offset = 0; /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0; /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null; /* starting table for length/literal codes */
  this.distcode = null; /* starting table for distance codes */
  this.lenbits = 0; /* index bits for lencode */
  this.distbits = 0; /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0; /* number of code length code lengths */
  this.nlen = 0; /* number of length code lengths */
  this.ndist = 0; /* number of distance code lengths */
  this.have = 0; /* number of code lengths in lens[] */
  this.next = null; /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null; /* dynamic table for distance codes (JS specific) */
  this.sane = 0; /* if false, allow invalid distance too far */
  this.back = 0; /* bits back of last unprocessed length/lit */
  this.was = 0; /* initial length of match */
}
const inflateStateCheck = strm => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null /*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};
const inflateReset = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null /*Z_NULL*/;
  state.mode = HEAD; /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null /*Z_NULL*/;
  }
  return ret;
};
const inflateInit = strm => {
  return inflateInit2(strm, DEF_WBITS);
};

/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;
let lenfix, distfix; // We have no pointers in JS, so keep tables separate

const fixedtables = state => {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });

    /* distance table */
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });

    /* do this just once */
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};

/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output; // input/output buffers
  let next; /* next input INDEX */
  let put; /* next output INDEX */
  let have, left; /* available input and output */
  let hold; /* bit buffer */
  let bits; /* bits in bit buffer */
  let _in, _out; /* save starting available input and output */
  let copy; /* number of stored or match bytes to copy */
  let from; /* where to copy match bytes from */
  let from_source;
  let here = 0; /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len; /* length to copy for repeats, bits to drop */
  let ret; /* return code */
  const hbuf = new Uint8Array(4); /* buffer for gzip header crc calculation */
  let opts;
  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
  new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  } /* skip check */

  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
  // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) || /* check if zlib header allowed */
        (((hold & 0xff /*BITS(8)*/) << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f /*BITS(4)*/) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f /*BITS(4)*/) + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0; /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
      /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
      /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }
        if (state.flags & 0x0200 && state.wrap & 4) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
      /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200 && state.wrap & 4) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        } else if (state.head) {
          state.head.extra = null /*Z_NULL*/;
        }
        state.mode = EXTRA;
      /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) {
            copy = have;
          }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(input.subarray(next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              next + copy), /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len);
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) {
            break inf_leave;
          }
        }
        state.length = 0;
        state.mode = NAME;
      /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.name_max*/) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200 && state.wrap & 4) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
      /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len && state.length < 65536 /*state.head.comm_max*/) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200 && state.wrap & 4) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
      /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.wrap & 4 && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
      /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
      /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = hold & 0x01 /*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch (hold & 0x03 /*BITS(2)*/) {
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:
            /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_; /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case COPY_:
        state.mode = COPY;
      /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) {
            copy = have;
          }
          if (copy > left) {
            copy = left;
          }
          if (copy === 0) {
            break inf_leave;
          }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f /*BITS(5)*/) + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f /*BITS(5)*/) + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f /*BITS(4)*/) + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        //#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
      /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;
        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
      /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) {
          break;
        }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }
        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) {
          break inf_leave;
        }
      /* falls through */
      case LEN_:
        state.mode = LEN;
      /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;
          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
      /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
      /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;
          if (here_bits <= bits) {
            break;
          }
          //--- PULLBYTE() ---//
          if (have === 0) {
            break inf_leave;
          }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1 /*BITS(last.bits + last.op)*/) >> last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;
            if (last_bits + here_bits <= bits) {
              break;
            }
            //--- PULLBYTE() ---//
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;
      /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
        //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
      /* falls through */
      case MATCH:
        if (left === 0) {
          break inf_leave;
        }
        copy = _out - left;
        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }
          if (copy > state.length) {
            copy = state.length;
          }
          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) {
          copy = left;
        }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) {
          state.mode = LEN;
        }
        break;
      case LIT:
        if (left === 0) {
          break inf_leave;
        }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap & 4 && _out) {
            strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
      /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.wrap & 4 && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
      /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
      /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = strm => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  /* check state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text = 0;
  /* modification time */
  this.time = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags = 0;
  /* operating system */
  this.os = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len = 0; // Actually, we don't need it in JS,
  // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/

/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});
  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0; // error code, if happens (0 = Z_OK)
  this.msg = ''; // error message
  this.ended = false; // used to avoid multiple onEnd() calls
  this.chunks = []; // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === 'string') {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};

/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};

/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}

/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}

/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/

var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants
};
const {
  Deflate,
  deflate,
  deflateRaw,
  gzip
} = deflate_1$1;
const {
  Inflate,
  inflate,
  inflateRaw,
  ungzip
} = inflate_1$1;
var Deflate_1 = exports.Deflate = Deflate;
var deflate_1 = exports.deflate = deflate;
var deflateRaw_1 = exports.deflateRaw = deflateRaw;
var gzip_1 = exports.gzip = gzip;
var Inflate_1 = exports.Inflate = Inflate;
var inflate_1 = exports.inflate = inflate;
var inflateRaw_1 = exports.inflateRaw = inflateRaw;
var ungzip_1 = exports.ungzip = ungzip;
var constants_1 = exports.constants = constants$2;
var pako = exports.default = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

},{}],62:[function(require,module,exports){
module.exports=[
"ac",
"com.ac",
"edu.ac",
"gov.ac",
"net.ac",
"mil.ac",
"org.ac",
"ad",
"nom.ad",
"ae",
"co.ae",
"net.ae",
"org.ae",
"sch.ae",
"ac.ae",
"gov.ae",
"mil.ae",
"aero",
"accident-investigation.aero",
"accident-prevention.aero",
"aerobatic.aero",
"aeroclub.aero",
"aerodrome.aero",
"agents.aero",
"aircraft.aero",
"airline.aero",
"airport.aero",
"air-surveillance.aero",
"airtraffic.aero",
"air-traffic-control.aero",
"ambulance.aero",
"amusement.aero",
"association.aero",
"author.aero",
"ballooning.aero",
"broker.aero",
"caa.aero",
"cargo.aero",
"catering.aero",
"certification.aero",
"championship.aero",
"charter.aero",
"civilaviation.aero",
"club.aero",
"conference.aero",
"consultant.aero",
"consulting.aero",
"control.aero",
"council.aero",
"crew.aero",
"design.aero",
"dgca.aero",
"educator.aero",
"emergency.aero",
"engine.aero",
"engineer.aero",
"entertainment.aero",
"equipment.aero",
"exchange.aero",
"express.aero",
"federation.aero",
"flight.aero",
"fuel.aero",
"gliding.aero",
"government.aero",
"groundhandling.aero",
"group.aero",
"hanggliding.aero",
"homebuilt.aero",
"insurance.aero",
"journal.aero",
"journalist.aero",
"leasing.aero",
"logistics.aero",
"magazine.aero",
"maintenance.aero",
"media.aero",
"microlight.aero",
"modelling.aero",
"navigation.aero",
"parachuting.aero",
"paragliding.aero",
"passenger-association.aero",
"pilot.aero",
"press.aero",
"production.aero",
"recreation.aero",
"repbody.aero",
"res.aero",
"research.aero",
"rotorcraft.aero",
"safety.aero",
"scientist.aero",
"services.aero",
"show.aero",
"skydiving.aero",
"software.aero",
"student.aero",
"trader.aero",
"trading.aero",
"trainer.aero",
"union.aero",
"workinggroup.aero",
"works.aero",
"af",
"gov.af",
"com.af",
"org.af",
"net.af",
"edu.af",
"ag",
"com.ag",
"org.ag",
"net.ag",
"co.ag",
"nom.ag",
"ai",
"off.ai",
"com.ai",
"net.ai",
"org.ai",
"al",
"com.al",
"edu.al",
"gov.al",
"mil.al",
"net.al",
"org.al",
"am",
"co.am",
"com.am",
"commune.am",
"net.am",
"org.am",
"ao",
"ed.ao",
"gv.ao",
"og.ao",
"co.ao",
"pb.ao",
"it.ao",
"aq",
"ar",
"bet.ar",
"com.ar",
"coop.ar",
"edu.ar",
"gob.ar",
"gov.ar",
"int.ar",
"mil.ar",
"musica.ar",
"mutual.ar",
"net.ar",
"org.ar",
"senasa.ar",
"tur.ar",
"arpa",
"e164.arpa",
"in-addr.arpa",
"ip6.arpa",
"iris.arpa",
"uri.arpa",
"urn.arpa",
"as",
"gov.as",
"asia",
"at",
"ac.at",
"co.at",
"gv.at",
"or.at",
"sth.ac.at",
"au",
"com.au",
"net.au",
"org.au",
"edu.au",
"gov.au",
"asn.au",
"id.au",
"info.au",
"conf.au",
"oz.au",
"act.au",
"nsw.au",
"nt.au",
"qld.au",
"sa.au",
"tas.au",
"vic.au",
"wa.au",
"act.edu.au",
"catholic.edu.au",
"nsw.edu.au",
"nt.edu.au",
"qld.edu.au",
"sa.edu.au",
"tas.edu.au",
"vic.edu.au",
"wa.edu.au",
"qld.gov.au",
"sa.gov.au",
"tas.gov.au",
"vic.gov.au",
"wa.gov.au",
"schools.nsw.edu.au",
"aw",
"com.aw",
"ax",
"az",
"com.az",
"net.az",
"int.az",
"gov.az",
"org.az",
"edu.az",
"info.az",
"pp.az",
"mil.az",
"name.az",
"pro.az",
"biz.az",
"ba",
"com.ba",
"edu.ba",
"gov.ba",
"mil.ba",
"net.ba",
"org.ba",
"bb",
"biz.bb",
"co.bb",
"com.bb",
"edu.bb",
"gov.bb",
"info.bb",
"net.bb",
"org.bb",
"store.bb",
"tv.bb",
"*.bd",
"be",
"ac.be",
"bf",
"gov.bf",
"bg",
"a.bg",
"b.bg",
"c.bg",
"d.bg",
"e.bg",
"f.bg",
"g.bg",
"h.bg",
"i.bg",
"j.bg",
"k.bg",
"l.bg",
"m.bg",
"n.bg",
"o.bg",
"p.bg",
"q.bg",
"r.bg",
"s.bg",
"t.bg",
"u.bg",
"v.bg",
"w.bg",
"x.bg",
"y.bg",
"z.bg",
"0.bg",
"1.bg",
"2.bg",
"3.bg",
"4.bg",
"5.bg",
"6.bg",
"7.bg",
"8.bg",
"9.bg",
"bh",
"com.bh",
"edu.bh",
"net.bh",
"org.bh",
"gov.bh",
"bi",
"co.bi",
"com.bi",
"edu.bi",
"or.bi",
"org.bi",
"biz",
"bj",
"asso.bj",
"barreau.bj",
"gouv.bj",
"bm",
"com.bm",
"edu.bm",
"gov.bm",
"net.bm",
"org.bm",
"bn",
"com.bn",
"edu.bn",
"gov.bn",
"net.bn",
"org.bn",
"bo",
"com.bo",
"edu.bo",
"gob.bo",
"int.bo",
"org.bo",
"net.bo",
"mil.bo",
"tv.bo",
"web.bo",
"academia.bo",
"agro.bo",
"arte.bo",
"blog.bo",
"bolivia.bo",
"ciencia.bo",
"cooperativa.bo",
"democracia.bo",
"deporte.bo",
"ecologia.bo",
"economia.bo",
"empresa.bo",
"indigena.bo",
"industria.bo",
"info.bo",
"medicina.bo",
"movimiento.bo",
"musica.bo",
"natural.bo",
"nombre.bo",
"noticias.bo",
"patria.bo",
"politica.bo",
"profesional.bo",
"plurinacional.bo",
"pueblo.bo",
"revista.bo",
"salud.bo",
"tecnologia.bo",
"tksat.bo",
"transporte.bo",
"wiki.bo",
"br",
"9guacu.br",
"abc.br",
"adm.br",
"adv.br",
"agr.br",
"aju.br",
"am.br",
"anani.br",
"aparecida.br",
"app.br",
"arq.br",
"art.br",
"ato.br",
"b.br",
"barueri.br",
"belem.br",
"bhz.br",
"bib.br",
"bio.br",
"blog.br",
"bmd.br",
"boavista.br",
"bsb.br",
"campinagrande.br",
"campinas.br",
"caxias.br",
"cim.br",
"cng.br",
"cnt.br",
"com.br",
"contagem.br",
"coop.br",
"coz.br",
"cri.br",
"cuiaba.br",
"curitiba.br",
"def.br",
"des.br",
"det.br",
"dev.br",
"ecn.br",
"eco.br",
"edu.br",
"emp.br",
"enf.br",
"eng.br",
"esp.br",
"etc.br",
"eti.br",
"far.br",
"feira.br",
"flog.br",
"floripa.br",
"fm.br",
"fnd.br",
"fortal.br",
"fot.br",
"foz.br",
"fst.br",
"g12.br",
"geo.br",
"ggf.br",
"goiania.br",
"gov.br",
"ac.gov.br",
"al.gov.br",
"am.gov.br",
"ap.gov.br",
"ba.gov.br",
"ce.gov.br",
"df.gov.br",
"es.gov.br",
"go.gov.br",
"ma.gov.br",
"mg.gov.br",
"ms.gov.br",
"mt.gov.br",
"pa.gov.br",
"pb.gov.br",
"pe.gov.br",
"pi.gov.br",
"pr.gov.br",
"rj.gov.br",
"rn.gov.br",
"ro.gov.br",
"rr.gov.br",
"rs.gov.br",
"sc.gov.br",
"se.gov.br",
"sp.gov.br",
"to.gov.br",
"gru.br",
"imb.br",
"ind.br",
"inf.br",
"jab.br",
"jampa.br",
"jdf.br",
"joinville.br",
"jor.br",
"jus.br",
"leg.br",
"lel.br",
"log.br",
"londrina.br",
"macapa.br",
"maceio.br",
"manaus.br",
"maringa.br",
"mat.br",
"med.br",
"mil.br",
"morena.br",
"mp.br",
"mus.br",
"natal.br",
"net.br",
"niteroi.br",
"*.nom.br",
"not.br",
"ntr.br",
"odo.br",
"ong.br",
"org.br",
"osasco.br",
"palmas.br",
"poa.br",
"ppg.br",
"pro.br",
"psc.br",
"psi.br",
"pvh.br",
"qsl.br",
"radio.br",
"rec.br",
"recife.br",
"rep.br",
"ribeirao.br",
"rio.br",
"riobranco.br",
"riopreto.br",
"salvador.br",
"sampa.br",
"santamaria.br",
"santoandre.br",
"saobernardo.br",
"saogonca.br",
"seg.br",
"sjc.br",
"slg.br",
"slz.br",
"sorocaba.br",
"srv.br",
"taxi.br",
"tc.br",
"tec.br",
"teo.br",
"the.br",
"tmp.br",
"trd.br",
"tur.br",
"tv.br",
"udi.br",
"vet.br",
"vix.br",
"vlog.br",
"wiki.br",
"zlg.br",
"bs",
"com.bs",
"net.bs",
"org.bs",
"edu.bs",
"gov.bs",
"bt",
"com.bt",
"edu.bt",
"gov.bt",
"net.bt",
"org.bt",
"bv",
"bw",
"co.bw",
"org.bw",
"by",
"gov.by",
"mil.by",
"com.by",
"of.by",
"bz",
"com.bz",
"net.bz",
"org.bz",
"edu.bz",
"gov.bz",
"ca",
"ab.ca",
"bc.ca",
"mb.ca",
"nb.ca",
"nf.ca",
"nl.ca",
"ns.ca",
"nt.ca",
"nu.ca",
"on.ca",
"pe.ca",
"qc.ca",
"sk.ca",
"yk.ca",
"gc.ca",
"cat",
"cc",
"cd",
"gov.cd",
"cf",
"cg",
"ch",
"ci",
"org.ci",
"or.ci",
"com.ci",
"co.ci",
"edu.ci",
"ed.ci",
"ac.ci",
"net.ci",
"go.ci",
"asso.ci",
"aroport.ci",
"int.ci",
"presse.ci",
"md.ci",
"gouv.ci",
"*.ck",
"!www.ck",
"cl",
"co.cl",
"gob.cl",
"gov.cl",
"mil.cl",
"cm",
"co.cm",
"com.cm",
"gov.cm",
"net.cm",
"cn",
"ac.cn",
"com.cn",
"edu.cn",
"gov.cn",
"net.cn",
"org.cn",
"mil.cn",
".cn",
".cn",
".cn",
"ah.cn",
"bj.cn",
"cq.cn",
"fj.cn",
"gd.cn",
"gs.cn",
"gz.cn",
"gx.cn",
"ha.cn",
"hb.cn",
"he.cn",
"hi.cn",
"hl.cn",
"hn.cn",
"jl.cn",
"js.cn",
"jx.cn",
"ln.cn",
"nm.cn",
"nx.cn",
"qh.cn",
"sc.cn",
"sd.cn",
"sh.cn",
"sn.cn",
"sx.cn",
"tj.cn",
"xj.cn",
"xz.cn",
"yn.cn",
"zj.cn",
"hk.cn",
"mo.cn",
"tw.cn",
"co",
"arts.co",
"com.co",
"edu.co",
"firm.co",
"gov.co",
"info.co",
"int.co",
"mil.co",
"net.co",
"nom.co",
"org.co",
"rec.co",
"web.co",
"com",
"coop",
"cr",
"ac.cr",
"co.cr",
"ed.cr",
"fi.cr",
"go.cr",
"or.cr",
"sa.cr",
"cu",
"com.cu",
"edu.cu",
"org.cu",
"net.cu",
"gov.cu",
"inf.cu",
"cv",
"com.cv",
"edu.cv",
"int.cv",
"nome.cv",
"org.cv",
"cw",
"com.cw",
"edu.cw",
"net.cw",
"org.cw",
"cx",
"gov.cx",
"cy",
"ac.cy",
"biz.cy",
"com.cy",
"ekloges.cy",
"gov.cy",
"ltd.cy",
"mil.cy",
"net.cy",
"org.cy",
"press.cy",
"pro.cy",
"tm.cy",
"cz",
"de",
"dj",
"dk",
"dm",
"com.dm",
"net.dm",
"org.dm",
"edu.dm",
"gov.dm",
"do",
"art.do",
"com.do",
"edu.do",
"gob.do",
"gov.do",
"mil.do",
"net.do",
"org.do",
"sld.do",
"web.do",
"dz",
"art.dz",
"asso.dz",
"com.dz",
"edu.dz",
"gov.dz",
"org.dz",
"net.dz",
"pol.dz",
"soc.dz",
"tm.dz",
"ec",
"com.ec",
"info.ec",
"net.ec",
"fin.ec",
"k12.ec",
"med.ec",
"pro.ec",
"org.ec",
"edu.ec",
"gov.ec",
"gob.ec",
"mil.ec",
"edu",
"ee",
"edu.ee",
"gov.ee",
"riik.ee",
"lib.ee",
"med.ee",
"com.ee",
"pri.ee",
"aip.ee",
"org.ee",
"fie.ee",
"eg",
"com.eg",
"edu.eg",
"eun.eg",
"gov.eg",
"mil.eg",
"name.eg",
"net.eg",
"org.eg",
"sci.eg",
"*.er",
"es",
"com.es",
"nom.es",
"org.es",
"gob.es",
"edu.es",
"et",
"com.et",
"gov.et",
"org.et",
"edu.et",
"biz.et",
"name.et",
"info.et",
"net.et",
"eu",
"fi",
"aland.fi",
"fj",
"ac.fj",
"biz.fj",
"com.fj",
"gov.fj",
"info.fj",
"mil.fj",
"name.fj",
"net.fj",
"org.fj",
"pro.fj",
"*.fk",
"com.fm",
"edu.fm",
"net.fm",
"org.fm",
"fm",
"fo",
"fr",
"asso.fr",
"com.fr",
"gouv.fr",
"nom.fr",
"prd.fr",
"tm.fr",
"aeroport.fr",
"avocat.fr",
"avoues.fr",
"cci.fr",
"chambagri.fr",
"chirurgiens-dentistes.fr",
"experts-comptables.fr",
"geometre-expert.fr",
"greta.fr",
"huissier-justice.fr",
"medecin.fr",
"notaires.fr",
"pharmacien.fr",
"port.fr",
"veterinaire.fr",
"ga",
"gb",
"edu.gd",
"gov.gd",
"gd",
"ge",
"com.ge",
"edu.ge",
"gov.ge",
"org.ge",
"mil.ge",
"net.ge",
"pvt.ge",
"gf",
"gg",
"co.gg",
"net.gg",
"org.gg",
"gh",
"com.gh",
"edu.gh",
"gov.gh",
"org.gh",
"mil.gh",
"gi",
"com.gi",
"ltd.gi",
"gov.gi",
"mod.gi",
"edu.gi",
"org.gi",
"gl",
"co.gl",
"com.gl",
"edu.gl",
"net.gl",
"org.gl",
"gm",
"gn",
"ac.gn",
"com.gn",
"edu.gn",
"gov.gn",
"org.gn",
"net.gn",
"gov",
"gp",
"com.gp",
"net.gp",
"mobi.gp",
"edu.gp",
"org.gp",
"asso.gp",
"gq",
"gr",
"com.gr",
"edu.gr",
"net.gr",
"org.gr",
"gov.gr",
"gs",
"gt",
"com.gt",
"edu.gt",
"gob.gt",
"ind.gt",
"mil.gt",
"net.gt",
"org.gt",
"gu",
"com.gu",
"edu.gu",
"gov.gu",
"guam.gu",
"info.gu",
"net.gu",
"org.gu",
"web.gu",
"gw",
"gy",
"co.gy",
"com.gy",
"edu.gy",
"gov.gy",
"net.gy",
"org.gy",
"hk",
"com.hk",
"edu.hk",
"gov.hk",
"idv.hk",
"net.hk",
"org.hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
".hk",
"hm",
"hn",
"com.hn",
"edu.hn",
"org.hn",
"net.hn",
"mil.hn",
"gob.hn",
"hr",
"iz.hr",
"from.hr",
"name.hr",
"com.hr",
"ht",
"com.ht",
"shop.ht",
"firm.ht",
"info.ht",
"adult.ht",
"net.ht",
"pro.ht",
"org.ht",
"med.ht",
"art.ht",
"coop.ht",
"pol.ht",
"asso.ht",
"edu.ht",
"rel.ht",
"gouv.ht",
"perso.ht",
"hu",
"co.hu",
"info.hu",
"org.hu",
"priv.hu",
"sport.hu",
"tm.hu",
"2000.hu",
"agrar.hu",
"bolt.hu",
"casino.hu",
"city.hu",
"erotica.hu",
"erotika.hu",
"film.hu",
"forum.hu",
"games.hu",
"hotel.hu",
"ingatlan.hu",
"jogasz.hu",
"konyvelo.hu",
"lakas.hu",
"media.hu",
"news.hu",
"reklam.hu",
"sex.hu",
"shop.hu",
"suli.hu",
"szex.hu",
"tozsde.hu",
"utazas.hu",
"video.hu",
"id",
"ac.id",
"biz.id",
"co.id",
"desa.id",
"go.id",
"mil.id",
"my.id",
"net.id",
"or.id",
"ponpes.id",
"sch.id",
"web.id",
"ie",
"gov.ie",
"il",
"ac.il",
"co.il",
"gov.il",
"idf.il",
"k12.il",
"muni.il",
"net.il",
"org.il",
"im",
"ac.im",
"co.im",
"com.im",
"ltd.co.im",
"net.im",
"org.im",
"plc.co.im",
"tt.im",
"tv.im",
"in",
"co.in",
"firm.in",
"net.in",
"org.in",
"gen.in",
"ind.in",
"nic.in",
"ac.in",
"edu.in",
"res.in",
"gov.in",
"mil.in",
"info",
"int",
"eu.int",
"io",
"com.io",
"iq",
"gov.iq",
"edu.iq",
"mil.iq",
"com.iq",
"org.iq",
"net.iq",
"ir",
"ac.ir",
"co.ir",
"gov.ir",
"id.ir",
"net.ir",
"org.ir",
"sch.ir",
".ir",
".ir",
"is",
"net.is",
"com.is",
"edu.is",
"gov.is",
"org.is",
"int.is",
"it",
"gov.it",
"edu.it",
"abr.it",
"abruzzo.it",
"aosta-valley.it",
"aostavalley.it",
"bas.it",
"basilicata.it",
"cal.it",
"calabria.it",
"cam.it",
"campania.it",
"emilia-romagna.it",
"emiliaromagna.it",
"emr.it",
"friuli-v-giulia.it",
"friuli-ve-giulia.it",
"friuli-vegiulia.it",
"friuli-venezia-giulia.it",
"friuli-veneziagiulia.it",
"friuli-vgiulia.it",
"friuliv-giulia.it",
"friulive-giulia.it",
"friulivegiulia.it",
"friulivenezia-giulia.it",
"friuliveneziagiulia.it",
"friulivgiulia.it",
"fvg.it",
"laz.it",
"lazio.it",
"lig.it",
"liguria.it",
"lom.it",
"lombardia.it",
"lombardy.it",
"lucania.it",
"mar.it",
"marche.it",
"mol.it",
"molise.it",
"piedmont.it",
"piemonte.it",
"pmn.it",
"pug.it",
"puglia.it",
"sar.it",
"sardegna.it",
"sardinia.it",
"sic.it",
"sicilia.it",
"sicily.it",
"taa.it",
"tos.it",
"toscana.it",
"trentin-sud-tirol.it",
"trentin-sd-tirol.it",
"trentin-sudtirol.it",
"trentin-sdtirol.it",
"trentin-sued-tirol.it",
"trentin-suedtirol.it",
"trentino-a-adige.it",
"trentino-aadige.it",
"trentino-alto-adige.it",
"trentino-altoadige.it",
"trentino-s-tirol.it",
"trentino-stirol.it",
"trentino-sud-tirol.it",
"trentino-sd-tirol.it",
"trentino-sudtirol.it",
"trentino-sdtirol.it",
"trentino-sued-tirol.it",
"trentino-suedtirol.it",
"trentino.it",
"trentinoa-adige.it",
"trentinoaadige.it",
"trentinoalto-adige.it",
"trentinoaltoadige.it",
"trentinos-tirol.it",
"trentinostirol.it",
"trentinosud-tirol.it",
"trentinosd-tirol.it",
"trentinosudtirol.it",
"trentinosdtirol.it",
"trentinosued-tirol.it",
"trentinosuedtirol.it",
"trentinsud-tirol.it",
"trentinsd-tirol.it",
"trentinsudtirol.it",
"trentinsdtirol.it",
"trentinsued-tirol.it",
"trentinsuedtirol.it",
"tuscany.it",
"umb.it",
"umbria.it",
"val-d-aosta.it",
"val-daosta.it",
"vald-aosta.it",
"valdaosta.it",
"valle-aosta.it",
"valle-d-aosta.it",
"valle-daosta.it",
"valleaosta.it",
"valled-aosta.it",
"valledaosta.it",
"vallee-aoste.it",
"valle-aoste.it",
"vallee-d-aoste.it",
"valle-d-aoste.it",
"valleeaoste.it",
"valleaoste.it",
"valleedaoste.it",
"valledaoste.it",
"vao.it",
"vda.it",
"ven.it",
"veneto.it",
"ag.it",
"agrigento.it",
"al.it",
"alessandria.it",
"alto-adige.it",
"altoadige.it",
"an.it",
"ancona.it",
"andria-barletta-trani.it",
"andria-trani-barletta.it",
"andriabarlettatrani.it",
"andriatranibarletta.it",
"ao.it",
"aosta.it",
"aoste.it",
"ap.it",
"aq.it",
"aquila.it",
"ar.it",
"arezzo.it",
"ascoli-piceno.it",
"ascolipiceno.it",
"asti.it",
"at.it",
"av.it",
"avellino.it",
"ba.it",
"balsan-sudtirol.it",
"balsan-sdtirol.it",
"balsan-suedtirol.it",
"balsan.it",
"bari.it",
"barletta-trani-andria.it",
"barlettatraniandria.it",
"belluno.it",
"benevento.it",
"bergamo.it",
"bg.it",
"bi.it",
"biella.it",
"bl.it",
"bn.it",
"bo.it",
"bologna.it",
"bolzano-altoadige.it",
"bolzano.it",
"bozen-sudtirol.it",
"bozen-sdtirol.it",
"bozen-suedtirol.it",
"bozen.it",
"br.it",
"brescia.it",
"brindisi.it",
"bs.it",
"bt.it",
"bulsan-sudtirol.it",
"bulsan-sdtirol.it",
"bulsan-suedtirol.it",
"bulsan.it",
"bz.it",
"ca.it",
"cagliari.it",
"caltanissetta.it",
"campidano-medio.it",
"campidanomedio.it",
"campobasso.it",
"carbonia-iglesias.it",
"carboniaiglesias.it",
"carrara-massa.it",
"carraramassa.it",
"caserta.it",
"catania.it",
"catanzaro.it",
"cb.it",
"ce.it",
"cesena-forli.it",
"cesena-forl.it",
"cesenaforli.it",
"cesenaforl.it",
"ch.it",
"chieti.it",
"ci.it",
"cl.it",
"cn.it",
"co.it",
"como.it",
"cosenza.it",
"cr.it",
"cremona.it",
"crotone.it",
"cs.it",
"ct.it",
"cuneo.it",
"cz.it",
"dell-ogliastra.it",
"dellogliastra.it",
"en.it",
"enna.it",
"fc.it",
"fe.it",
"fermo.it",
"ferrara.it",
"fg.it",
"fi.it",
"firenze.it",
"florence.it",
"fm.it",
"foggia.it",
"forli-cesena.it",
"forl-cesena.it",
"forlicesena.it",
"forlcesena.it",
"fr.it",
"frosinone.it",
"ge.it",
"genoa.it",
"genova.it",
"go.it",
"gorizia.it",
"gr.it",
"grosseto.it",
"iglesias-carbonia.it",
"iglesiascarbonia.it",
"im.it",
"imperia.it",
"is.it",
"isernia.it",
"kr.it",
"la-spezia.it",
"laquila.it",
"laspezia.it",
"latina.it",
"lc.it",
"le.it",
"lecce.it",
"lecco.it",
"li.it",
"livorno.it",
"lo.it",
"lodi.it",
"lt.it",
"lu.it",
"lucca.it",
"macerata.it",
"mantova.it",
"massa-carrara.it",
"massacarrara.it",
"matera.it",
"mb.it",
"mc.it",
"me.it",
"medio-campidano.it",
"mediocampidano.it",
"messina.it",
"mi.it",
"milan.it",
"milano.it",
"mn.it",
"mo.it",
"modena.it",
"monza-brianza.it",
"monza-e-della-brianza.it",
"monza.it",
"monzabrianza.it",
"monzaebrianza.it",
"monzaedellabrianza.it",
"ms.it",
"mt.it",
"na.it",
"naples.it",
"napoli.it",
"no.it",
"novara.it",
"nu.it",
"nuoro.it",
"og.it",
"ogliastra.it",
"olbia-tempio.it",
"olbiatempio.it",
"or.it",
"oristano.it",
"ot.it",
"pa.it",
"padova.it",
"padua.it",
"palermo.it",
"parma.it",
"pavia.it",
"pc.it",
"pd.it",
"pe.it",
"perugia.it",
"pesaro-urbino.it",
"pesarourbino.it",
"pescara.it",
"pg.it",
"pi.it",
"piacenza.it",
"pisa.it",
"pistoia.it",
"pn.it",
"po.it",
"pordenone.it",
"potenza.it",
"pr.it",
"prato.it",
"pt.it",
"pu.it",
"pv.it",
"pz.it",
"ra.it",
"ragusa.it",
"ravenna.it",
"rc.it",
"re.it",
"reggio-calabria.it",
"reggio-emilia.it",
"reggiocalabria.it",
"reggioemilia.it",
"rg.it",
"ri.it",
"rieti.it",
"rimini.it",
"rm.it",
"rn.it",
"ro.it",
"roma.it",
"rome.it",
"rovigo.it",
"sa.it",
"salerno.it",
"sassari.it",
"savona.it",
"si.it",
"siena.it",
"siracusa.it",
"so.it",
"sondrio.it",
"sp.it",
"sr.it",
"ss.it",
"suedtirol.it",
"sdtirol.it",
"sv.it",
"ta.it",
"taranto.it",
"te.it",
"tempio-olbia.it",
"tempioolbia.it",
"teramo.it",
"terni.it",
"tn.it",
"to.it",
"torino.it",
"tp.it",
"tr.it",
"trani-andria-barletta.it",
"trani-barletta-andria.it",
"traniandriabarletta.it",
"tranibarlettaandria.it",
"trapani.it",
"trento.it",
"treviso.it",
"trieste.it",
"ts.it",
"turin.it",
"tv.it",
"ud.it",
"udine.it",
"urbino-pesaro.it",
"urbinopesaro.it",
"va.it",
"varese.it",
"vb.it",
"vc.it",
"ve.it",
"venezia.it",
"venice.it",
"verbania.it",
"vercelli.it",
"verona.it",
"vi.it",
"vibo-valentia.it",
"vibovalentia.it",
"vicenza.it",
"viterbo.it",
"vr.it",
"vs.it",
"vt.it",
"vv.it",
"je",
"co.je",
"net.je",
"org.je",
"*.jm",
"jo",
"com.jo",
"org.jo",
"net.jo",
"edu.jo",
"sch.jo",
"gov.jo",
"mil.jo",
"name.jo",
"jobs",
"jp",
"ac.jp",
"ad.jp",
"co.jp",
"ed.jp",
"go.jp",
"gr.jp",
"lg.jp",
"ne.jp",
"or.jp",
"aichi.jp",
"akita.jp",
"aomori.jp",
"chiba.jp",
"ehime.jp",
"fukui.jp",
"fukuoka.jp",
"fukushima.jp",
"gifu.jp",
"gunma.jp",
"hiroshima.jp",
"hokkaido.jp",
"hyogo.jp",
"ibaraki.jp",
"ishikawa.jp",
"iwate.jp",
"kagawa.jp",
"kagoshima.jp",
"kanagawa.jp",
"kochi.jp",
"kumamoto.jp",
"kyoto.jp",
"mie.jp",
"miyagi.jp",
"miyazaki.jp",
"nagano.jp",
"nagasaki.jp",
"nara.jp",
"niigata.jp",
"oita.jp",
"okayama.jp",
"okinawa.jp",
"osaka.jp",
"saga.jp",
"saitama.jp",
"shiga.jp",
"shimane.jp",
"shizuoka.jp",
"tochigi.jp",
"tokushima.jp",
"tokyo.jp",
"tottori.jp",
"toyama.jp",
"wakayama.jp",
"yamagata.jp",
"yamaguchi.jp",
"yamanashi.jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
".jp",
"*.kawasaki.jp",
"*.kitakyushu.jp",
"*.kobe.jp",
"*.nagoya.jp",
"*.sapporo.jp",
"*.sendai.jp",
"*.yokohama.jp",
"!city.kawasaki.jp",
"!city.kitakyushu.jp",
"!city.kobe.jp",
"!city.nagoya.jp",
"!city.sapporo.jp",
"!city.sendai.jp",
"!city.yokohama.jp",
"aisai.aichi.jp",
"ama.aichi.jp",
"anjo.aichi.jp",
"asuke.aichi.jp",
"chiryu.aichi.jp",
"chita.aichi.jp",
"fuso.aichi.jp",
"gamagori.aichi.jp",
"handa.aichi.jp",
"hazu.aichi.jp",
"hekinan.aichi.jp",
"higashiura.aichi.jp",
"ichinomiya.aichi.jp",
"inazawa.aichi.jp",
"inuyama.aichi.jp",
"isshiki.aichi.jp",
"iwakura.aichi.jp",
"kanie.aichi.jp",
"kariya.aichi.jp",
"kasugai.aichi.jp",
"kira.aichi.jp",
"kiyosu.aichi.jp",
"komaki.aichi.jp",
"konan.aichi.jp",
"kota.aichi.jp",
"mihama.aichi.jp",
"miyoshi.aichi.jp",
"nishio.aichi.jp",
"nisshin.aichi.jp",
"obu.aichi.jp",
"oguchi.aichi.jp",
"oharu.aichi.jp",
"okazaki.aichi.jp",
"owariasahi.aichi.jp",
"seto.aichi.jp",
"shikatsu.aichi.jp",
"shinshiro.aichi.jp",
"shitara.aichi.jp",
"tahara.aichi.jp",
"takahama.aichi.jp",
"tobishima.aichi.jp",
"toei.aichi.jp",
"togo.aichi.jp",
"tokai.aichi.jp",
"tokoname.aichi.jp",
"toyoake.aichi.jp",
"toyohashi.aichi.jp",
"toyokawa.aichi.jp",
"toyone.aichi.jp",
"toyota.aichi.jp",
"tsushima.aichi.jp",
"yatomi.aichi.jp",
"akita.akita.jp",
"daisen.akita.jp",
"fujisato.akita.jp",
"gojome.akita.jp",
"hachirogata.akita.jp",
"happou.akita.jp",
"higashinaruse.akita.jp",
"honjo.akita.jp",
"honjyo.akita.jp",
"ikawa.akita.jp",
"kamikoani.akita.jp",
"kamioka.akita.jp",
"katagami.akita.jp",
"kazuno.akita.jp",
"kitaakita.akita.jp",
"kosaka.akita.jp",
"kyowa.akita.jp",
"misato.akita.jp",
"mitane.akita.jp",
"moriyoshi.akita.jp",
"nikaho.akita.jp",
"noshiro.akita.jp",
"odate.akita.jp",
"oga.akita.jp",
"ogata.akita.jp",
"semboku.akita.jp",
"yokote.akita.jp",
"yurihonjo.akita.jp",
"aomori.aomori.jp",
"gonohe.aomori.jp",
"hachinohe.aomori.jp",
"hashikami.aomori.jp",
"hiranai.aomori.jp",
"hirosaki.aomori.jp",
"itayanagi.aomori.jp",
"kuroishi.aomori.jp",
"misawa.aomori.jp",
"mutsu.aomori.jp",
"nakadomari.aomori.jp",
"noheji.aomori.jp",
"oirase.aomori.jp",
"owani.aomori.jp",
"rokunohe.aomori.jp",
"sannohe.aomori.jp",
"shichinohe.aomori.jp",
"shingo.aomori.jp",
"takko.aomori.jp",
"towada.aomori.jp",
"tsugaru.aomori.jp",
"tsuruta.aomori.jp",
"abiko.chiba.jp",
"asahi.chiba.jp",
"chonan.chiba.jp",
"chosei.chiba.jp",
"choshi.chiba.jp",
"chuo.chiba.jp",
"funabashi.chiba.jp",
"futtsu.chiba.jp",
"hanamigawa.chiba.jp",
"ichihara.chiba.jp",
"ichikawa.chiba.jp",
"ichinomiya.chiba.jp",
"inzai.chiba.jp",
"isumi.chiba.jp",
"kamagaya.chiba.jp",
"kamogawa.chiba.jp",
"kashiwa.chiba.jp",
"katori.chiba.jp",
"katsuura.chiba.jp",
"kimitsu.chiba.jp",
"kisarazu.chiba.jp",
"kozaki.chiba.jp",
"kujukuri.chiba.jp",
"kyonan.chiba.jp",
"matsudo.chiba.jp",
"midori.chiba.jp",
"mihama.chiba.jp",
"minamiboso.chiba.jp",
"mobara.chiba.jp",
"mutsuzawa.chiba.jp",
"nagara.chiba.jp",
"nagareyama.chiba.jp",
"narashino.chiba.jp",
"narita.chiba.jp",
"noda.chiba.jp",
"oamishirasato.chiba.jp",
"omigawa.chiba.jp",
"onjuku.chiba.jp",
"otaki.chiba.jp",
"sakae.chiba.jp",
"sakura.chiba.jp",
"shimofusa.chiba.jp",
"shirako.chiba.jp",
"shiroi.chiba.jp",
"shisui.chiba.jp",
"sodegaura.chiba.jp",
"sosa.chiba.jp",
"tako.chiba.jp",
"tateyama.chiba.jp",
"togane.chiba.jp",
"tohnosho.chiba.jp",
"tomisato.chiba.jp",
"urayasu.chiba.jp",
"yachimata.chiba.jp",
"yachiyo.chiba.jp",
"yokaichiba.chiba.jp",
"yokoshibahikari.chiba.jp",
"yotsukaido.chiba.jp",
"ainan.ehime.jp",
"honai.ehime.jp",
"ikata.ehime.jp",
"imabari.ehime.jp",
"iyo.ehime.jp",
"kamijima.ehime.jp",
"kihoku.ehime.jp",
"kumakogen.ehime.jp",
"masaki.ehime.jp",
"matsuno.ehime.jp",
"matsuyama.ehime.jp",
"namikata.ehime.jp",
"niihama.ehime.jp",
"ozu.ehime.jp",
"saijo.ehime.jp",
"seiyo.ehime.jp",
"shikokuchuo.ehime.jp",
"tobe.ehime.jp",
"toon.ehime.jp",
"uchiko.ehime.jp",
"uwajima.ehime.jp",
"yawatahama.ehime.jp",
"echizen.fukui.jp",
"eiheiji.fukui.jp",
"fukui.fukui.jp",
"ikeda.fukui.jp",
"katsuyama.fukui.jp",
"mihama.fukui.jp",
"minamiechizen.fukui.jp",
"obama.fukui.jp",
"ohi.fukui.jp",
"ono.fukui.jp",
"sabae.fukui.jp",
"sakai.fukui.jp",
"takahama.fukui.jp",
"tsuruga.fukui.jp",
"wakasa.fukui.jp",
"ashiya.fukuoka.jp",
"buzen.fukuoka.jp",
"chikugo.fukuoka.jp",
"chikuho.fukuoka.jp",
"chikujo.fukuoka.jp",
"chikushino.fukuoka.jp",
"chikuzen.fukuoka.jp",
"chuo.fukuoka.jp",
"dazaifu.fukuoka.jp",
"fukuchi.fukuoka.jp",
"hakata.fukuoka.jp",
"higashi.fukuoka.jp",
"hirokawa.fukuoka.jp",
"hisayama.fukuoka.jp",
"iizuka.fukuoka.jp",
"inatsuki.fukuoka.jp",
"kaho.fukuoka.jp",
"kasuga.fukuoka.jp",
"kasuya.fukuoka.jp",
"kawara.fukuoka.jp",
"keisen.fukuoka.jp",
"koga.fukuoka.jp",
"kurate.fukuoka.jp",
"kurogi.fukuoka.jp",
"kurume.fukuoka.jp",
"minami.fukuoka.jp",
"miyako.fukuoka.jp",
"miyama.fukuoka.jp",
"miyawaka.fukuoka.jp",
"mizumaki.fukuoka.jp",
"munakata.fukuoka.jp",
"nakagawa.fukuoka.jp",
"nakama.fukuoka.jp",
"nishi.fukuoka.jp",
"nogata.fukuoka.jp",
"ogori.fukuoka.jp",
"okagaki.fukuoka.jp",
"okawa.fukuoka.jp",
"oki.fukuoka.jp",
"omuta.fukuoka.jp",
"onga.fukuoka.jp",
"onojo.fukuoka.jp",
"oto.fukuoka.jp",
"saigawa.fukuoka.jp",
"sasaguri.fukuoka.jp",
"shingu.fukuoka.jp",
"shinyoshitomi.fukuoka.jp",
"shonai.fukuoka.jp",
"soeda.fukuoka.jp",
"sue.fukuoka.jp",
"tachiarai.fukuoka.jp",
"tagawa.fukuoka.jp",
"takata.fukuoka.jp",
"toho.fukuoka.jp",
"toyotsu.fukuoka.jp",
"tsuiki.fukuoka.jp",
"ukiha.fukuoka.jp",
"umi.fukuoka.jp",
"usui.fukuoka.jp",
"yamada.fukuoka.jp",
"yame.fukuoka.jp",
"yanagawa.fukuoka.jp",
"yukuhashi.fukuoka.jp",
"aizubange.fukushima.jp",
"aizumisato.fukushima.jp",
"aizuwakamatsu.fukushima.jp",
"asakawa.fukushima.jp",
"bandai.fukushima.jp",
"date.fukushima.jp",
"fukushima.fukushima.jp",
"furudono.fukushima.jp",
"futaba.fukushima.jp",
"hanawa.fukushima.jp",
"higashi.fukushima.jp",
"hirata.fukushima.jp",
"hirono.fukushima.jp",
"iitate.fukushima.jp",
"inawashiro.fukushima.jp",
"ishikawa.fukushima.jp",
"iwaki.fukushima.jp",
"izumizaki.fukushima.jp",
"kagamiishi.fukushima.jp",
"kaneyama.fukushima.jp",
"kawamata.fukushima.jp",
"kitakata.fukushima.jp",
"kitashiobara.fukushima.jp",
"koori.fukushima.jp",
"koriyama.fukushima.jp",
"kunimi.fukushima.jp",
"miharu.fukushima.jp",
"mishima.fukushima.jp",
"namie.fukushima.jp",
"nango.fukushima.jp",
"nishiaizu.fukushima.jp",
"nishigo.fukushima.jp",
"okuma.fukushima.jp",
"omotego.fukushima.jp",
"ono.fukushima.jp",
"otama.fukushima.jp",
"samegawa.fukushima.jp",
"shimogo.fukushima.jp",
"shirakawa.fukushima.jp",
"showa.fukushima.jp",
"soma.fukushima.jp",
"sukagawa.fukushima.jp",
"taishin.fukushima.jp",
"tamakawa.fukushima.jp",
"tanagura.fukushima.jp",
"tenei.fukushima.jp",
"yabuki.fukushima.jp",
"yamato.fukushima.jp",
"yamatsuri.fukushima.jp",
"yanaizu.fukushima.jp",
"yugawa.fukushima.jp",
"anpachi.gifu.jp",
"ena.gifu.jp",
"gifu.gifu.jp",
"ginan.gifu.jp",
"godo.gifu.jp",
"gujo.gifu.jp",
"hashima.gifu.jp",
"hichiso.gifu.jp",
"hida.gifu.jp",
"higashishirakawa.gifu.jp",
"ibigawa.gifu.jp",
"ikeda.gifu.jp",
"kakamigahara.gifu.jp",
"kani.gifu.jp",
"kasahara.gifu.jp",
"kasamatsu.gifu.jp",
"kawaue.gifu.jp",
"kitagata.gifu.jp",
"mino.gifu.jp",
"minokamo.gifu.jp",
"mitake.gifu.jp",
"mizunami.gifu.jp",
"motosu.gifu.jp",
"nakatsugawa.gifu.jp",
"ogaki.gifu.jp",
"sakahogi.gifu.jp",
"seki.gifu.jp",
"sekigahara.gifu.jp",
"shirakawa.gifu.jp",
"tajimi.gifu.jp",
"takayama.gifu.jp",
"tarui.gifu.jp",
"toki.gifu.jp",
"tomika.gifu.jp",
"wanouchi.gifu.jp",
"yamagata.gifu.jp",
"yaotsu.gifu.jp",
"yoro.gifu.jp",
"annaka.gunma.jp",
"chiyoda.gunma.jp",
"fujioka.gunma.jp",
"higashiagatsuma.gunma.jp",
"isesaki.gunma.jp",
"itakura.gunma.jp",
"kanna.gunma.jp",
"kanra.gunma.jp",
"katashina.gunma.jp",
"kawaba.gunma.jp",
"kiryu.gunma.jp",
"kusatsu.gunma.jp",
"maebashi.gunma.jp",
"meiwa.gunma.jp",
"midori.gunma.jp",
"minakami.gunma.jp",
"naganohara.gunma.jp",
"nakanojo.gunma.jp",
"nanmoku.gunma.jp",
"numata.gunma.jp",
"oizumi.gunma.jp",
"ora.gunma.jp",
"ota.gunma.jp",
"shibukawa.gunma.jp",
"shimonita.gunma.jp",
"shinto.gunma.jp",
"showa.gunma.jp",
"takasaki.gunma.jp",
"takayama.gunma.jp",
"tamamura.gunma.jp",
"tatebayashi.gunma.jp",
"tomioka.gunma.jp",
"tsukiyono.gunma.jp",
"tsumagoi.gunma.jp",
"ueno.gunma.jp",
"yoshioka.gunma.jp",
"asaminami.hiroshima.jp",
"daiwa.hiroshima.jp",
"etajima.hiroshima.jp",
"fuchu.hiroshima.jp",
"fukuyama.hiroshima.jp",
"hatsukaichi.hiroshima.jp",
"higashihiroshima.hiroshima.jp",
"hongo.hiroshima.jp",
"jinsekikogen.hiroshima.jp",
"kaita.hiroshima.jp",
"kui.hiroshima.jp",
"kumano.hiroshima.jp",
"kure.hiroshima.jp",
"mihara.hiroshima.jp",
"miyoshi.hiroshima.jp",
"naka.hiroshima.jp",
"onomichi.hiroshima.jp",
"osakikamijima.hiroshima.jp",
"otake.hiroshima.jp",
"saka.hiroshima.jp",
"sera.hiroshima.jp",
"seranishi.hiroshima.jp",
"shinichi.hiroshima.jp",
"shobara.hiroshima.jp",
"takehara.hiroshima.jp",
"abashiri.hokkaido.jp",
"abira.hokkaido.jp",
"aibetsu.hokkaido.jp",
"akabira.hokkaido.jp",
"akkeshi.hokkaido.jp",
"asahikawa.hokkaido.jp",
"ashibetsu.hokkaido.jp",
"ashoro.hokkaido.jp",
"assabu.hokkaido.jp",
"atsuma.hokkaido.jp",
"bibai.hokkaido.jp",
"biei.hokkaido.jp",
"bifuka.hokkaido.jp",
"bihoro.hokkaido.jp",
"biratori.hokkaido.jp",
"chippubetsu.hokkaido.jp",
"chitose.hokkaido.jp",
"date.hokkaido.jp",
"ebetsu.hokkaido.jp",
"embetsu.hokkaido.jp",
"eniwa.hokkaido.jp",
"erimo.hokkaido.jp",
"esan.hokkaido.jp",
"esashi.hokkaido.jp",
"fukagawa.hokkaido.jp",
"fukushima.hokkaido.jp",
"furano.hokkaido.jp",
"furubira.hokkaido.jp",
"haboro.hokkaido.jp",
"hakodate.hokkaido.jp",
"hamatonbetsu.hokkaido.jp",
"hidaka.hokkaido.jp",
"higashikagura.hokkaido.jp",
"higashikawa.hokkaido.jp",
"hiroo.hokkaido.jp",
"hokuryu.hokkaido.jp",
"hokuto.hokkaido.jp",
"honbetsu.hokkaido.jp",
"horokanai.hokkaido.jp",
"horonobe.hokkaido.jp",
"ikeda.hokkaido.jp",
"imakane.hokkaido.jp",
"ishikari.hokkaido.jp",
"iwamizawa.hokkaido.jp",
"iwanai.hokkaido.jp",
"kamifurano.hokkaido.jp",
"kamikawa.hokkaido.jp",
"kamishihoro.hokkaido.jp",
"kamisunagawa.hokkaido.jp",
"kamoenai.hokkaido.jp",
"kayabe.hokkaido.jp",
"kembuchi.hokkaido.jp",
"kikonai.hokkaido.jp",
"kimobetsu.hokkaido.jp",
"kitahiroshima.hokkaido.jp",
"kitami.hokkaido.jp",
"kiyosato.hokkaido.jp",
"koshimizu.hokkaido.jp",
"kunneppu.hokkaido.jp",
"kuriyama.hokkaido.jp",
"kuromatsunai.hokkaido.jp",
"kushiro.hokkaido.jp",
"kutchan.hokkaido.jp",
"kyowa.hokkaido.jp",
"mashike.hokkaido.jp",
"matsumae.hokkaido.jp",
"mikasa.hokkaido.jp",
"minamifurano.hokkaido.jp",
"mombetsu.hokkaido.jp",
"moseushi.hokkaido.jp",
"mukawa.hokkaido.jp",
"muroran.hokkaido.jp",
"naie.hokkaido.jp",
"nakagawa.hokkaido.jp",
"nakasatsunai.hokkaido.jp",
"nakatombetsu.hokkaido.jp",
"nanae.hokkaido.jp",
"nanporo.hokkaido.jp",
"nayoro.hokkaido.jp",
"nemuro.hokkaido.jp",
"niikappu.hokkaido.jp",
"niki.hokkaido.jp",
"nishiokoppe.hokkaido.jp",
"noboribetsu.hokkaido.jp",
"numata.hokkaido.jp",
"obihiro.hokkaido.jp",
"obira.hokkaido.jp",
"oketo.hokkaido.jp",
"okoppe.hokkaido.jp",
"otaru.hokkaido.jp",
"otobe.hokkaido.jp",
"otofuke.hokkaido.jp",
"otoineppu.hokkaido.jp",
"oumu.hokkaido.jp",
"ozora.hokkaido.jp",
"pippu.hokkaido.jp",
"rankoshi.hokkaido.jp",
"rebun.hokkaido.jp",
"rikubetsu.hokkaido.jp",
"rishiri.hokkaido.jp",
"rishirifuji.hokkaido.jp",
"saroma.hokkaido.jp",
"sarufutsu.hokkaido.jp",
"shakotan.hokkaido.jp",
"shari.hokkaido.jp",
"shibecha.hokkaido.jp",
"shibetsu.hokkaido.jp",
"shikabe.hokkaido.jp",
"shikaoi.hokkaido.jp",
"shimamaki.hokkaido.jp",
"shimizu.hokkaido.jp",
"shimokawa.hokkaido.jp",
"shinshinotsu.hokkaido.jp",
"shintoku.hokkaido.jp",
"shiranuka.hokkaido.jp",
"shiraoi.hokkaido.jp",
"shiriuchi.hokkaido.jp",
"sobetsu.hokkaido.jp",
"sunagawa.hokkaido.jp",
"taiki.hokkaido.jp",
"takasu.hokkaido.jp",
"takikawa.hokkaido.jp",
"takinoue.hokkaido.jp",
"teshikaga.hokkaido.jp",
"tobetsu.hokkaido.jp",
"tohma.hokkaido.jp",
"tomakomai.hokkaido.jp",
"tomari.hokkaido.jp",
"toya.hokkaido.jp",
"toyako.hokkaido.jp",
"toyotomi.hokkaido.jp",
"toyoura.hokkaido.jp",
"tsubetsu.hokkaido.jp",
"tsukigata.hokkaido.jp",
"urakawa.hokkaido.jp",
"urausu.hokkaido.jp",
"uryu.hokkaido.jp",
"utashinai.hokkaido.jp",
"wakkanai.hokkaido.jp",
"wassamu.hokkaido.jp",
"yakumo.hokkaido.jp",
"yoichi.hokkaido.jp",
"aioi.hyogo.jp",
"akashi.hyogo.jp",
"ako.hyogo.jp",
"amagasaki.hyogo.jp",
"aogaki.hyogo.jp",
"asago.hyogo.jp",
"ashiya.hyogo.jp",
"awaji.hyogo.jp",
"fukusaki.hyogo.jp",
"goshiki.hyogo.jp",
"harima.hyogo.jp",
"himeji.hyogo.jp",
"ichikawa.hyogo.jp",
"inagawa.hyogo.jp",
"itami.hyogo.jp",
"kakogawa.hyogo.jp",
"kamigori.hyogo.jp",
"kamikawa.hyogo.jp",
"kasai.hyogo.jp",
"kasuga.hyogo.jp",
"kawanishi.hyogo.jp",
"miki.hyogo.jp",
"minamiawaji.hyogo.jp",
"nishinomiya.hyogo.jp",
"nishiwaki.hyogo.jp",
"ono.hyogo.jp",
"sanda.hyogo.jp",
"sannan.hyogo.jp",
"sasayama.hyogo.jp",
"sayo.hyogo.jp",
"shingu.hyogo.jp",
"shinonsen.hyogo.jp",
"shiso.hyogo.jp",
"sumoto.hyogo.jp",
"taishi.hyogo.jp",
"taka.hyogo.jp",
"takarazuka.hyogo.jp",
"takasago.hyogo.jp",
"takino.hyogo.jp",
"tamba.hyogo.jp",
"tatsuno.hyogo.jp",
"toyooka.hyogo.jp",
"yabu.hyogo.jp",
"yashiro.hyogo.jp",
"yoka.hyogo.jp",
"yokawa.hyogo.jp",
"ami.ibaraki.jp",
"asahi.ibaraki.jp",
"bando.ibaraki.jp",
"chikusei.ibaraki.jp",
"daigo.ibaraki.jp",
"fujishiro.ibaraki.jp",
"hitachi.ibaraki.jp",
"hitachinaka.ibaraki.jp",
"hitachiomiya.ibaraki.jp",
"hitachiota.ibaraki.jp",
"ibaraki.ibaraki.jp",
"ina.ibaraki.jp",
"inashiki.ibaraki.jp",
"itako.ibaraki.jp",
"iwama.ibaraki.jp",
"joso.ibaraki.jp",
"kamisu.ibaraki.jp",
"kasama.ibaraki.jp",
"kashima.ibaraki.jp",
"kasumigaura.ibaraki.jp",
"koga.ibaraki.jp",
"miho.ibaraki.jp",
"mito.ibaraki.jp",
"moriya.ibaraki.jp",
"naka.ibaraki.jp",
"namegata.ibaraki.jp",
"oarai.ibaraki.jp",
"ogawa.ibaraki.jp",
"omitama.ibaraki.jp",
"ryugasaki.ibaraki.jp",
"sakai.ibaraki.jp",
"sakuragawa.ibaraki.jp",
"shimodate.ibaraki.jp",
"shimotsuma.ibaraki.jp",
"shirosato.ibaraki.jp",
"sowa.ibaraki.jp",
"suifu.ibaraki.jp",
"takahagi.ibaraki.jp",
"tamatsukuri.ibaraki.jp",
"tokai.ibaraki.jp",
"tomobe.ibaraki.jp",
"tone.ibaraki.jp",
"toride.ibaraki.jp",
"tsuchiura.ibaraki.jp",
"tsukuba.ibaraki.jp",
"uchihara.ibaraki.jp",
"ushiku.ibaraki.jp",
"yachiyo.ibaraki.jp",
"yamagata.ibaraki.jp",
"yawara.ibaraki.jp",
"yuki.ibaraki.jp",
"anamizu.ishikawa.jp",
"hakui.ishikawa.jp",
"hakusan.ishikawa.jp",
"kaga.ishikawa.jp",
"kahoku.ishikawa.jp",
"kanazawa.ishikawa.jp",
"kawakita.ishikawa.jp",
"komatsu.ishikawa.jp",
"nakanoto.ishikawa.jp",
"nanao.ishikawa.jp",
"nomi.ishikawa.jp",
"nonoichi.ishikawa.jp",
"noto.ishikawa.jp",
"shika.ishikawa.jp",
"suzu.ishikawa.jp",
"tsubata.ishikawa.jp",
"tsurugi.ishikawa.jp",
"uchinada.ishikawa.jp",
"wajima.ishikawa.jp",
"fudai.iwate.jp",
"fujisawa.iwate.jp",
"hanamaki.iwate.jp",
"hiraizumi.iwate.jp",
"hirono.iwate.jp",
"ichinohe.iwate.jp",
"ichinoseki.iwate.jp",
"iwaizumi.iwate.jp",
"iwate.iwate.jp",
"joboji.iwate.jp",
"kamaishi.iwate.jp",
"kanegasaki.iwate.jp",
"karumai.iwate.jp",
"kawai.iwate.jp",
"kitakami.iwate.jp",
"kuji.iwate.jp",
"kunohe.iwate.jp",
"kuzumaki.iwate.jp",
"miyako.iwate.jp",
"mizusawa.iwate.jp",
"morioka.iwate.jp",
"ninohe.iwate.jp",
"noda.iwate.jp",
"ofunato.iwate.jp",
"oshu.iwate.jp",
"otsuchi.iwate.jp",
"rikuzentakata.iwate.jp",
"shiwa.iwate.jp",
"shizukuishi.iwate.jp",
"sumita.iwate.jp",
"tanohata.iwate.jp",
"tono.iwate.jp",
"yahaba.iwate.jp",
"yamada.iwate.jp",
"ayagawa.kagawa.jp",
"higashikagawa.kagawa.jp",
"kanonji.kagawa.jp",
"kotohira.kagawa.jp",
"manno.kagawa.jp",
"marugame.kagawa.jp",
"mitoyo.kagawa.jp",
"naoshima.kagawa.jp",
"sanuki.kagawa.jp",
"tadotsu.kagawa.jp",
"takamatsu.kagawa.jp",
"tonosho.kagawa.jp",
"uchinomi.kagawa.jp",
"utazu.kagawa.jp",
"zentsuji.kagawa.jp",
"akune.kagoshima.jp",
"amami.kagoshima.jp",
"hioki.kagoshima.jp",
"isa.kagoshima.jp",
"isen.kagoshima.jp",
"izumi.kagoshima.jp",
"kagoshima.kagoshima.jp",
"kanoya.kagoshima.jp",
"kawanabe.kagoshima.jp",
"kinko.kagoshima.jp",
"kouyama.kagoshima.jp",
"makurazaki.kagoshima.jp",
"matsumoto.kagoshima.jp",
"minamitane.kagoshima.jp",
"nakatane.kagoshima.jp",
"nishinoomote.kagoshima.jp",
"satsumasendai.kagoshima.jp",
"soo.kagoshima.jp",
"tarumizu.kagoshima.jp",
"yusui.kagoshima.jp",
"aikawa.kanagawa.jp",
"atsugi.kanagawa.jp",
"ayase.kanagawa.jp",
"chigasaki.kanagawa.jp",
"ebina.kanagawa.jp",
"fujisawa.kanagawa.jp",
"hadano.kanagawa.jp",
"hakone.kanagawa.jp",
"hiratsuka.kanagawa.jp",
"isehara.kanagawa.jp",
"kaisei.kanagawa.jp",
"kamakura.kanagawa.jp",
"kiyokawa.kanagawa.jp",
"matsuda.kanagawa.jp",
"minamiashigara.kanagawa.jp",
"miura.kanagawa.jp",
"nakai.kanagawa.jp",
"ninomiya.kanagawa.jp",
"odawara.kanagawa.jp",
"oi.kanagawa.jp",
"oiso.kanagawa.jp",
"sagamihara.kanagawa.jp",
"samukawa.kanagawa.jp",
"tsukui.kanagawa.jp",
"yamakita.kanagawa.jp",
"yamato.kanagawa.jp",
"yokosuka.kanagawa.jp",
"yugawara.kanagawa.jp",
"zama.kanagawa.jp",
"zushi.kanagawa.jp",
"aki.kochi.jp",
"geisei.kochi.jp",
"hidaka.kochi.jp",
"higashitsuno.kochi.jp",
"ino.kochi.jp",
"kagami.kochi.jp",
"kami.kochi.jp",
"kitagawa.kochi.jp",
"kochi.kochi.jp",
"mihara.kochi.jp",
"motoyama.kochi.jp",
"muroto.kochi.jp",
"nahari.kochi.jp",
"nakamura.kochi.jp",
"nankoku.kochi.jp",
"nishitosa.kochi.jp",
"niyodogawa.kochi.jp",
"ochi.kochi.jp",
"okawa.kochi.jp",
"otoyo.kochi.jp",
"otsuki.kochi.jp",
"sakawa.kochi.jp",
"sukumo.kochi.jp",
"susaki.kochi.jp",
"tosa.kochi.jp",
"tosashimizu.kochi.jp",
"toyo.kochi.jp",
"tsuno.kochi.jp",
"umaji.kochi.jp",
"yasuda.kochi.jp",
"yusuhara.kochi.jp",
"amakusa.kumamoto.jp",
"arao.kumamoto.jp",
"aso.kumamoto.jp",
"choyo.kumamoto.jp",
"gyokuto.kumamoto.jp",
"kamiamakusa.kumamoto.jp",
"kikuchi.kumamoto.jp",
"kumamoto.kumamoto.jp",
"mashiki.kumamoto.jp",
"mifune.kumamoto.jp",
"minamata.kumamoto.jp",
"minamioguni.kumamoto.jp",
"nagasu.kumamoto.jp",
"nishihara.kumamoto.jp",
"oguni.kumamoto.jp",
"ozu.kumamoto.jp",
"sumoto.kumamoto.jp",
"takamori.kumamoto.jp",
"uki.kumamoto.jp",
"uto.kumamoto.jp",
"yamaga.kumamoto.jp",
"yamato.kumamoto.jp",
"yatsushiro.kumamoto.jp",
"ayabe.kyoto.jp",
"fukuchiyama.kyoto.jp",
"higashiyama.kyoto.jp",
"ide.kyoto.jp",
"ine.kyoto.jp",
"joyo.kyoto.jp",
"kameoka.kyoto.jp",
"kamo.kyoto.jp",
"kita.kyoto.jp",
"kizu.kyoto.jp",
"kumiyama.kyoto.jp",
"kyotamba.kyoto.jp",
"kyotanabe.kyoto.jp",
"kyotango.kyoto.jp",
"maizuru.kyoto.jp",
"minami.kyoto.jp",
"minamiyamashiro.kyoto.jp",
"miyazu.kyoto.jp",
"muko.kyoto.jp",
"nagaokakyo.kyoto.jp",
"nakagyo.kyoto.jp",
"nantan.kyoto.jp",
"oyamazaki.kyoto.jp",
"sakyo.kyoto.jp",
"seika.kyoto.jp",
"tanabe.kyoto.jp",
"uji.kyoto.jp",
"ujitawara.kyoto.jp",
"wazuka.kyoto.jp",
"yamashina.kyoto.jp",
"yawata.kyoto.jp",
"asahi.mie.jp",
"inabe.mie.jp",
"ise.mie.jp",
"kameyama.mie.jp",
"kawagoe.mie.jp",
"kiho.mie.jp",
"kisosaki.mie.jp",
"kiwa.mie.jp",
"komono.mie.jp",
"kumano.mie.jp",
"kuwana.mie.jp",
"matsusaka.mie.jp",
"meiwa.mie.jp",
"mihama.mie.jp",
"minamiise.mie.jp",
"misugi.mie.jp",
"miyama.mie.jp",
"nabari.mie.jp",
"shima.mie.jp",
"suzuka.mie.jp",
"tado.mie.jp",
"taiki.mie.jp",
"taki.mie.jp",
"tamaki.mie.jp",
"toba.mie.jp",
"tsu.mie.jp",
"udono.mie.jp",
"ureshino.mie.jp",
"watarai.mie.jp",
"yokkaichi.mie.jp",
"furukawa.miyagi.jp",
"higashimatsushima.miyagi.jp",
"ishinomaki.miyagi.jp",
"iwanuma.miyagi.jp",
"kakuda.miyagi.jp",
"kami.miyagi.jp",
"kawasaki.miyagi.jp",
"marumori.miyagi.jp",
"matsushima.miyagi.jp",
"minamisanriku.miyagi.jp",
"misato.miyagi.jp",
"murata.miyagi.jp",
"natori.miyagi.jp",
"ogawara.miyagi.jp",
"ohira.miyagi.jp",
"onagawa.miyagi.jp",
"osaki.miyagi.jp",
"rifu.miyagi.jp",
"semine.miyagi.jp",
"shibata.miyagi.jp",
"shichikashuku.miyagi.jp",
"shikama.miyagi.jp",
"shiogama.miyagi.jp",
"shiroishi.miyagi.jp",
"tagajo.miyagi.jp",
"taiwa.miyagi.jp",
"tome.miyagi.jp",
"tomiya.miyagi.jp",
"wakuya.miyagi.jp",
"watari.miyagi.jp",
"yamamoto.miyagi.jp",
"zao.miyagi.jp",
"aya.miyazaki.jp",
"ebino.miyazaki.jp",
"gokase.miyazaki.jp",
"hyuga.miyazaki.jp",
"kadogawa.miyazaki.jp",
"kawaminami.miyazaki.jp",
"kijo.miyazaki.jp",
"kitagawa.miyazaki.jp",
"kitakata.miyazaki.jp",
"kitaura.miyazaki.jp",
"kobayashi.miyazaki.jp",
"kunitomi.miyazaki.jp",
"kushima.miyazaki.jp",
"mimata.miyazaki.jp",
"miyakonojo.miyazaki.jp",
"miyazaki.miyazaki.jp",
"morotsuka.miyazaki.jp",
"nichinan.miyazaki.jp",
"nishimera.miyazaki.jp",
"nobeoka.miyazaki.jp",
"saito.miyazaki.jp",
"shiiba.miyazaki.jp",
"shintomi.miyazaki.jp",
"takaharu.miyazaki.jp",
"takanabe.miyazaki.jp",
"takazaki.miyazaki.jp",
"tsuno.miyazaki.jp",
"achi.nagano.jp",
"agematsu.nagano.jp",
"anan.nagano.jp",
"aoki.nagano.jp",
"asahi.nagano.jp",
"azumino.nagano.jp",
"chikuhoku.nagano.jp",
"chikuma.nagano.jp",
"chino.nagano.jp",
"fujimi.nagano.jp",
"hakuba.nagano.jp",
"hara.nagano.jp",
"hiraya.nagano.jp",
"iida.nagano.jp",
"iijima.nagano.jp",
"iiyama.nagano.jp",
"iizuna.nagano.jp",
"ikeda.nagano.jp",
"ikusaka.nagano.jp",
"ina.nagano.jp",
"karuizawa.nagano.jp",
"kawakami.nagano.jp",
"kiso.nagano.jp",
"kisofukushima.nagano.jp",
"kitaaiki.nagano.jp",
"komagane.nagano.jp",
"komoro.nagano.jp",
"matsukawa.nagano.jp",
"matsumoto.nagano.jp",
"miasa.nagano.jp",
"minamiaiki.nagano.jp",
"minamimaki.nagano.jp",
"minamiminowa.nagano.jp",
"minowa.nagano.jp",
"miyada.nagano.jp",
"miyota.nagano.jp",
"mochizuki.nagano.jp",
"nagano.nagano.jp",
"nagawa.nagano.jp",
"nagiso.nagano.jp",
"nakagawa.nagano.jp",
"nakano.nagano.jp",
"nozawaonsen.nagano.jp",
"obuse.nagano.jp",
"ogawa.nagano.jp",
"okaya.nagano.jp",
"omachi.nagano.jp",
"omi.nagano.jp",
"ookuwa.nagano.jp",
"ooshika.nagano.jp",
"otaki.nagano.jp",
"otari.nagano.jp",
"sakae.nagano.jp",
"sakaki.nagano.jp",
"saku.nagano.jp",
"sakuho.nagano.jp",
"shimosuwa.nagano.jp",
"shinanomachi.nagano.jp",
"shiojiri.nagano.jp",
"suwa.nagano.jp",
"suzaka.nagano.jp",
"takagi.nagano.jp",
"takamori.nagano.jp",
"takayama.nagano.jp",
"tateshina.nagano.jp",
"tatsuno.nagano.jp",
"togakushi.nagano.jp",
"togura.nagano.jp",
"tomi.nagano.jp",
"ueda.nagano.jp",
"wada.nagano.jp",
"yamagata.nagano.jp",
"yamanouchi.nagano.jp",
"yasaka.nagano.jp",
"yasuoka.nagano.jp",
"chijiwa.nagasaki.jp",
"futsu.nagasaki.jp",
"goto.nagasaki.jp",
"hasami.nagasaki.jp",
"hirado.nagasaki.jp",
"iki.nagasaki.jp",
"isahaya.nagasaki.jp",
"kawatana.nagasaki.jp",
"kuchinotsu.nagasaki.jp",
"matsuura.nagasaki.jp",
"nagasaki.nagasaki.jp",
"obama.nagasaki.jp",
"omura.nagasaki.jp",
"oseto.nagasaki.jp",
"saikai.nagasaki.jp",
"sasebo.nagasaki.jp",
"seihi.nagasaki.jp",
"shimabara.nagasaki.jp",
"shinkamigoto.nagasaki.jp",
"togitsu.nagasaki.jp",
"tsushima.nagasaki.jp",
"unzen.nagasaki.jp",
"ando.nara.jp",
"gose.nara.jp",
"heguri.nara.jp",
"higashiyoshino.nara.jp",
"ikaruga.nara.jp",
"ikoma.nara.jp",
"kamikitayama.nara.jp",
"kanmaki.nara.jp",
"kashiba.nara.jp",
"kashihara.nara.jp",
"katsuragi.nara.jp",
"kawai.nara.jp",
"kawakami.nara.jp",
"kawanishi.nara.jp",
"koryo.nara.jp",
"kurotaki.nara.jp",
"mitsue.nara.jp",
"miyake.nara.jp",
"nara.nara.jp",
"nosegawa.nara.jp",
"oji.nara.jp",
"ouda.nara.jp",
"oyodo.nara.jp",
"sakurai.nara.jp",
"sango.nara.jp",
"shimoichi.nara.jp",
"shimokitayama.nara.jp",
"shinjo.nara.jp",
"soni.nara.jp",
"takatori.nara.jp",
"tawaramoto.nara.jp",
"tenkawa.nara.jp",
"tenri.nara.jp",
"uda.nara.jp",
"yamatokoriyama.nara.jp",
"yamatotakada.nara.jp",
"yamazoe.nara.jp",
"yoshino.nara.jp",
"aga.niigata.jp",
"agano.niigata.jp",
"gosen.niigata.jp",
"itoigawa.niigata.jp",
"izumozaki.niigata.jp",
"joetsu.niigata.jp",
"kamo.niigata.jp",
"kariwa.niigata.jp",
"kashiwazaki.niigata.jp",
"minamiuonuma.niigata.jp",
"mitsuke.niigata.jp",
"muika.niigata.jp",
"murakami.niigata.jp",
"myoko.niigata.jp",
"nagaoka.niigata.jp",
"niigata.niigata.jp",
"ojiya.niigata.jp",
"omi.niigata.jp",
"sado.niigata.jp",
"sanjo.niigata.jp",
"seiro.niigata.jp",
"seirou.niigata.jp",
"sekikawa.niigata.jp",
"shibata.niigata.jp",
"tagami.niigata.jp",
"tainai.niigata.jp",
"tochio.niigata.jp",
"tokamachi.niigata.jp",
"tsubame.niigata.jp",
"tsunan.niigata.jp",
"uonuma.niigata.jp",
"yahiko.niigata.jp",
"yoita.niigata.jp",
"yuzawa.niigata.jp",
"beppu.oita.jp",
"bungoono.oita.jp",
"bungotakada.oita.jp",
"hasama.oita.jp",
"hiji.oita.jp",
"himeshima.oita.jp",
"hita.oita.jp",
"kamitsue.oita.jp",
"kokonoe.oita.jp",
"kuju.oita.jp",
"kunisaki.oita.jp",
"kusu.oita.jp",
"oita.oita.jp",
"saiki.oita.jp",
"taketa.oita.jp",
"tsukumi.oita.jp",
"usa.oita.jp",
"usuki.oita.jp",
"yufu.oita.jp",
"akaiwa.okayama.jp",
"asakuchi.okayama.jp",
"bizen.okayama.jp",
"hayashima.okayama.jp",
"ibara.okayama.jp",
"kagamino.okayama.jp",
"kasaoka.okayama.jp",
"kibichuo.okayama.jp",
"kumenan.okayama.jp",
"kurashiki.okayama.jp",
"maniwa.okayama.jp",
"misaki.okayama.jp",
"nagi.okayama.jp",
"niimi.okayama.jp",
"nishiawakura.okayama.jp",
"okayama.okayama.jp",
"satosho.okayama.jp",
"setouchi.okayama.jp",
"shinjo.okayama.jp",
"shoo.okayama.jp",
"soja.okayama.jp",
"takahashi.okayama.jp",
"tamano.okayama.jp",
"tsuyama.okayama.jp",
"wake.okayama.jp",
"yakage.okayama.jp",
"aguni.okinawa.jp",
"ginowan.okinawa.jp",
"ginoza.okinawa.jp",
"gushikami.okinawa.jp",
"haebaru.okinawa.jp",
"higashi.okinawa.jp",
"hirara.okinawa.jp",
"iheya.okinawa.jp",
"ishigaki.okinawa.jp",
"ishikawa.okinawa.jp",
"itoman.okinawa.jp",
"izena.okinawa.jp",
"kadena.okinawa.jp",
"kin.okinawa.jp",
"kitadaito.okinawa.jp",
"kitanakagusuku.okinawa.jp",
"kumejima.okinawa.jp",
"kunigami.okinawa.jp",
"minamidaito.okinawa.jp",
"motobu.okinawa.jp",
"nago.okinawa.jp",
"naha.okinawa.jp",
"nakagusuku.okinawa.jp",
"nakijin.okinawa.jp",
"nanjo.okinawa.jp",
"nishihara.okinawa.jp",
"ogimi.okinawa.jp",
"okinawa.okinawa.jp",
"onna.okinawa.jp",
"shimoji.okinawa.jp",
"taketomi.okinawa.jp",
"tarama.okinawa.jp",
"tokashiki.okinawa.jp",
"tomigusuku.okinawa.jp",
"tonaki.okinawa.jp",
"urasoe.okinawa.jp",
"uruma.okinawa.jp",
"yaese.okinawa.jp",
"yomitan.okinawa.jp",
"yonabaru.okinawa.jp",
"yonaguni.okinawa.jp",
"zamami.okinawa.jp",
"abeno.osaka.jp",
"chihayaakasaka.osaka.jp",
"chuo.osaka.jp",
"daito.osaka.jp",
"fujiidera.osaka.jp",
"habikino.osaka.jp",
"hannan.osaka.jp",
"higashiosaka.osaka.jp",
"higashisumiyoshi.osaka.jp",
"higashiyodogawa.osaka.jp",
"hirakata.osaka.jp",
"ibaraki.osaka.jp",
"ikeda.osaka.jp",
"izumi.osaka.jp",
"izumiotsu.osaka.jp",
"izumisano.osaka.jp",
"kadoma.osaka.jp",
"kaizuka.osaka.jp",
"kanan.osaka.jp",
"kashiwara.osaka.jp",
"katano.osaka.jp",
"kawachinagano.osaka.jp",
"kishiwada.osaka.jp",
"kita.osaka.jp",
"kumatori.osaka.jp",
"matsubara.osaka.jp",
"minato.osaka.jp",
"minoh.osaka.jp",
"misaki.osaka.jp",
"moriguchi.osaka.jp",
"neyagawa.osaka.jp",
"nishi.osaka.jp",
"nose.osaka.jp",
"osakasayama.osaka.jp",
"sakai.osaka.jp",
"sayama.osaka.jp",
"sennan.osaka.jp",
"settsu.osaka.jp",
"shijonawate.osaka.jp",
"shimamoto.osaka.jp",
"suita.osaka.jp",
"tadaoka.osaka.jp",
"taishi.osaka.jp",
"tajiri.osaka.jp",
"takaishi.osaka.jp",
"takatsuki.osaka.jp",
"tondabayashi.osaka.jp",
"toyonaka.osaka.jp",
"toyono.osaka.jp",
"yao.osaka.jp",
"ariake.saga.jp",
"arita.saga.jp",
"fukudomi.saga.jp",
"genkai.saga.jp",
"hamatama.saga.jp",
"hizen.saga.jp",
"imari.saga.jp",
"kamimine.saga.jp",
"kanzaki.saga.jp",
"karatsu.saga.jp",
"kashima.saga.jp",
"kitagata.saga.jp",
"kitahata.saga.jp",
"kiyama.saga.jp",
"kouhoku.saga.jp",
"kyuragi.saga.jp",
"nishiarita.saga.jp",
"ogi.saga.jp",
"omachi.saga.jp",
"ouchi.saga.jp",
"saga.saga.jp",
"shiroishi.saga.jp",
"taku.saga.jp",
"tara.saga.jp",
"tosu.saga.jp",
"yoshinogari.saga.jp",
"arakawa.saitama.jp",
"asaka.saitama.jp",
"chichibu.saitama.jp",
"fujimi.saitama.jp",
"fujimino.saitama.jp",
"fukaya.saitama.jp",
"hanno.saitama.jp",
"hanyu.saitama.jp",
"hasuda.saitama.jp",
"hatogaya.saitama.jp",
"hatoyama.saitama.jp",
"hidaka.saitama.jp",
"higashichichibu.saitama.jp",
"higashimatsuyama.saitama.jp",
"honjo.saitama.jp",
"ina.saitama.jp",
"iruma.saitama.jp",
"iwatsuki.saitama.jp",
"kamiizumi.saitama.jp",
"kamikawa.saitama.jp",
"kamisato.saitama.jp",
"kasukabe.saitama.jp",
"kawagoe.saitama.jp",
"kawaguchi.saitama.jp",
"kawajima.saitama.jp",
"kazo.saitama.jp",
"kitamoto.saitama.jp",
"koshigaya.saitama.jp",
"kounosu.saitama.jp",
"kuki.saitama.jp",
"kumagaya.saitama.jp",
"matsubushi.saitama.jp",
"minano.saitama.jp",
"misato.saitama.jp",
"miyashiro.saitama.jp",
"miyoshi.saitama.jp",
"moroyama.saitama.jp",
"nagatoro.saitama.jp",
"namegawa.saitama.jp",
"niiza.saitama.jp",
"ogano.saitama.jp",
"ogawa.saitama.jp",
"ogose.saitama.jp",
"okegawa.saitama.jp",
"omiya.saitama.jp",
"otaki.saitama.jp",
"ranzan.saitama.jp",
"ryokami.saitama.jp",
"saitama.saitama.jp",
"sakado.saitama.jp",
"satte.saitama.jp",
"sayama.saitama.jp",
"shiki.saitama.jp",
"shiraoka.saitama.jp",
"soka.saitama.jp",
"sugito.saitama.jp",
"toda.saitama.jp",
"tokigawa.saitama.jp",
"tokorozawa.saitama.jp",
"tsurugashima.saitama.jp",
"urawa.saitama.jp",
"warabi.saitama.jp",
"yashio.saitama.jp",
"yokoze.saitama.jp",
"yono.saitama.jp",
"yorii.saitama.jp",
"yoshida.saitama.jp",
"yoshikawa.saitama.jp",
"yoshimi.saitama.jp",
"aisho.shiga.jp",
"gamo.shiga.jp",
"higashiomi.shiga.jp",
"hikone.shiga.jp",
"koka.shiga.jp",
"konan.shiga.jp",
"kosei.shiga.jp",
"koto.shiga.jp",
"kusatsu.shiga.jp",
"maibara.shiga.jp",
"moriyama.shiga.jp",
"nagahama.shiga.jp",
"nishiazai.shiga.jp",
"notogawa.shiga.jp",
"omihachiman.shiga.jp",
"otsu.shiga.jp",
"ritto.shiga.jp",
"ryuoh.shiga.jp",
"takashima.shiga.jp",
"takatsuki.shiga.jp",
"torahime.shiga.jp",
"toyosato.shiga.jp",
"yasu.shiga.jp",
"akagi.shimane.jp",
"ama.shimane.jp",
"gotsu.shimane.jp",
"hamada.shimane.jp",
"higashiizumo.shimane.jp",
"hikawa.shimane.jp",
"hikimi.shimane.jp",
"izumo.shimane.jp",
"kakinoki.shimane.jp",
"masuda.shimane.jp",
"matsue.shimane.jp",
"misato.shimane.jp",
"nishinoshima.shimane.jp",
"ohda.shimane.jp",
"okinoshima.shimane.jp",
"okuizumo.shimane.jp",
"shimane.shimane.jp",
"tamayu.shimane.jp",
"tsuwano.shimane.jp",
"unnan.shimane.jp",
"yakumo.shimane.jp",
"yasugi.shimane.jp",
"yatsuka.shimane.jp",
"arai.shizuoka.jp",
"atami.shizuoka.jp",
"fuji.shizuoka.jp",
"fujieda.shizuoka.jp",
"fujikawa.shizuoka.jp",
"fujinomiya.shizuoka.jp",
"fukuroi.shizuoka.jp",
"gotemba.shizuoka.jp",
"haibara.shizuoka.jp",
"hamamatsu.shizuoka.jp",
"higashiizu.shizuoka.jp",
"ito.shizuoka.jp",
"iwata.shizuoka.jp",
"izu.shizuoka.jp",
"izunokuni.shizuoka.jp",
"kakegawa.shizuoka.jp",
"kannami.shizuoka.jp",
"kawanehon.shizuoka.jp",
"kawazu.shizuoka.jp",
"kikugawa.shizuoka.jp",
"kosai.shizuoka.jp",
"makinohara.shizuoka.jp",
"matsuzaki.shizuoka.jp",
"minamiizu.shizuoka.jp",
"mishima.shizuoka.jp",
"morimachi.shizuoka.jp",
"nishiizu.shizuoka.jp",
"numazu.shizuoka.jp",
"omaezaki.shizuoka.jp",
"shimada.shizuoka.jp",
"shimizu.shizuoka.jp",
"shimoda.shizuoka.jp",
"shizuoka.shizuoka.jp",
"susono.shizuoka.jp",
"yaizu.shizuoka.jp",
"yoshida.shizuoka.jp",
"ashikaga.tochigi.jp",
"bato.tochigi.jp",
"haga.tochigi.jp",
"ichikai.tochigi.jp",
"iwafune.tochigi.jp",
"kaminokawa.tochigi.jp",
"kanuma.tochigi.jp",
"karasuyama.tochigi.jp",
"kuroiso.tochigi.jp",
"mashiko.tochigi.jp",
"mibu.tochigi.jp",
"moka.tochigi.jp",
"motegi.tochigi.jp",
"nasu.tochigi.jp",
"nasushiobara.tochigi.jp",
"nikko.tochigi.jp",
"nishikata.tochigi.jp",
"nogi.tochigi.jp",
"ohira.tochigi.jp",
"ohtawara.tochigi.jp",
"oyama.tochigi.jp",
"sakura.tochigi.jp",
"sano.tochigi.jp",
"shimotsuke.tochigi.jp",
"shioya.tochigi.jp",
"takanezawa.tochigi.jp",
"tochigi.tochigi.jp",
"tsuga.tochigi.jp",
"ujiie.tochigi.jp",
"utsunomiya.tochigi.jp",
"yaita.tochigi.jp",
"aizumi.tokushima.jp",
"anan.tokushima.jp",
"ichiba.tokushima.jp",
"itano.tokushima.jp",
"kainan.tokushima.jp",
"komatsushima.tokushima.jp",
"matsushige.tokushima.jp",
"mima.tokushima.jp",
"minami.tokushima.jp",
"miyoshi.tokushima.jp",
"mugi.tokushima.jp",
"nakagawa.tokushima.jp",
"naruto.tokushima.jp",
"sanagochi.tokushima.jp",
"shishikui.tokushima.jp",
"tokushima.tokushima.jp",
"wajiki.tokushima.jp",
"adachi.tokyo.jp",
"akiruno.tokyo.jp",
"akishima.tokyo.jp",
"aogashima.tokyo.jp",
"arakawa.tokyo.jp",
"bunkyo.tokyo.jp",
"chiyoda.tokyo.jp",
"chofu.tokyo.jp",
"chuo.tokyo.jp",
"edogawa.tokyo.jp",
"fuchu.tokyo.jp",
"fussa.tokyo.jp",
"hachijo.tokyo.jp",
"hachioji.tokyo.jp",
"hamura.tokyo.jp",
"higashikurume.tokyo.jp",
"higashimurayama.tokyo.jp",
"higashiyamato.tokyo.jp",
"hino.tokyo.jp",
"hinode.tokyo.jp",
"hinohara.tokyo.jp",
"inagi.tokyo.jp",
"itabashi.tokyo.jp",
"katsushika.tokyo.jp",
"kita.tokyo.jp",
"kiyose.tokyo.jp",
"kodaira.tokyo.jp",
"koganei.tokyo.jp",
"kokubunji.tokyo.jp",
"komae.tokyo.jp",
"koto.tokyo.jp",
"kouzushima.tokyo.jp",
"kunitachi.tokyo.jp",
"machida.tokyo.jp",
"meguro.tokyo.jp",
"minato.tokyo.jp",
"mitaka.tokyo.jp",
"mizuho.tokyo.jp",
"musashimurayama.tokyo.jp",
"musashino.tokyo.jp",
"nakano.tokyo.jp",
"nerima.tokyo.jp",
"ogasawara.tokyo.jp",
"okutama.tokyo.jp",
"ome.tokyo.jp",
"oshima.tokyo.jp",
"ota.tokyo.jp",
"setagaya.tokyo.jp",
"shibuya.tokyo.jp",
"shinagawa.tokyo.jp",
"shinjuku.tokyo.jp",
"suginami.tokyo.jp",
"sumida.tokyo.jp",
"tachikawa.tokyo.jp",
"taito.tokyo.jp",
"tama.tokyo.jp",
"toshima.tokyo.jp",
"chizu.tottori.jp",
"hino.tottori.jp",
"kawahara.tottori.jp",
"koge.tottori.jp",
"kotoura.tottori.jp",
"misasa.tottori.jp",
"nanbu.tottori.jp",
"nichinan.tottori.jp",
"sakaiminato.tottori.jp",
"tottori.tottori.jp",
"wakasa.tottori.jp",
"yazu.tottori.jp",
"yonago.tottori.jp",
"asahi.toyama.jp",
"fuchu.toyama.jp",
"fukumitsu.toyama.jp",
"funahashi.toyama.jp",
"himi.toyama.jp",
"imizu.toyama.jp",
"inami.toyama.jp",
"johana.toyama.jp",
"kamiichi.toyama.jp",
"kurobe.toyama.jp",
"nakaniikawa.toyama.jp",
"namerikawa.toyama.jp",
"nanto.toyama.jp",
"nyuzen.toyama.jp",
"oyabe.toyama.jp",
"taira.toyama.jp",
"takaoka.toyama.jp",
"tateyama.toyama.jp",
"toga.toyama.jp",
"tonami.toyama.jp",
"toyama.toyama.jp",
"unazuki.toyama.jp",
"uozu.toyama.jp",
"yamada.toyama.jp",
"arida.wakayama.jp",
"aridagawa.wakayama.jp",
"gobo.wakayama.jp",
"hashimoto.wakayama.jp",
"hidaka.wakayama.jp",
"hirogawa.wakayama.jp",
"inami.wakayama.jp",
"iwade.wakayama.jp",
"kainan.wakayama.jp",
"kamitonda.wakayama.jp",
"katsuragi.wakayama.jp",
"kimino.wakayama.jp",
"kinokawa.wakayama.jp",
"kitayama.wakayama.jp",
"koya.wakayama.jp",
"koza.wakayama.jp",
"kozagawa.wakayama.jp",
"kudoyama.wakayama.jp",
"kushimoto.wakayama.jp",
"mihama.wakayama.jp",
"misato.wakayama.jp",
"nachikatsuura.wakayama.jp",
"shingu.wakayama.jp",
"shirahama.wakayama.jp",
"taiji.wakayama.jp",
"tanabe.wakayama.jp",
"wakayama.wakayama.jp",
"yuasa.wakayama.jp",
"yura.wakayama.jp",
"asahi.yamagata.jp",
"funagata.yamagata.jp",
"higashine.yamagata.jp",
"iide.yamagata.jp",
"kahoku.yamagata.jp",
"kaminoyama.yamagata.jp",
"kaneyama.yamagata.jp",
"kawanishi.yamagata.jp",
"mamurogawa.yamagata.jp",
"mikawa.yamagata.jp",
"murayama.yamagata.jp",
"nagai.yamagata.jp",
"nakayama.yamagata.jp",
"nanyo.yamagata.jp",
"nishikawa.yamagata.jp",
"obanazawa.yamagata.jp",
"oe.yamagata.jp",
"oguni.yamagata.jp",
"ohkura.yamagata.jp",
"oishida.yamagata.jp",
"sagae.yamagata.jp",
"sakata.yamagata.jp",
"sakegawa.yamagata.jp",
"shinjo.yamagata.jp",
"shirataka.yamagata.jp",
"shonai.yamagata.jp",
"takahata.yamagata.jp",
"tendo.yamagata.jp",
"tozawa.yamagata.jp",
"tsuruoka.yamagata.jp",
"yamagata.yamagata.jp",
"yamanobe.yamagata.jp",
"yonezawa.yamagata.jp",
"yuza.yamagata.jp",
"abu.yamaguchi.jp",
"hagi.yamaguchi.jp",
"hikari.yamaguchi.jp",
"hofu.yamaguchi.jp",
"iwakuni.yamaguchi.jp",
"kudamatsu.yamaguchi.jp",
"mitou.yamaguchi.jp",
"nagato.yamaguchi.jp",
"oshima.yamaguchi.jp",
"shimonoseki.yamaguchi.jp",
"shunan.yamaguchi.jp",
"tabuse.yamaguchi.jp",
"tokuyama.yamaguchi.jp",
"toyota.yamaguchi.jp",
"ube.yamaguchi.jp",
"yuu.yamaguchi.jp",
"chuo.yamanashi.jp",
"doshi.yamanashi.jp",
"fuefuki.yamanashi.jp",
"fujikawa.yamanashi.jp",
"fujikawaguchiko.yamanashi.jp",
"fujiyoshida.yamanashi.jp",
"hayakawa.yamanashi.jp",
"hokuto.yamanashi.jp",
"ichikawamisato.yamanashi.jp",
"kai.yamanashi.jp",
"kofu.yamanashi.jp",
"koshu.yamanashi.jp",
"kosuge.yamanashi.jp",
"minami-alps.yamanashi.jp",
"minobu.yamanashi.jp",
"nakamichi.yamanashi.jp",
"nanbu.yamanashi.jp",
"narusawa.yamanashi.jp",
"nirasaki.yamanashi.jp",
"nishikatsura.yamanashi.jp",
"oshino.yamanashi.jp",
"otsuki.yamanashi.jp",
"showa.yamanashi.jp",
"tabayama.yamanashi.jp",
"tsuru.yamanashi.jp",
"uenohara.yamanashi.jp",
"yamanakako.yamanashi.jp",
"yamanashi.yamanashi.jp",
"ke",
"ac.ke",
"co.ke",
"go.ke",
"info.ke",
"me.ke",
"mobi.ke",
"ne.ke",
"or.ke",
"sc.ke",
"kg",
"org.kg",
"net.kg",
"com.kg",
"edu.kg",
"gov.kg",
"mil.kg",
"*.kh",
"ki",
"edu.ki",
"biz.ki",
"net.ki",
"org.ki",
"gov.ki",
"info.ki",
"com.ki",
"km",
"org.km",
"nom.km",
"gov.km",
"prd.km",
"tm.km",
"edu.km",
"mil.km",
"ass.km",
"com.km",
"coop.km",
"asso.km",
"presse.km",
"medecin.km",
"notaires.km",
"pharmaciens.km",
"veterinaire.km",
"gouv.km",
"kn",
"net.kn",
"org.kn",
"edu.kn",
"gov.kn",
"kp",
"com.kp",
"edu.kp",
"gov.kp",
"org.kp",
"rep.kp",
"tra.kp",
"kr",
"ac.kr",
"co.kr",
"es.kr",
"go.kr",
"hs.kr",
"kg.kr",
"mil.kr",
"ms.kr",
"ne.kr",
"or.kr",
"pe.kr",
"re.kr",
"sc.kr",
"busan.kr",
"chungbuk.kr",
"chungnam.kr",
"daegu.kr",
"daejeon.kr",
"gangwon.kr",
"gwangju.kr",
"gyeongbuk.kr",
"gyeonggi.kr",
"gyeongnam.kr",
"incheon.kr",
"jeju.kr",
"jeonbuk.kr",
"jeonnam.kr",
"seoul.kr",
"ulsan.kr",
"kw",
"com.kw",
"edu.kw",
"emb.kw",
"gov.kw",
"ind.kw",
"net.kw",
"org.kw",
"ky",
"com.ky",
"edu.ky",
"net.ky",
"org.ky",
"kz",
"org.kz",
"edu.kz",
"net.kz",
"gov.kz",
"mil.kz",
"com.kz",
"la",
"int.la",
"net.la",
"info.la",
"edu.la",
"gov.la",
"per.la",
"com.la",
"org.la",
"lb",
"com.lb",
"edu.lb",
"gov.lb",
"net.lb",
"org.lb",
"lc",
"com.lc",
"net.lc",
"co.lc",
"org.lc",
"edu.lc",
"gov.lc",
"li",
"lk",
"gov.lk",
"sch.lk",
"net.lk",
"int.lk",
"com.lk",
"org.lk",
"edu.lk",
"ngo.lk",
"soc.lk",
"web.lk",
"ltd.lk",
"assn.lk",
"grp.lk",
"hotel.lk",
"ac.lk",
"lr",
"com.lr",
"edu.lr",
"gov.lr",
"org.lr",
"net.lr",
"ls",
"ac.ls",
"biz.ls",
"co.ls",
"edu.ls",
"gov.ls",
"info.ls",
"net.ls",
"org.ls",
"sc.ls",
"lt",
"gov.lt",
"lu",
"lv",
"com.lv",
"edu.lv",
"gov.lv",
"org.lv",
"mil.lv",
"id.lv",
"net.lv",
"asn.lv",
"conf.lv",
"ly",
"com.ly",
"net.ly",
"gov.ly",
"plc.ly",
"edu.ly",
"sch.ly",
"med.ly",
"org.ly",
"id.ly",
"ma",
"co.ma",
"net.ma",
"gov.ma",
"org.ma",
"ac.ma",
"press.ma",
"mc",
"tm.mc",
"asso.mc",
"md",
"me",
"co.me",
"net.me",
"org.me",
"edu.me",
"ac.me",
"gov.me",
"its.me",
"priv.me",
"mg",
"org.mg",
"nom.mg",
"gov.mg",
"prd.mg",
"tm.mg",
"edu.mg",
"mil.mg",
"com.mg",
"co.mg",
"mh",
"mil",
"mk",
"com.mk",
"org.mk",
"net.mk",
"edu.mk",
"gov.mk",
"inf.mk",
"name.mk",
"ml",
"com.ml",
"edu.ml",
"gouv.ml",
"gov.ml",
"net.ml",
"org.ml",
"presse.ml",
"*.mm",
"mn",
"gov.mn",
"edu.mn",
"org.mn",
"mo",
"com.mo",
"net.mo",
"org.mo",
"edu.mo",
"gov.mo",
"mobi",
"mp",
"mq",
"mr",
"gov.mr",
"ms",
"com.ms",
"edu.ms",
"gov.ms",
"net.ms",
"org.ms",
"mt",
"com.mt",
"edu.mt",
"net.mt",
"org.mt",
"mu",
"com.mu",
"net.mu",
"org.mu",
"gov.mu",
"ac.mu",
"co.mu",
"or.mu",
"museum",
"academy.museum",
"agriculture.museum",
"air.museum",
"airguard.museum",
"alabama.museum",
"alaska.museum",
"amber.museum",
"ambulance.museum",
"american.museum",
"americana.museum",
"americanantiques.museum",
"americanart.museum",
"amsterdam.museum",
"and.museum",
"annefrank.museum",
"anthro.museum",
"anthropology.museum",
"antiques.museum",
"aquarium.museum",
"arboretum.museum",
"archaeological.museum",
"archaeology.museum",
"architecture.museum",
"art.museum",
"artanddesign.museum",
"artcenter.museum",
"artdeco.museum",
"arteducation.museum",
"artgallery.museum",
"arts.museum",
"artsandcrafts.museum",
"asmatart.museum",
"assassination.museum",
"assisi.museum",
"association.museum",
"astronomy.museum",
"atlanta.museum",
"austin.museum",
"australia.museum",
"automotive.museum",
"aviation.museum",
"axis.museum",
"badajoz.museum",
"baghdad.museum",
"bahn.museum",
"bale.museum",
"baltimore.museum",
"barcelona.museum",
"baseball.museum",
"basel.museum",
"baths.museum",
"bauern.museum",
"beauxarts.museum",
"beeldengeluid.museum",
"bellevue.museum",
"bergbau.museum",
"berkeley.museum",
"berlin.museum",
"bern.museum",
"bible.museum",
"bilbao.museum",
"bill.museum",
"birdart.museum",
"birthplace.museum",
"bonn.museum",
"boston.museum",
"botanical.museum",
"botanicalgarden.museum",
"botanicgarden.museum",
"botany.museum",
"brandywinevalley.museum",
"brasil.museum",
"bristol.museum",
"british.museum",
"britishcolumbia.museum",
"broadcast.museum",
"brunel.museum",
"brussel.museum",
"brussels.museum",
"bruxelles.museum",
"building.museum",
"burghof.museum",
"bus.museum",
"bushey.museum",
"cadaques.museum",
"california.museum",
"cambridge.museum",
"can.museum",
"canada.museum",
"capebreton.museum",
"carrier.museum",
"cartoonart.museum",
"casadelamoneda.museum",
"castle.museum",
"castres.museum",
"celtic.museum",
"center.museum",
"chattanooga.museum",
"cheltenham.museum",
"chesapeakebay.museum",
"chicago.museum",
"children.museum",
"childrens.museum",
"childrensgarden.museum",
"chiropractic.museum",
"chocolate.museum",
"christiansburg.museum",
"cincinnati.museum",
"cinema.museum",
"circus.museum",
"civilisation.museum",
"civilization.museum",
"civilwar.museum",
"clinton.museum",
"clock.museum",
"coal.museum",
"coastaldefence.museum",
"cody.museum",
"coldwar.museum",
"collection.museum",
"colonialwilliamsburg.museum",
"coloradoplateau.museum",
"columbia.museum",
"columbus.museum",
"communication.museum",
"communications.museum",
"community.museum",
"computer.museum",
"computerhistory.museum",
"comunicaes.museum",
"contemporary.museum",
"contemporaryart.museum",
"convent.museum",
"copenhagen.museum",
"corporation.museum",
"correios-e-telecomunicaes.museum",
"corvette.museum",
"costume.museum",
"countryestate.museum",
"county.museum",
"crafts.museum",
"cranbrook.museum",
"creation.museum",
"cultural.museum",
"culturalcenter.museum",
"culture.museum",
"cyber.museum",
"cymru.museum",
"dali.museum",
"dallas.museum",
"database.museum",
"ddr.museum",
"decorativearts.museum",
"delaware.museum",
"delmenhorst.museum",
"denmark.museum",
"depot.museum",
"design.museum",
"detroit.museum",
"dinosaur.museum",
"discovery.museum",
"dolls.museum",
"donostia.museum",
"durham.museum",
"eastafrica.museum",
"eastcoast.museum",
"education.museum",
"educational.museum",
"egyptian.museum",
"eisenbahn.museum",
"elburg.museum",
"elvendrell.museum",
"embroidery.museum",
"encyclopedic.museum",
"england.museum",
"entomology.museum",
"environment.museum",
"environmentalconservation.museum",
"epilepsy.museum",
"essex.museum",
"estate.museum",
"ethnology.museum",
"exeter.museum",
"exhibition.museum",
"family.museum",
"farm.museum",
"farmequipment.museum",
"farmers.museum",
"farmstead.museum",
"field.museum",
"figueres.museum",
"filatelia.museum",
"film.museum",
"fineart.museum",
"finearts.museum",
"finland.museum",
"flanders.museum",
"florida.museum",
"force.museum",
"fortmissoula.museum",
"fortworth.museum",
"foundation.museum",
"francaise.museum",
"frankfurt.museum",
"franziskaner.museum",
"freemasonry.museum",
"freiburg.museum",
"fribourg.museum",
"frog.museum",
"fundacio.museum",
"furniture.museum",
"gallery.museum",
"garden.museum",
"gateway.museum",
"geelvinck.museum",
"gemological.museum",
"geology.museum",
"georgia.museum",
"giessen.museum",
"glas.museum",
"glass.museum",
"gorge.museum",
"grandrapids.museum",
"graz.museum",
"guernsey.museum",
"halloffame.museum",
"hamburg.museum",
"handson.museum",
"harvestcelebration.museum",
"hawaii.museum",
"health.museum",
"heimatunduhren.museum",
"hellas.museum",
"helsinki.museum",
"hembygdsforbund.museum",
"heritage.museum",
"histoire.museum",
"historical.museum",
"historicalsociety.museum",
"historichouses.museum",
"historisch.museum",
"historisches.museum",
"history.museum",
"historyofscience.museum",
"horology.museum",
"house.museum",
"humanities.museum",
"illustration.museum",
"imageandsound.museum",
"indian.museum",
"indiana.museum",
"indianapolis.museum",
"indianmarket.museum",
"intelligence.museum",
"interactive.museum",
"iraq.museum",
"iron.museum",
"isleofman.museum",
"jamison.museum",
"jefferson.museum",
"jerusalem.museum",
"jewelry.museum",
"jewish.museum",
"jewishart.museum",
"jfk.museum",
"journalism.museum",
"judaica.museum",
"judygarland.museum",
"juedisches.museum",
"juif.museum",
"karate.museum",
"karikatur.museum",
"kids.museum",
"koebenhavn.museum",
"koeln.museum",
"kunst.museum",
"kunstsammlung.museum",
"kunstunddesign.museum",
"labor.museum",
"labour.museum",
"lajolla.museum",
"lancashire.museum",
"landes.museum",
"lans.museum",
"lns.museum",
"larsson.museum",
"lewismiller.museum",
"lincoln.museum",
"linz.museum",
"living.museum",
"livinghistory.museum",
"localhistory.museum",
"london.museum",
"losangeles.museum",
"louvre.museum",
"loyalist.museum",
"lucerne.museum",
"luxembourg.museum",
"luzern.museum",
"mad.museum",
"madrid.museum",
"mallorca.museum",
"manchester.museum",
"mansion.museum",
"mansions.museum",
"manx.museum",
"marburg.museum",
"maritime.museum",
"maritimo.museum",
"maryland.museum",
"marylhurst.museum",
"media.museum",
"medical.museum",
"medizinhistorisches.museum",
"meeres.museum",
"memorial.museum",
"mesaverde.museum",
"michigan.museum",
"midatlantic.museum",
"military.museum",
"mill.museum",
"miners.museum",
"mining.museum",
"minnesota.museum",
"missile.museum",
"missoula.museum",
"modern.museum",
"moma.museum",
"money.museum",
"monmouth.museum",
"monticello.museum",
"montreal.museum",
"moscow.museum",
"motorcycle.museum",
"muenchen.museum",
"muenster.museum",
"mulhouse.museum",
"muncie.museum",
"museet.museum",
"museumcenter.museum",
"museumvereniging.museum",
"music.museum",
"national.museum",
"nationalfirearms.museum",
"nationalheritage.museum",
"nativeamerican.museum",
"naturalhistory.museum",
"naturalhistorymuseum.museum",
"naturalsciences.museum",
"nature.museum",
"naturhistorisches.museum",
"natuurwetenschappen.museum",
"naumburg.museum",
"naval.museum",
"nebraska.museum",
"neues.museum",
"newhampshire.museum",
"newjersey.museum",
"newmexico.museum",
"newport.museum",
"newspaper.museum",
"newyork.museum",
"niepce.museum",
"norfolk.museum",
"north.museum",
"nrw.museum",
"nyc.museum",
"nyny.museum",
"oceanographic.museum",
"oceanographique.museum",
"omaha.museum",
"online.museum",
"ontario.museum",
"openair.museum",
"oregon.museum",
"oregontrail.museum",
"otago.museum",
"oxford.museum",
"pacific.museum",
"paderborn.museum",
"palace.museum",
"paleo.museum",
"palmsprings.museum",
"panama.museum",
"paris.museum",
"pasadena.museum",
"pharmacy.museum",
"philadelphia.museum",
"philadelphiaarea.museum",
"philately.museum",
"phoenix.museum",
"photography.museum",
"pilots.museum",
"pittsburgh.museum",
"planetarium.museum",
"plantation.museum",
"plants.museum",
"plaza.museum",
"portal.museum",
"portland.museum",
"portlligat.museum",
"posts-and-telecommunications.museum",
"preservation.museum",
"presidio.museum",
"press.museum",
"project.museum",
"public.museum",
"pubol.museum",
"quebec.museum",
"railroad.museum",
"railway.museum",
"research.museum",
"resistance.museum",
"riodejaneiro.museum",
"rochester.museum",
"rockart.museum",
"roma.museum",
"russia.museum",
"saintlouis.museum",
"salem.museum",
"salvadordali.museum",
"salzburg.museum",
"sandiego.museum",
"sanfrancisco.museum",
"santabarbara.museum",
"santacruz.museum",
"santafe.museum",
"saskatchewan.museum",
"satx.museum",
"savannahga.museum",
"schlesisches.museum",
"schoenbrunn.museum",
"schokoladen.museum",
"school.museum",
"schweiz.museum",
"science.museum",
"scienceandhistory.museum",
"scienceandindustry.museum",
"sciencecenter.museum",
"sciencecenters.museum",
"science-fiction.museum",
"sciencehistory.museum",
"sciences.museum",
"sciencesnaturelles.museum",
"scotland.museum",
"seaport.museum",
"settlement.museum",
"settlers.museum",
"shell.museum",
"sherbrooke.museum",
"sibenik.museum",
"silk.museum",
"ski.museum",
"skole.museum",
"society.museum",
"sologne.museum",
"soundandvision.museum",
"southcarolina.museum",
"southwest.museum",
"space.museum",
"spy.museum",
"square.museum",
"stadt.museum",
"stalbans.museum",
"starnberg.museum",
"state.museum",
"stateofdelaware.museum",
"station.museum",
"steam.museum",
"steiermark.museum",
"stjohn.museum",
"stockholm.museum",
"stpetersburg.museum",
"stuttgart.museum",
"suisse.museum",
"surgeonshall.museum",
"surrey.museum",
"svizzera.museum",
"sweden.museum",
"sydney.museum",
"tank.museum",
"tcm.museum",
"technology.museum",
"telekommunikation.museum",
"television.museum",
"texas.museum",
"textile.museum",
"theater.museum",
"time.museum",
"timekeeping.museum",
"topology.museum",
"torino.museum",
"touch.museum",
"town.museum",
"transport.museum",
"tree.museum",
"trolley.museum",
"trust.museum",
"trustee.museum",
"uhren.museum",
"ulm.museum",
"undersea.museum",
"university.museum",
"usa.museum",
"usantiques.museum",
"usarts.museum",
"uscountryestate.museum",
"usculture.museum",
"usdecorativearts.museum",
"usgarden.museum",
"ushistory.museum",
"ushuaia.museum",
"uslivinghistory.museum",
"utah.museum",
"uvic.museum",
"valley.museum",
"vantaa.museum",
"versailles.museum",
"viking.museum",
"village.museum",
"virginia.museum",
"virtual.museum",
"virtuel.museum",
"vlaanderen.museum",
"volkenkunde.museum",
"wales.museum",
"wallonie.museum",
"war.museum",
"washingtondc.museum",
"watchandclock.museum",
"watch-and-clock.museum",
"western.museum",
"westfalen.museum",
"whaling.museum",
"wildlife.museum",
"williamsburg.museum",
"windmill.museum",
"workshop.museum",
"york.museum",
"yorkshire.museum",
"yosemite.museum",
"youth.museum",
"zoological.museum",
"zoology.museum",
".museum",
".museum",
"mv",
"aero.mv",
"biz.mv",
"com.mv",
"coop.mv",
"edu.mv",
"gov.mv",
"info.mv",
"int.mv",
"mil.mv",
"museum.mv",
"name.mv",
"net.mv",
"org.mv",
"pro.mv",
"mw",
"ac.mw",
"biz.mw",
"co.mw",
"com.mw",
"coop.mw",
"edu.mw",
"gov.mw",
"int.mw",
"museum.mw",
"net.mw",
"org.mw",
"mx",
"com.mx",
"org.mx",
"gob.mx",
"edu.mx",
"net.mx",
"my",
"biz.my",
"com.my",
"edu.my",
"gov.my",
"mil.my",
"name.my",
"net.my",
"org.my",
"mz",
"ac.mz",
"adv.mz",
"co.mz",
"edu.mz",
"gov.mz",
"mil.mz",
"net.mz",
"org.mz",
"na",
"info.na",
"pro.na",
"name.na",
"school.na",
"or.na",
"dr.na",
"us.na",
"mx.na",
"ca.na",
"in.na",
"cc.na",
"tv.na",
"ws.na",
"mobi.na",
"co.na",
"com.na",
"org.na",
"name",
"nc",
"asso.nc",
"nom.nc",
"ne",
"net",
"nf",
"com.nf",
"net.nf",
"per.nf",
"rec.nf",
"web.nf",
"arts.nf",
"firm.nf",
"info.nf",
"other.nf",
"store.nf",
"ng",
"com.ng",
"edu.ng",
"gov.ng",
"i.ng",
"mil.ng",
"mobi.ng",
"name.ng",
"net.ng",
"org.ng",
"sch.ng",
"ni",
"ac.ni",
"biz.ni",
"co.ni",
"com.ni",
"edu.ni",
"gob.ni",
"in.ni",
"info.ni",
"int.ni",
"mil.ni",
"net.ni",
"nom.ni",
"org.ni",
"web.ni",
"nl",
"no",
"fhs.no",
"vgs.no",
"fylkesbibl.no",
"folkebibl.no",
"museum.no",
"idrett.no",
"priv.no",
"mil.no",
"stat.no",
"dep.no",
"kommune.no",
"herad.no",
"aa.no",
"ah.no",
"bu.no",
"fm.no",
"hl.no",
"hm.no",
"jan-mayen.no",
"mr.no",
"nl.no",
"nt.no",
"of.no",
"ol.no",
"oslo.no",
"rl.no",
"sf.no",
"st.no",
"svalbard.no",
"tm.no",
"tr.no",
"va.no",
"vf.no",
"gs.aa.no",
"gs.ah.no",
"gs.bu.no",
"gs.fm.no",
"gs.hl.no",
"gs.hm.no",
"gs.jan-mayen.no",
"gs.mr.no",
"gs.nl.no",
"gs.nt.no",
"gs.of.no",
"gs.ol.no",
"gs.oslo.no",
"gs.rl.no",
"gs.sf.no",
"gs.st.no",
"gs.svalbard.no",
"gs.tm.no",
"gs.tr.no",
"gs.va.no",
"gs.vf.no",
"akrehamn.no",
"krehamn.no",
"algard.no",
"lgrd.no",
"arna.no",
"brumunddal.no",
"bryne.no",
"bronnoysund.no",
"brnnysund.no",
"drobak.no",
"drbak.no",
"egersund.no",
"fetsund.no",
"floro.no",
"flor.no",
"fredrikstad.no",
"hokksund.no",
"honefoss.no",
"hnefoss.no",
"jessheim.no",
"jorpeland.no",
"jrpeland.no",
"kirkenes.no",
"kopervik.no",
"krokstadelva.no",
"langevag.no",
"langevg.no",
"leirvik.no",
"mjondalen.no",
"mjndalen.no",
"mo-i-rana.no",
"mosjoen.no",
"mosjen.no",
"nesoddtangen.no",
"orkanger.no",
"osoyro.no",
"osyro.no",
"raholt.no",
"rholt.no",
"sandnessjoen.no",
"sandnessjen.no",
"skedsmokorset.no",
"slattum.no",
"spjelkavik.no",
"stathelle.no",
"stavern.no",
"stjordalshalsen.no",
"stjrdalshalsen.no",
"tananger.no",
"tranby.no",
"vossevangen.no",
"afjord.no",
"fjord.no",
"agdenes.no",
"al.no",
"l.no",
"alesund.no",
"lesund.no",
"alstahaug.no",
"alta.no",
"lt.no",
"alaheadju.no",
"laheadju.no",
"alvdal.no",
"amli.no",
"mli.no",
"amot.no",
"mot.no",
"andebu.no",
"andoy.no",
"andy.no",
"andasuolo.no",
"ardal.no",
"rdal.no",
"aremark.no",
"arendal.no",
"s.no",
"aseral.no",
"seral.no",
"asker.no",
"askim.no",
"askvoll.no",
"askoy.no",
"asky.no",
"asnes.no",
"snes.no",
"audnedaln.no",
"aukra.no",
"aure.no",
"aurland.no",
"aurskog-holand.no",
"aurskog-hland.no",
"austevoll.no",
"austrheim.no",
"averoy.no",
"avery.no",
"balestrand.no",
"ballangen.no",
"balat.no",
"blt.no",
"balsfjord.no",
"bahccavuotna.no",
"bhccavuotna.no",
"bamble.no",
"bardu.no",
"beardu.no",
"beiarn.no",
"bajddar.no",
"bjddar.no",
"baidar.no",
"bidr.no",
"berg.no",
"bergen.no",
"berlevag.no",
"berlevg.no",
"bearalvahki.no",
"bearalvhki.no",
"bindal.no",
"birkenes.no",
"bjarkoy.no",
"bjarky.no",
"bjerkreim.no",
"bjugn.no",
"bodo.no",
"bod.no",
"badaddja.no",
"bdddj.no",
"budejju.no",
"bokn.no",
"bremanger.no",
"bronnoy.no",
"brnny.no",
"bygland.no",
"bykle.no",
"barum.no",
"brum.no",
"bo.telemark.no",
"b.telemark.no",
"bo.nordland.no",
"b.nordland.no",
"bievat.no",
"bievt.no",
"bomlo.no",
"bmlo.no",
"batsfjord.no",
"btsfjord.no",
"bahcavuotna.no",
"bhcavuotna.no",
"dovre.no",
"drammen.no",
"drangedal.no",
"dyroy.no",
"dyry.no",
"donna.no",
"dnna.no",
"eid.no",
"eidfjord.no",
"eidsberg.no",
"eidskog.no",
"eidsvoll.no",
"eigersund.no",
"elverum.no",
"enebakk.no",
"engerdal.no",
"etne.no",
"etnedal.no",
"evenes.no",
"evenassi.no",
"eveni.no",
"evje-og-hornnes.no",
"farsund.no",
"fauske.no",
"fuossko.no",
"fuoisku.no",
"fedje.no",
"fet.no",
"finnoy.no",
"finny.no",
"fitjar.no",
"fjaler.no",
"fjell.no",
"flakstad.no",
"flatanger.no",
"flekkefjord.no",
"flesberg.no",
"flora.no",
"fla.no",
"fl.no",
"folldal.no",
"forsand.no",
"fosnes.no",
"frei.no",
"frogn.no",
"froland.no",
"frosta.no",
"frana.no",
"frna.no",
"froya.no",
"frya.no",
"fusa.no",
"fyresdal.no",
"forde.no",
"frde.no",
"gamvik.no",
"gangaviika.no",
"ggaviika.no",
"gaular.no",
"gausdal.no",
"gildeskal.no",
"gildeskl.no",
"giske.no",
"gjemnes.no",
"gjerdrum.no",
"gjerstad.no",
"gjesdal.no",
"gjovik.no",
"gjvik.no",
"gloppen.no",
"gol.no",
"gran.no",
"grane.no",
"granvin.no",
"gratangen.no",
"grimstad.no",
"grong.no",
"kraanghke.no",
"kranghke.no",
"grue.no",
"gulen.no",
"hadsel.no",
"halden.no",
"halsa.no",
"hamar.no",
"hamaroy.no",
"habmer.no",
"hbmer.no",
"hapmir.no",
"hpmir.no",
"hammerfest.no",
"hammarfeasta.no",
"hmmrfeasta.no",
"haram.no",
"hareid.no",
"harstad.no",
"hasvik.no",
"aknoluokta.no",
"koluokta.no",
"hattfjelldal.no",
"aarborte.no",
"haugesund.no",
"hemne.no",
"hemnes.no",
"hemsedal.no",
"heroy.more-og-romsdal.no",
"hery.mre-og-romsdal.no",
"heroy.nordland.no",
"hery.nordland.no",
"hitra.no",
"hjartdal.no",
"hjelmeland.no",
"hobol.no",
"hobl.no",
"hof.no",
"hol.no",
"hole.no",
"holmestrand.no",
"holtalen.no",
"holtlen.no",
"hornindal.no",
"horten.no",
"hurdal.no",
"hurum.no",
"hvaler.no",
"hyllestad.no",
"hagebostad.no",
"hgebostad.no",
"hoyanger.no",
"hyanger.no",
"hoylandet.no",
"hylandet.no",
"ha.no",
"h.no",
"ibestad.no",
"inderoy.no",
"indery.no",
"iveland.no",
"jevnaker.no",
"jondal.no",
"jolster.no",
"jlster.no",
"karasjok.no",
"karasjohka.no",
"krjohka.no",
"karlsoy.no",
"galsa.no",
"gls.no",
"karmoy.no",
"karmy.no",
"kautokeino.no",
"guovdageaidnu.no",
"klepp.no",
"klabu.no",
"klbu.no",
"kongsberg.no",
"kongsvinger.no",
"kragero.no",
"krager.no",
"kristiansand.no",
"kristiansund.no",
"krodsherad.no",
"krdsherad.no",
"kvalsund.no",
"rahkkeravju.no",
"rhkkervju.no",
"kvam.no",
"kvinesdal.no",
"kvinnherad.no",
"kviteseid.no",
"kvitsoy.no",
"kvitsy.no",
"kvafjord.no",
"kvfjord.no",
"giehtavuoatna.no",
"kvanangen.no",
"kvnangen.no",
"navuotna.no",
"nvuotna.no",
"kafjord.no",
"kfjord.no",
"gaivuotna.no",
"givuotna.no",
"larvik.no",
"lavangen.no",
"lavagis.no",
"loabat.no",
"loabt.no",
"lebesby.no",
"davvesiida.no",
"leikanger.no",
"leirfjord.no",
"leka.no",
"leksvik.no",
"lenvik.no",
"leangaviika.no",
"leagaviika.no",
"lesja.no",
"levanger.no",
"lier.no",
"lierne.no",
"lillehammer.no",
"lillesand.no",
"lindesnes.no",
"lindas.no",
"linds.no",
"lom.no",
"loppa.no",
"lahppi.no",
"lhppi.no",
"lund.no",
"lunner.no",
"luroy.no",
"lury.no",
"luster.no",
"lyngdal.no",
"lyngen.no",
"ivgu.no",
"lardal.no",
"lerdal.no",
"lrdal.no",
"lodingen.no",
"ldingen.no",
"lorenskog.no",
"lrenskog.no",
"loten.no",
"lten.no",
"malvik.no",
"masoy.no",
"msy.no",
"muosat.no",
"muost.no",
"mandal.no",
"marker.no",
"marnardal.no",
"masfjorden.no",
"meland.no",
"meldal.no",
"melhus.no",
"meloy.no",
"mely.no",
"meraker.no",
"merker.no",
"moareke.no",
"moreke.no",
"midsund.no",
"midtre-gauldal.no",
"modalen.no",
"modum.no",
"molde.no",
"moskenes.no",
"moss.no",
"mosvik.no",
"malselv.no",
"mlselv.no",
"malatvuopmi.no",
"mlatvuopmi.no",
"namdalseid.no",
"aejrie.no",
"namsos.no",
"namsskogan.no",
"naamesjevuemie.no",
"nmesjevuemie.no",
"laakesvuemie.no",
"nannestad.no",
"narvik.no",
"narviika.no",
"naustdal.no",
"nedre-eiker.no",
"nes.akershus.no",
"nes.buskerud.no",
"nesna.no",
"nesodden.no",
"nesseby.no",
"unjarga.no",
"unjrga.no",
"nesset.no",
"nissedal.no",
"nittedal.no",
"nord-aurdal.no",
"nord-fron.no",
"nord-odal.no",
"norddal.no",
"nordkapp.no",
"davvenjarga.no",
"davvenjrga.no",
"nordre-land.no",
"nordreisa.no",
"raisa.no",
"risa.no",
"nore-og-uvdal.no",
"notodden.no",
"naroy.no",
"nry.no",
"notteroy.no",
"nttery.no",
"odda.no",
"oksnes.no",
"ksnes.no",
"oppdal.no",
"oppegard.no",
"oppegrd.no",
"orkdal.no",
"orland.no",
"rland.no",
"orskog.no",
"rskog.no",
"orsta.no",
"rsta.no",
"os.hedmark.no",
"os.hordaland.no",
"osen.no",
"osteroy.no",
"ostery.no",
"ostre-toten.no",
"stre-toten.no",
"overhalla.no",
"ovre-eiker.no",
"vre-eiker.no",
"oyer.no",
"yer.no",
"oygarden.no",
"ygarden.no",
"oystre-slidre.no",
"ystre-slidre.no",
"porsanger.no",
"porsangu.no",
"porsgu.no",
"porsgrunn.no",
"radoy.no",
"rady.no",
"rakkestad.no",
"rana.no",
"ruovat.no",
"randaberg.no",
"rauma.no",
"rendalen.no",
"rennebu.no",
"rennesoy.no",
"rennesy.no",
"rindal.no",
"ringebu.no",
"ringerike.no",
"ringsaker.no",
"rissa.no",
"risor.no",
"risr.no",
"roan.no",
"rollag.no",
"rygge.no",
"ralingen.no",
"rlingen.no",
"rodoy.no",
"rdy.no",
"romskog.no",
"rmskog.no",
"roros.no",
"rros.no",
"rost.no",
"rst.no",
"royken.no",
"ryken.no",
"royrvik.no",
"ryrvik.no",
"rade.no",
"rde.no",
"salangen.no",
"siellak.no",
"saltdal.no",
"salat.no",
"slt.no",
"slat.no",
"samnanger.no",
"sande.more-og-romsdal.no",
"sande.mre-og-romsdal.no",
"sande.vestfold.no",
"sandefjord.no",
"sandnes.no",
"sandoy.no",
"sandy.no",
"sarpsborg.no",
"sauda.no",
"sauherad.no",
"sel.no",
"selbu.no",
"selje.no",
"seljord.no",
"sigdal.no",
"siljan.no",
"sirdal.no",
"skaun.no",
"skedsmo.no",
"ski.no",
"skien.no",
"skiptvet.no",
"skjervoy.no",
"skjervy.no",
"skierva.no",
"skierv.no",
"skjak.no",
"skjk.no",
"skodje.no",
"skanland.no",
"sknland.no",
"skanit.no",
"sknit.no",
"smola.no",
"smla.no",
"snillfjord.no",
"snasa.no",
"snsa.no",
"snoasa.no",
"snaase.no",
"snase.no",
"sogndal.no",
"sokndal.no",
"sola.no",
"solund.no",
"songdalen.no",
"sortland.no",
"spydeberg.no",
"stange.no",
"stavanger.no",
"steigen.no",
"steinkjer.no",
"stjordal.no",
"stjrdal.no",
"stokke.no",
"stor-elvdal.no",
"stord.no",
"stordal.no",
"storfjord.no",
"omasvuotna.no",
"strand.no",
"stranda.no",
"stryn.no",
"sula.no",
"suldal.no",
"sund.no",
"sunndal.no",
"surnadal.no",
"sveio.no",
"svelvik.no",
"sykkylven.no",
"sogne.no",
"sgne.no",
"somna.no",
"smna.no",
"sondre-land.no",
"sndre-land.no",
"sor-aurdal.no",
"sr-aurdal.no",
"sor-fron.no",
"sr-fron.no",
"sor-odal.no",
"sr-odal.no",
"sor-varanger.no",
"sr-varanger.no",
"matta-varjjat.no",
"mtta-vrjjat.no",
"sorfold.no",
"srfold.no",
"sorreisa.no",
"srreisa.no",
"sorum.no",
"srum.no",
"tana.no",
"deatnu.no",
"time.no",
"tingvoll.no",
"tinn.no",
"tjeldsund.no",
"dielddanuorri.no",
"tjome.no",
"tjme.no",
"tokke.no",
"tolga.no",
"torsken.no",
"tranoy.no",
"trany.no",
"tromso.no",
"troms.no",
"tromsa.no",
"romsa.no",
"trondheim.no",
"troandin.no",
"trysil.no",
"trana.no",
"trna.no",
"trogstad.no",
"trgstad.no",
"tvedestrand.no",
"tydal.no",
"tynset.no",
"tysfjord.no",
"divtasvuodna.no",
"divttasvuotna.no",
"tysnes.no",
"tysvar.no",
"tysvr.no",
"tonsberg.no",
"tnsberg.no",
"ullensaker.no",
"ullensvang.no",
"ulvik.no",
"utsira.no",
"vadso.no",
"vads.no",
"cahcesuolo.no",
"hcesuolo.no",
"vaksdal.no",
"valle.no",
"vang.no",
"vanylven.no",
"vardo.no",
"vard.no",
"varggat.no",
"vrggt.no",
"vefsn.no",
"vaapste.no",
"vega.no",
"vegarshei.no",
"vegrshei.no",
"vennesla.no",
"verdal.no",
"verran.no",
"vestby.no",
"vestnes.no",
"vestre-slidre.no",
"vestre-toten.no",
"vestvagoy.no",
"vestvgy.no",
"vevelstad.no",
"vik.no",
"vikna.no",
"vindafjord.no",
"volda.no",
"voss.no",
"varoy.no",
"vry.no",
"vagan.no",
"vgan.no",
"voagat.no",
"vagsoy.no",
"vgsy.no",
"vaga.no",
"vg.no",
"valer.ostfold.no",
"vler.stfold.no",
"valer.hedmark.no",
"vler.hedmark.no",
"*.np",
"nr",
"biz.nr",
"info.nr",
"gov.nr",
"edu.nr",
"org.nr",
"net.nr",
"com.nr",
"nu",
"nz",
"ac.nz",
"co.nz",
"cri.nz",
"geek.nz",
"gen.nz",
"govt.nz",
"health.nz",
"iwi.nz",
"kiwi.nz",
"maori.nz",
"mil.nz",
"mori.nz",
"net.nz",
"org.nz",
"parliament.nz",
"school.nz",
"om",
"co.om",
"com.om",
"edu.om",
"gov.om",
"med.om",
"museum.om",
"net.om",
"org.om",
"pro.om",
"onion",
"org",
"pa",
"ac.pa",
"gob.pa",
"com.pa",
"org.pa",
"sld.pa",
"edu.pa",
"net.pa",
"ing.pa",
"abo.pa",
"med.pa",
"nom.pa",
"pe",
"edu.pe",
"gob.pe",
"nom.pe",
"mil.pe",
"org.pe",
"com.pe",
"net.pe",
"pf",
"com.pf",
"org.pf",
"edu.pf",
"*.pg",
"ph",
"com.ph",
"net.ph",
"org.ph",
"gov.ph",
"edu.ph",
"ngo.ph",
"mil.ph",
"i.ph",
"pk",
"com.pk",
"net.pk",
"edu.pk",
"org.pk",
"fam.pk",
"biz.pk",
"web.pk",
"gov.pk",
"gob.pk",
"gok.pk",
"gon.pk",
"gop.pk",
"gos.pk",
"info.pk",
"pl",
"com.pl",
"net.pl",
"org.pl",
"aid.pl",
"agro.pl",
"atm.pl",
"auto.pl",
"biz.pl",
"edu.pl",
"gmina.pl",
"gsm.pl",
"info.pl",
"mail.pl",
"miasta.pl",
"media.pl",
"mil.pl",
"nieruchomosci.pl",
"nom.pl",
"pc.pl",
"powiat.pl",
"priv.pl",
"realestate.pl",
"rel.pl",
"sex.pl",
"shop.pl",
"sklep.pl",
"sos.pl",
"szkola.pl",
"targi.pl",
"tm.pl",
"tourism.pl",
"travel.pl",
"turystyka.pl",
"gov.pl",
"ap.gov.pl",
"ic.gov.pl",
"is.gov.pl",
"us.gov.pl",
"kmpsp.gov.pl",
"kppsp.gov.pl",
"kwpsp.gov.pl",
"psp.gov.pl",
"wskr.gov.pl",
"kwp.gov.pl",
"mw.gov.pl",
"ug.gov.pl",
"um.gov.pl",
"umig.gov.pl",
"ugim.gov.pl",
"upow.gov.pl",
"uw.gov.pl",
"starostwo.gov.pl",
"pa.gov.pl",
"po.gov.pl",
"psse.gov.pl",
"pup.gov.pl",
"rzgw.gov.pl",
"sa.gov.pl",
"so.gov.pl",
"sr.gov.pl",
"wsa.gov.pl",
"sko.gov.pl",
"uzs.gov.pl",
"wiih.gov.pl",
"winb.gov.pl",
"pinb.gov.pl",
"wios.gov.pl",
"witd.gov.pl",
"wzmiuw.gov.pl",
"piw.gov.pl",
"wiw.gov.pl",
"griw.gov.pl",
"wif.gov.pl",
"oum.gov.pl",
"sdn.gov.pl",
"zp.gov.pl",
"uppo.gov.pl",
"mup.gov.pl",
"wuoz.gov.pl",
"konsulat.gov.pl",
"oirm.gov.pl",
"augustow.pl",
"babia-gora.pl",
"bedzin.pl",
"beskidy.pl",
"bialowieza.pl",
"bialystok.pl",
"bielawa.pl",
"bieszczady.pl",
"boleslawiec.pl",
"bydgoszcz.pl",
"bytom.pl",
"cieszyn.pl",
"czeladz.pl",
"czest.pl",
"dlugoleka.pl",
"elblag.pl",
"elk.pl",
"glogow.pl",
"gniezno.pl",
"gorlice.pl",
"grajewo.pl",
"ilawa.pl",
"jaworzno.pl",
"jelenia-gora.pl",
"jgora.pl",
"kalisz.pl",
"kazimierz-dolny.pl",
"karpacz.pl",
"kartuzy.pl",
"kaszuby.pl",
"katowice.pl",
"kepno.pl",
"ketrzyn.pl",
"klodzko.pl",
"kobierzyce.pl",
"kolobrzeg.pl",
"konin.pl",
"konskowola.pl",
"kutno.pl",
"lapy.pl",
"lebork.pl",
"legnica.pl",
"lezajsk.pl",
"limanowa.pl",
"lomza.pl",
"lowicz.pl",
"lubin.pl",
"lukow.pl",
"malbork.pl",
"malopolska.pl",
"mazowsze.pl",
"mazury.pl",
"mielec.pl",
"mielno.pl",
"mragowo.pl",
"naklo.pl",
"nowaruda.pl",
"nysa.pl",
"olawa.pl",
"olecko.pl",
"olkusz.pl",
"olsztyn.pl",
"opoczno.pl",
"opole.pl",
"ostroda.pl",
"ostroleka.pl",
"ostrowiec.pl",
"ostrowwlkp.pl",
"pila.pl",
"pisz.pl",
"podhale.pl",
"podlasie.pl",
"polkowice.pl",
"pomorze.pl",
"pomorskie.pl",
"prochowice.pl",
"pruszkow.pl",
"przeworsk.pl",
"pulawy.pl",
"radom.pl",
"rawa-maz.pl",
"rybnik.pl",
"rzeszow.pl",
"sanok.pl",
"sejny.pl",
"slask.pl",
"slupsk.pl",
"sosnowiec.pl",
"stalowa-wola.pl",
"skoczow.pl",
"starachowice.pl",
"stargard.pl",
"suwalki.pl",
"swidnica.pl",
"swiebodzin.pl",
"swinoujscie.pl",
"szczecin.pl",
"szczytno.pl",
"tarnobrzeg.pl",
"tgory.pl",
"turek.pl",
"tychy.pl",
"ustka.pl",
"walbrzych.pl",
"warmia.pl",
"warszawa.pl",
"waw.pl",
"wegrow.pl",
"wielun.pl",
"wlocl.pl",
"wloclawek.pl",
"wodzislaw.pl",
"wolomin.pl",
"wroclaw.pl",
"zachpomor.pl",
"zagan.pl",
"zarow.pl",
"zgora.pl",
"zgorzelec.pl",
"pm",
"pn",
"gov.pn",
"co.pn",
"org.pn",
"edu.pn",
"net.pn",
"post",
"pr",
"com.pr",
"net.pr",
"org.pr",
"gov.pr",
"edu.pr",
"isla.pr",
"pro.pr",
"biz.pr",
"info.pr",
"name.pr",
"est.pr",
"prof.pr",
"ac.pr",
"pro",
"aaa.pro",
"aca.pro",
"acct.pro",
"avocat.pro",
"bar.pro",
"cpa.pro",
"eng.pro",
"jur.pro",
"law.pro",
"med.pro",
"recht.pro",
"ps",
"edu.ps",
"gov.ps",
"sec.ps",
"plo.ps",
"com.ps",
"org.ps",
"net.ps",
"pt",
"net.pt",
"gov.pt",
"org.pt",
"edu.pt",
"int.pt",
"publ.pt",
"com.pt",
"nome.pt",
"pw",
"co.pw",
"ne.pw",
"or.pw",
"ed.pw",
"go.pw",
"belau.pw",
"py",
"com.py",
"coop.py",
"edu.py",
"gov.py",
"mil.py",
"net.py",
"org.py",
"qa",
"com.qa",
"edu.qa",
"gov.qa",
"mil.qa",
"name.qa",
"net.qa",
"org.qa",
"sch.qa",
"re",
"asso.re",
"com.re",
"nom.re",
"ro",
"arts.ro",
"com.ro",
"firm.ro",
"info.ro",
"nom.ro",
"nt.ro",
"org.ro",
"rec.ro",
"store.ro",
"tm.ro",
"www.ro",
"rs",
"ac.rs",
"co.rs",
"edu.rs",
"gov.rs",
"in.rs",
"org.rs",
"ru",
"rw",
"ac.rw",
"co.rw",
"coop.rw",
"gov.rw",
"mil.rw",
"net.rw",
"org.rw",
"sa",
"com.sa",
"net.sa",
"org.sa",
"gov.sa",
"med.sa",
"pub.sa",
"edu.sa",
"sch.sa",
"sb",
"com.sb",
"edu.sb",
"gov.sb",
"net.sb",
"org.sb",
"sc",
"com.sc",
"gov.sc",
"net.sc",
"org.sc",
"edu.sc",
"sd",
"com.sd",
"net.sd",
"org.sd",
"edu.sd",
"med.sd",
"tv.sd",
"gov.sd",
"info.sd",
"se",
"a.se",
"ac.se",
"b.se",
"bd.se",
"brand.se",
"c.se",
"d.se",
"e.se",
"f.se",
"fh.se",
"fhsk.se",
"fhv.se",
"g.se",
"h.se",
"i.se",
"k.se",
"komforb.se",
"kommunalforbund.se",
"komvux.se",
"l.se",
"lanbib.se",
"m.se",
"n.se",
"naturbruksgymn.se",
"o.se",
"org.se",
"p.se",
"parti.se",
"pp.se",
"press.se",
"r.se",
"s.se",
"t.se",
"tm.se",
"u.se",
"w.se",
"x.se",
"y.se",
"z.se",
"sg",
"com.sg",
"net.sg",
"org.sg",
"gov.sg",
"edu.sg",
"per.sg",
"sh",
"com.sh",
"net.sh",
"gov.sh",
"org.sh",
"mil.sh",
"si",
"sj",
"sk",
"sl",
"com.sl",
"net.sl",
"edu.sl",
"gov.sl",
"org.sl",
"sm",
"sn",
"art.sn",
"com.sn",
"edu.sn",
"gouv.sn",
"org.sn",
"perso.sn",
"univ.sn",
"so",
"com.so",
"edu.so",
"gov.so",
"me.so",
"net.so",
"org.so",
"sr",
"ss",
"biz.ss",
"com.ss",
"edu.ss",
"gov.ss",
"me.ss",
"net.ss",
"org.ss",
"sch.ss",
"st",
"co.st",
"com.st",
"consulado.st",
"edu.st",
"embaixada.st",
"mil.st",
"net.st",
"org.st",
"principe.st",
"saotome.st",
"store.st",
"su",
"sv",
"com.sv",
"edu.sv",
"gob.sv",
"org.sv",
"red.sv",
"sx",
"gov.sx",
"sy",
"edu.sy",
"gov.sy",
"net.sy",
"mil.sy",
"com.sy",
"org.sy",
"sz",
"co.sz",
"ac.sz",
"org.sz",
"tc",
"td",
"tel",
"tf",
"tg",
"th",
"ac.th",
"co.th",
"go.th",
"in.th",
"mi.th",
"net.th",
"or.th",
"tj",
"ac.tj",
"biz.tj",
"co.tj",
"com.tj",
"edu.tj",
"go.tj",
"gov.tj",
"int.tj",
"mil.tj",
"name.tj",
"net.tj",
"nic.tj",
"org.tj",
"test.tj",
"web.tj",
"tk",
"tl",
"gov.tl",
"tm",
"com.tm",
"co.tm",
"org.tm",
"net.tm",
"nom.tm",
"gov.tm",
"mil.tm",
"edu.tm",
"tn",
"com.tn",
"ens.tn",
"fin.tn",
"gov.tn",
"ind.tn",
"info.tn",
"intl.tn",
"mincom.tn",
"nat.tn",
"net.tn",
"org.tn",
"perso.tn",
"tourism.tn",
"to",
"com.to",
"gov.to",
"net.to",
"org.to",
"edu.to",
"mil.to",
"tr",
"av.tr",
"bbs.tr",
"bel.tr",
"biz.tr",
"com.tr",
"dr.tr",
"edu.tr",
"gen.tr",
"gov.tr",
"info.tr",
"mil.tr",
"k12.tr",
"kep.tr",
"name.tr",
"net.tr",
"org.tr",
"pol.tr",
"tel.tr",
"tsk.tr",
"tv.tr",
"web.tr",
"nc.tr",
"gov.nc.tr",
"tt",
"co.tt",
"com.tt",
"org.tt",
"net.tt",
"biz.tt",
"info.tt",
"pro.tt",
"int.tt",
"coop.tt",
"jobs.tt",
"mobi.tt",
"travel.tt",
"museum.tt",
"aero.tt",
"name.tt",
"gov.tt",
"edu.tt",
"tv",
"tw",
"edu.tw",
"gov.tw",
"mil.tw",
"com.tw",
"net.tw",
"org.tw",
"idv.tw",
"game.tw",
"ebiz.tw",
"club.tw",
".tw",
".tw",
".tw",
"tz",
"ac.tz",
"co.tz",
"go.tz",
"hotel.tz",
"info.tz",
"me.tz",
"mil.tz",
"mobi.tz",
"ne.tz",
"or.tz",
"sc.tz",
"tv.tz",
"ua",
"com.ua",
"edu.ua",
"gov.ua",
"in.ua",
"net.ua",
"org.ua",
"cherkassy.ua",
"cherkasy.ua",
"chernigov.ua",
"chernihiv.ua",
"chernivtsi.ua",
"chernovtsy.ua",
"ck.ua",
"cn.ua",
"cr.ua",
"crimea.ua",
"cv.ua",
"dn.ua",
"dnepropetrovsk.ua",
"dnipropetrovsk.ua",
"donetsk.ua",
"dp.ua",
"if.ua",
"ivano-frankivsk.ua",
"kh.ua",
"kharkiv.ua",
"kharkov.ua",
"kherson.ua",
"khmelnitskiy.ua",
"khmelnytskyi.ua",
"kiev.ua",
"kirovograd.ua",
"km.ua",
"kr.ua",
"krym.ua",
"ks.ua",
"kv.ua",
"kyiv.ua",
"lg.ua",
"lt.ua",
"lugansk.ua",
"lutsk.ua",
"lv.ua",
"lviv.ua",
"mk.ua",
"mykolaiv.ua",
"nikolaev.ua",
"od.ua",
"odesa.ua",
"odessa.ua",
"pl.ua",
"poltava.ua",
"rivne.ua",
"rovno.ua",
"rv.ua",
"sb.ua",
"sebastopol.ua",
"sevastopol.ua",
"sm.ua",
"sumy.ua",
"te.ua",
"ternopil.ua",
"uz.ua",
"uzhgorod.ua",
"vinnica.ua",
"vinnytsia.ua",
"vn.ua",
"volyn.ua",
"yalta.ua",
"zaporizhzhe.ua",
"zaporizhzhia.ua",
"zhitomir.ua",
"zhytomyr.ua",
"zp.ua",
"zt.ua",
"ug",
"co.ug",
"or.ug",
"ac.ug",
"sc.ug",
"go.ug",
"ne.ug",
"com.ug",
"org.ug",
"uk",
"ac.uk",
"co.uk",
"gov.uk",
"ltd.uk",
"me.uk",
"net.uk",
"nhs.uk",
"org.uk",
"plc.uk",
"police.uk",
"*.sch.uk",
"us",
"dni.us",
"fed.us",
"isa.us",
"kids.us",
"nsn.us",
"ak.us",
"al.us",
"ar.us",
"as.us",
"az.us",
"ca.us",
"co.us",
"ct.us",
"dc.us",
"de.us",
"fl.us",
"ga.us",
"gu.us",
"hi.us",
"ia.us",
"id.us",
"il.us",
"in.us",
"ks.us",
"ky.us",
"la.us",
"ma.us",
"md.us",
"me.us",
"mi.us",
"mn.us",
"mo.us",
"ms.us",
"mt.us",
"nc.us",
"nd.us",
"ne.us",
"nh.us",
"nj.us",
"nm.us",
"nv.us",
"ny.us",
"oh.us",
"ok.us",
"or.us",
"pa.us",
"pr.us",
"ri.us",
"sc.us",
"sd.us",
"tn.us",
"tx.us",
"ut.us",
"vi.us",
"vt.us",
"va.us",
"wa.us",
"wi.us",
"wv.us",
"wy.us",
"k12.ak.us",
"k12.al.us",
"k12.ar.us",
"k12.as.us",
"k12.az.us",
"k12.ca.us",
"k12.co.us",
"k12.ct.us",
"k12.dc.us",
"k12.de.us",
"k12.fl.us",
"k12.ga.us",
"k12.gu.us",
"k12.ia.us",
"k12.id.us",
"k12.il.us",
"k12.in.us",
"k12.ks.us",
"k12.ky.us",
"k12.la.us",
"k12.ma.us",
"k12.md.us",
"k12.me.us",
"k12.mi.us",
"k12.mn.us",
"k12.mo.us",
"k12.ms.us",
"k12.mt.us",
"k12.nc.us",
"k12.ne.us",
"k12.nh.us",
"k12.nj.us",
"k12.nm.us",
"k12.nv.us",
"k12.ny.us",
"k12.oh.us",
"k12.ok.us",
"k12.or.us",
"k12.pa.us",
"k12.pr.us",
"k12.sc.us",
"k12.tn.us",
"k12.tx.us",
"k12.ut.us",
"k12.vi.us",
"k12.vt.us",
"k12.va.us",
"k12.wa.us",
"k12.wi.us",
"k12.wy.us",
"cc.ak.us",
"cc.al.us",
"cc.ar.us",
"cc.as.us",
"cc.az.us",
"cc.ca.us",
"cc.co.us",
"cc.ct.us",
"cc.dc.us",
"cc.de.us",
"cc.fl.us",
"cc.ga.us",
"cc.gu.us",
"cc.hi.us",
"cc.ia.us",
"cc.id.us",
"cc.il.us",
"cc.in.us",
"cc.ks.us",
"cc.ky.us",
"cc.la.us",
"cc.ma.us",
"cc.md.us",
"cc.me.us",
"cc.mi.us",
"cc.mn.us",
"cc.mo.us",
"cc.ms.us",
"cc.mt.us",
"cc.nc.us",
"cc.nd.us",
"cc.ne.us",
"cc.nh.us",
"cc.nj.us",
"cc.nm.us",
"cc.nv.us",
"cc.ny.us",
"cc.oh.us",
"cc.ok.us",
"cc.or.us",
"cc.pa.us",
"cc.pr.us",
"cc.ri.us",
"cc.sc.us",
"cc.sd.us",
"cc.tn.us",
"cc.tx.us",
"cc.ut.us",
"cc.vi.us",
"cc.vt.us",
"cc.va.us",
"cc.wa.us",
"cc.wi.us",
"cc.wv.us",
"cc.wy.us",
"lib.ak.us",
"lib.al.us",
"lib.ar.us",
"lib.as.us",
"lib.az.us",
"lib.ca.us",
"lib.co.us",
"lib.ct.us",
"lib.dc.us",
"lib.fl.us",
"lib.ga.us",
"lib.gu.us",
"lib.hi.us",
"lib.ia.us",
"lib.id.us",
"lib.il.us",
"lib.in.us",
"lib.ks.us",
"lib.ky.us",
"lib.la.us",
"lib.ma.us",
"lib.md.us",
"lib.me.us",
"lib.mi.us",
"lib.mn.us",
"lib.mo.us",
"lib.ms.us",
"lib.mt.us",
"lib.nc.us",
"lib.nd.us",
"lib.ne.us",
"lib.nh.us",
"lib.nj.us",
"lib.nm.us",
"lib.nv.us",
"lib.ny.us",
"lib.oh.us",
"lib.ok.us",
"lib.or.us",
"lib.pa.us",
"lib.pr.us",
"lib.ri.us",
"lib.sc.us",
"lib.sd.us",
"lib.tn.us",
"lib.tx.us",
"lib.ut.us",
"lib.vi.us",
"lib.vt.us",
"lib.va.us",
"lib.wa.us",
"lib.wi.us",
"lib.wy.us",
"pvt.k12.ma.us",
"chtr.k12.ma.us",
"paroch.k12.ma.us",
"ann-arbor.mi.us",
"cog.mi.us",
"dst.mi.us",
"eaton.mi.us",
"gen.mi.us",
"mus.mi.us",
"tec.mi.us",
"washtenaw.mi.us",
"uy",
"com.uy",
"edu.uy",
"gub.uy",
"mil.uy",
"net.uy",
"org.uy",
"uz",
"co.uz",
"com.uz",
"net.uz",
"org.uz",
"va",
"vc",
"com.vc",
"net.vc",
"org.vc",
"gov.vc",
"mil.vc",
"edu.vc",
"ve",
"arts.ve",
"bib.ve",
"co.ve",
"com.ve",
"e12.ve",
"edu.ve",
"firm.ve",
"gob.ve",
"gov.ve",
"info.ve",
"int.ve",
"mil.ve",
"net.ve",
"nom.ve",
"org.ve",
"rar.ve",
"rec.ve",
"store.ve",
"tec.ve",
"web.ve",
"vg",
"vi",
"co.vi",
"com.vi",
"k12.vi",
"net.vi",
"org.vi",
"vn",
"com.vn",
"net.vn",
"org.vn",
"edu.vn",
"gov.vn",
"int.vn",
"ac.vn",
"biz.vn",
"info.vn",
"name.vn",
"pro.vn",
"health.vn",
"vu",
"com.vu",
"edu.vu",
"net.vu",
"org.vu",
"wf",
"ws",
"com.ws",
"net.ws",
"org.ws",
"gov.ws",
"edu.ws",
"yt",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
".",
".",
".",
".",
".",
".",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
".",
".",
".",
".",
".",
".",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
".",
".",
".",
".",
".",
".",
"",
"",
"",
"",
"",
"",
"xxx",
"ye",
"com.ye",
"edu.ye",
"gov.ye",
"net.ye",
"mil.ye",
"org.ye",
"ac.za",
"agric.za",
"alt.za",
"co.za",
"edu.za",
"gov.za",
"grondar.za",
"law.za",
"mil.za",
"net.za",
"ngo.za",
"nic.za",
"nis.za",
"nom.za",
"org.za",
"school.za",
"tm.za",
"web.za",
"zm",
"ac.zm",
"biz.zm",
"co.zm",
"com.zm",
"edu.zm",
"gov.zm",
"info.zm",
"mil.zm",
"net.zm",
"org.zm",
"sch.zm",
"zw",
"ac.zw",
"co.zw",
"gov.zw",
"mil.zw",
"org.zw",
"aaa",
"aarp",
"abarth",
"abb",
"abbott",
"abbvie",
"abc",
"able",
"abogado",
"abudhabi",
"academy",
"accenture",
"accountant",
"accountants",
"aco",
"actor",
"adac",
"ads",
"adult",
"aeg",
"aetna",
"afl",
"africa",
"agakhan",
"agency",
"aig",
"airbus",
"airforce",
"airtel",
"akdn",
"alfaromeo",
"alibaba",
"alipay",
"allfinanz",
"allstate",
"ally",
"alsace",
"alstom",
"amazon",
"americanexpress",
"americanfamily",
"amex",
"amfam",
"amica",
"amsterdam",
"analytics",
"android",
"anquan",
"anz",
"aol",
"apartments",
"app",
"apple",
"aquarelle",
"arab",
"aramco",
"archi",
"army",
"art",
"arte",
"asda",
"associates",
"athleta",
"attorney",
"auction",
"audi",
"audible",
"audio",
"auspost",
"author",
"auto",
"autos",
"avianca",
"aws",
"axa",
"azure",
"baby",
"baidu",
"banamex",
"bananarepublic",
"band",
"bank",
"bar",
"barcelona",
"barclaycard",
"barclays",
"barefoot",
"bargains",
"baseball",
"basketball",
"bauhaus",
"bayern",
"bbc",
"bbt",
"bbva",
"bcg",
"bcn",
"beats",
"beauty",
"beer",
"bentley",
"berlin",
"best",
"bestbuy",
"bet",
"bharti",
"bible",
"bid",
"bike",
"bing",
"bingo",
"bio",
"black",
"blackfriday",
"blockbuster",
"blog",
"bloomberg",
"blue",
"bms",
"bmw",
"bnpparibas",
"boats",
"boehringer",
"bofa",
"bom",
"bond",
"boo",
"book",
"booking",
"bosch",
"bostik",
"boston",
"bot",
"boutique",
"box",
"bradesco",
"bridgestone",
"broadway",
"broker",
"brother",
"brussels",
"bugatti",
"build",
"builders",
"business",
"buy",
"buzz",
"bzh",
"cab",
"cafe",
"cal",
"call",
"calvinklein",
"cam",
"camera",
"camp",
"cancerresearch",
"canon",
"capetown",
"capital",
"capitalone",
"car",
"caravan",
"cards",
"care",
"career",
"careers",
"cars",
"casa",
"case",
"cash",
"casino",
"catering",
"catholic",
"cba",
"cbn",
"cbre",
"cbs",
"center",
"ceo",
"cern",
"cfa",
"cfd",
"chanel",
"channel",
"charity",
"chase",
"chat",
"cheap",
"chintai",
"christmas",
"chrome",
"church",
"cipriani",
"circle",
"cisco",
"citadel",
"citi",
"citic",
"city",
"cityeats",
"claims",
"cleaning",
"click",
"clinic",
"clinique",
"clothing",
"cloud",
"club",
"clubmed",
"coach",
"codes",
"coffee",
"college",
"cologne",
"comcast",
"commbank",
"community",
"company",
"compare",
"computer",
"comsec",
"condos",
"construction",
"consulting",
"contact",
"contractors",
"cooking",
"cookingchannel",
"cool",
"corsica",
"country",
"coupon",
"coupons",
"courses",
"cpa",
"credit",
"creditcard",
"creditunion",
"cricket",
"crown",
"crs",
"cruise",
"cruises",
"cuisinella",
"cymru",
"cyou",
"dabur",
"dad",
"dance",
"data",
"date",
"dating",
"datsun",
"day",
"dclk",
"dds",
"deal",
"dealer",
"deals",
"degree",
"delivery",
"dell",
"deloitte",
"delta",
"democrat",
"dental",
"dentist",
"desi",
"design",
"dev",
"dhl",
"diamonds",
"diet",
"digital",
"direct",
"directory",
"discount",
"discover",
"dish",
"diy",
"dnp",
"docs",
"doctor",
"dog",
"domains",
"dot",
"download",
"drive",
"dtv",
"dubai",
"dunlop",
"dupont",
"durban",
"dvag",
"dvr",
"earth",
"eat",
"eco",
"edeka",
"education",
"email",
"emerck",
"energy",
"engineer",
"engineering",
"enterprises",
"epson",
"equipment",
"ericsson",
"erni",
"esq",
"estate",
"etisalat",
"eurovision",
"eus",
"events",
"exchange",
"expert",
"exposed",
"express",
"extraspace",
"fage",
"fail",
"fairwinds",
"faith",
"family",
"fan",
"fans",
"farm",
"farmers",
"fashion",
"fast",
"fedex",
"feedback",
"ferrari",
"ferrero",
"fiat",
"fidelity",
"fido",
"film",
"final",
"finance",
"financial",
"fire",
"firestone",
"firmdale",
"fish",
"fishing",
"fit",
"fitness",
"flickr",
"flights",
"flir",
"florist",
"flowers",
"fly",
"foo",
"food",
"foodnetwork",
"football",
"ford",
"forex",
"forsale",
"forum",
"foundation",
"fox",
"free",
"fresenius",
"frl",
"frogans",
"frontdoor",
"frontier",
"ftr",
"fujitsu",
"fun",
"fund",
"furniture",
"futbol",
"fyi",
"gal",
"gallery",
"gallo",
"gallup",
"game",
"games",
"gap",
"garden",
"gay",
"gbiz",
"gdn",
"gea",
"gent",
"genting",
"george",
"ggee",
"gift",
"gifts",
"gives",
"giving",
"glass",
"gle",
"global",
"globo",
"gmail",
"gmbh",
"gmo",
"gmx",
"godaddy",
"gold",
"goldpoint",
"golf",
"goo",
"goodyear",
"goog",
"google",
"gop",
"got",
"grainger",
"graphics",
"gratis",
"green",
"gripe",
"grocery",
"group",
"guardian",
"gucci",
"guge",
"guide",
"guitars",
"guru",
"hair",
"hamburg",
"hangout",
"haus",
"hbo",
"hdfc",
"hdfcbank",
"health",
"healthcare",
"help",
"helsinki",
"here",
"hermes",
"hgtv",
"hiphop",
"hisamitsu",
"hitachi",
"hiv",
"hkt",
"hockey",
"holdings",
"holiday",
"homedepot",
"homegoods",
"homes",
"homesense",
"honda",
"horse",
"hospital",
"host",
"hosting",
"hot",
"hoteles",
"hotels",
"hotmail",
"house",
"how",
"hsbc",
"hughes",
"hyatt",
"hyundai",
"ibm",
"icbc",
"ice",
"icu",
"ieee",
"ifm",
"ikano",
"imamat",
"imdb",
"immo",
"immobilien",
"inc",
"industries",
"infiniti",
"ing",
"ink",
"institute",
"insurance",
"insure",
"international",
"intuit",
"investments",
"ipiranga",
"irish",
"ismaili",
"ist",
"istanbul",
"itau",
"itv",
"jaguar",
"java",
"jcb",
"jeep",
"jetzt",
"jewelry",
"jio",
"jll",
"jmp",
"jnj",
"joburg",
"jot",
"joy",
"jpmorgan",
"jprs",
"juegos",
"juniper",
"kaufen",
"kddi",
"kerryhotels",
"kerrylogistics",
"kerryproperties",
"kfh",
"kia",
"kids",
"kim",
"kinder",
"kindle",
"kitchen",
"kiwi",
"koeln",
"komatsu",
"kosher",
"kpmg",
"kpn",
"krd",
"kred",
"kuokgroup",
"kyoto",
"lacaixa",
"lamborghini",
"lamer",
"lancaster",
"lancia",
"land",
"landrover",
"lanxess",
"lasalle",
"lat",
"latino",
"latrobe",
"law",
"lawyer",
"lds",
"lease",
"leclerc",
"lefrak",
"legal",
"lego",
"lexus",
"lgbt",
"lidl",
"life",
"lifeinsurance",
"lifestyle",
"lighting",
"like",
"lilly",
"limited",
"limo",
"lincoln",
"linde",
"link",
"lipsy",
"live",
"living",
"llc",
"llp",
"loan",
"loans",
"locker",
"locus",
"loft",
"lol",
"london",
"lotte",
"lotto",
"love",
"lpl",
"lplfinancial",
"ltd",
"ltda",
"lundbeck",
"luxe",
"luxury",
"macys",
"madrid",
"maif",
"maison",
"makeup",
"man",
"management",
"mango",
"map",
"market",
"marketing",
"markets",
"marriott",
"marshalls",
"maserati",
"mattel",
"mba",
"mckinsey",
"med",
"media",
"meet",
"melbourne",
"meme",
"memorial",
"men",
"menu",
"merckmsd",
"miami",
"microsoft",
"mini",
"mint",
"mit",
"mitsubishi",
"mlb",
"mls",
"mma",
"mobile",
"moda",
"moe",
"moi",
"mom",
"monash",
"money",
"monster",
"mormon",
"mortgage",
"moscow",
"moto",
"motorcycles",
"mov",
"movie",
"msd",
"mtn",
"mtr",
"music",
"mutual",
"nab",
"nagoya",
"natura",
"navy",
"nba",
"nec",
"netbank",
"netflix",
"network",
"neustar",
"new",
"news",
"next",
"nextdirect",
"nexus",
"nfl",
"ngo",
"nhk",
"nico",
"nike",
"nikon",
"ninja",
"nissan",
"nissay",
"nokia",
"northwesternmutual",
"norton",
"now",
"nowruz",
"nowtv",
"nra",
"nrw",
"ntt",
"nyc",
"obi",
"observer",
"office",
"okinawa",
"olayan",
"olayangroup",
"oldnavy",
"ollo",
"omega",
"one",
"ong",
"onl",
"online",
"ooo",
"open",
"oracle",
"orange",
"organic",
"origins",
"osaka",
"otsuka",
"ott",
"ovh",
"page",
"panasonic",
"paris",
"pars",
"partners",
"parts",
"party",
"passagens",
"pay",
"pccw",
"pet",
"pfizer",
"pharmacy",
"phd",
"philips",
"phone",
"photo",
"photography",
"photos",
"physio",
"pics",
"pictet",
"pictures",
"pid",
"pin",
"ping",
"pink",
"pioneer",
"pizza",
"place",
"play",
"playstation",
"plumbing",
"plus",
"pnc",
"pohl",
"poker",
"politie",
"porn",
"pramerica",
"praxi",
"press",
"prime",
"prod",
"productions",
"prof",
"progressive",
"promo",
"properties",
"property",
"protection",
"pru",
"prudential",
"pub",
"pwc",
"qpon",
"quebec",
"quest",
"racing",
"radio",
"read",
"realestate",
"realtor",
"realty",
"recipes",
"red",
"redstone",
"redumbrella",
"rehab",
"reise",
"reisen",
"reit",
"reliance",
"ren",
"rent",
"rentals",
"repair",
"report",
"republican",
"rest",
"restaurant",
"review",
"reviews",
"rexroth",
"rich",
"richardli",
"ricoh",
"ril",
"rio",
"rip",
"rocher",
"rocks",
"rodeo",
"rogers",
"room",
"rsvp",
"rugby",
"ruhr",
"run",
"rwe",
"ryukyu",
"saarland",
"safe",
"safety",
"sakura",
"sale",
"salon",
"samsclub",
"samsung",
"sandvik",
"sandvikcoromant",
"sanofi",
"sap",
"sarl",
"sas",
"save",
"saxo",
"sbi",
"sbs",
"sca",
"scb",
"schaeffler",
"schmidt",
"scholarships",
"school",
"schule",
"schwarz",
"science",
"scot",
"search",
"seat",
"secure",
"security",
"seek",
"select",
"sener",
"services",
"ses",
"seven",
"sew",
"sex",
"sexy",
"sfr",
"shangrila",
"sharp",
"shaw",
"shell",
"shia",
"shiksha",
"shoes",
"shop",
"shopping",
"shouji",
"show",
"showtime",
"silk",
"sina",
"singles",
"site",
"ski",
"skin",
"sky",
"skype",
"sling",
"smart",
"smile",
"sncf",
"soccer",
"social",
"softbank",
"software",
"sohu",
"solar",
"solutions",
"song",
"sony",
"soy",
"spa",
"space",
"sport",
"spot",
"srl",
"stada",
"staples",
"star",
"statebank",
"statefarm",
"stc",
"stcgroup",
"stockholm",
"storage",
"store",
"stream",
"studio",
"study",
"style",
"sucks",
"supplies",
"supply",
"support",
"surf",
"surgery",
"suzuki",
"swatch",
"swiss",
"sydney",
"systems",
"tab",
"taipei",
"talk",
"taobao",
"target",
"tatamotors",
"tatar",
"tattoo",
"tax",
"taxi",
"tci",
"tdk",
"team",
"tech",
"technology",
"temasek",
"tennis",
"teva",
"thd",
"theater",
"theatre",
"tiaa",
"tickets",
"tienda",
"tiffany",
"tips",
"tires",
"tirol",
"tjmaxx",
"tjx",
"tkmaxx",
"tmall",
"today",
"tokyo",
"tools",
"top",
"toray",
"toshiba",
"total",
"tours",
"town",
"toyota",
"toys",
"trade",
"trading",
"training",
"travel",
"travelchannel",
"travelers",
"travelersinsurance",
"trust",
"trv",
"tube",
"tui",
"tunes",
"tushu",
"tvs",
"ubank",
"ubs",
"unicom",
"university",
"uno",
"uol",
"ups",
"vacations",
"vana",
"vanguard",
"vegas",
"ventures",
"verisign",
"versicherung",
"vet",
"viajes",
"video",
"vig",
"viking",
"villas",
"vin",
"vip",
"virgin",
"visa",
"vision",
"viva",
"vivo",
"vlaanderen",
"vodka",
"volkswagen",
"volvo",
"vote",
"voting",
"voto",
"voyage",
"vuelos",
"wales",
"walmart",
"walter",
"wang",
"wanggou",
"watch",
"watches",
"weather",
"weatherchannel",
"webcam",
"weber",
"website",
"wedding",
"weibo",
"weir",
"whoswho",
"wien",
"wiki",
"williamhill",
"win",
"windows",
"wine",
"winners",
"wme",
"wolterskluwer",
"woodside",
"work",
"works",
"world",
"wow",
"wtc",
"wtf",
"xbox",
"xerox",
"xfinity",
"xihuan",
"xin",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"",
"vermgensberater",
"vermgensberatung",
"",
"",
"",
"",
"",
"",
"xyz",
"yachts",
"yahoo",
"yamaxun",
"yandex",
"yodobashi",
"yoga",
"yokohama",
"you",
"youtube",
"yun",
"zappos",
"zara",
"zero",
"zip",
"zone",
"zuerich",
"cc.ua",
"inf.ua",
"ltd.ua",
"611.to",
"graphox.us",
"*.devcdnaccesso.com",
"adobeaemcloud.com",
"*.dev.adobeaemcloud.com",
"hlx.live",
"adobeaemcloud.net",
"hlx.page",
"hlx3.page",
"beep.pl",
"airkitapps.com",
"airkitapps-au.com",
"airkitapps.eu",
"aivencloud.com",
"barsy.ca",
"*.compute.estate",
"*.alces.network",
"kasserver.com",
"altervista.org",
"alwaysdata.net",
"cloudfront.net",
"*.compute.amazonaws.com",
"*.compute-1.amazonaws.com",
"*.compute.amazonaws.com.cn",
"us-east-1.amazonaws.com",
"cn-north-1.eb.amazonaws.com.cn",
"cn-northwest-1.eb.amazonaws.com.cn",
"elasticbeanstalk.com",
"ap-northeast-1.elasticbeanstalk.com",
"ap-northeast-2.elasticbeanstalk.com",
"ap-northeast-3.elasticbeanstalk.com",
"ap-south-1.elasticbeanstalk.com",
"ap-southeast-1.elasticbeanstalk.com",
"ap-southeast-2.elasticbeanstalk.com",
"ca-central-1.elasticbeanstalk.com",
"eu-central-1.elasticbeanstalk.com",
"eu-west-1.elasticbeanstalk.com",
"eu-west-2.elasticbeanstalk.com",
"eu-west-3.elasticbeanstalk.com",
"sa-east-1.elasticbeanstalk.com",
"us-east-1.elasticbeanstalk.com",
"us-east-2.elasticbeanstalk.com",
"us-gov-west-1.elasticbeanstalk.com",
"us-west-1.elasticbeanstalk.com",
"us-west-2.elasticbeanstalk.com",
"*.elb.amazonaws.com",
"*.elb.amazonaws.com.cn",
"awsglobalaccelerator.com",
"s3.amazonaws.com",
"s3-ap-northeast-1.amazonaws.com",
"s3-ap-northeast-2.amazonaws.com",
"s3-ap-south-1.amazonaws.com",
"s3-ap-southeast-1.amazonaws.com",
"s3-ap-southeast-2.amazonaws.com",
"s3-ca-central-1.amazonaws.com",
"s3-eu-central-1.amazonaws.com",
"s3-eu-west-1.amazonaws.com",
"s3-eu-west-2.amazonaws.com",
"s3-eu-west-3.amazonaws.com",
"s3-external-1.amazonaws.com",
"s3-fips-us-gov-west-1.amazonaws.com",
"s3-sa-east-1.amazonaws.com",
"s3-us-gov-west-1.amazonaws.com",
"s3-us-east-2.amazonaws.com",
"s3-us-west-1.amazonaws.com",
"s3-us-west-2.amazonaws.com",
"s3.ap-northeast-2.amazonaws.com",
"s3.ap-south-1.amazonaws.com",
"s3.cn-north-1.amazonaws.com.cn",
"s3.ca-central-1.amazonaws.com",
"s3.eu-central-1.amazonaws.com",
"s3.eu-west-2.amazonaws.com",
"s3.eu-west-3.amazonaws.com",
"s3.us-east-2.amazonaws.com",
"s3.dualstack.ap-northeast-1.amazonaws.com",
"s3.dualstack.ap-northeast-2.amazonaws.com",
"s3.dualstack.ap-south-1.amazonaws.com",
"s3.dualstack.ap-southeast-1.amazonaws.com",
"s3.dualstack.ap-southeast-2.amazonaws.com",
"s3.dualstack.ca-central-1.amazonaws.com",
"s3.dualstack.eu-central-1.amazonaws.com",
"s3.dualstack.eu-west-1.amazonaws.com",
"s3.dualstack.eu-west-2.amazonaws.com",
"s3.dualstack.eu-west-3.amazonaws.com",
"s3.dualstack.sa-east-1.amazonaws.com",
"s3.dualstack.us-east-1.amazonaws.com",
"s3.dualstack.us-east-2.amazonaws.com",
"s3-website-us-east-1.amazonaws.com",
"s3-website-us-west-1.amazonaws.com",
"s3-website-us-west-2.amazonaws.com",
"s3-website-ap-northeast-1.amazonaws.com",
"s3-website-ap-southeast-1.amazonaws.com",
"s3-website-ap-southeast-2.amazonaws.com",
"s3-website-eu-west-1.amazonaws.com",
"s3-website-sa-east-1.amazonaws.com",
"s3-website.ap-northeast-2.amazonaws.com",
"s3-website.ap-south-1.amazonaws.com",
"s3-website.ca-central-1.amazonaws.com",
"s3-website.eu-central-1.amazonaws.com",
"s3-website.eu-west-2.amazonaws.com",
"s3-website.eu-west-3.amazonaws.com",
"s3-website.us-east-2.amazonaws.com",
"t3l3p0rt.net",
"tele.amune.org",
"apigee.io",
"siiites.com",
"appspacehosted.com",
"appspaceusercontent.com",
"appudo.net",
"on-aptible.com",
"user.aseinet.ne.jp",
"gv.vc",
"d.gv.vc",
"user.party.eus",
"pimienta.org",
"poivron.org",
"potager.org",
"sweetpepper.org",
"myasustor.com",
"cdn.prod.atlassian-dev.net",
"translated.page",
"myfritz.net",
"onavstack.net",
"*.awdev.ca",
"*.advisor.ws",
"ecommerce-shop.pl",
"b-data.io",
"backplaneapp.io",
"balena-devices.com",
"rs.ba",
"*.banzai.cloud",
"app.banzaicloud.io",
"*.backyards.banzaicloud.io",
"base.ec",
"official.ec",
"buyshop.jp",
"fashionstore.jp",
"handcrafted.jp",
"kawaiishop.jp",
"supersale.jp",
"theshop.jp",
"shopselect.net",
"base.shop",
"*.beget.app",
"betainabox.com",
"bnr.la",
"bitbucket.io",
"blackbaudcdn.net",
"of.je",
"bluebite.io",
"boomla.net",
"boutir.com",
"boxfuse.io",
"square7.ch",
"bplaced.com",
"bplaced.de",
"square7.de",
"bplaced.net",
"square7.net",
"shop.brendly.rs",
"browsersafetymark.io",
"uk0.bigv.io",
"dh.bytemark.co.uk",
"vm.bytemark.co.uk",
"cafjs.com",
"mycd.eu",
"drr.ac",
"uwu.ai",
"carrd.co",
"crd.co",
"ju.mp",
"ae.org",
"br.com",
"cn.com",
"com.de",
"com.se",
"de.com",
"eu.com",
"gb.net",
"hu.net",
"jp.net",
"jpn.com",
"mex.com",
"ru.com",
"sa.com",
"se.net",
"uk.com",
"uk.net",
"us.com",
"za.bz",
"za.com",
"ar.com",
"hu.com",
"kr.com",
"no.com",
"qc.com",
"uy.com",
"africa.com",
"gr.com",
"in.net",
"web.in",
"us.org",
"co.com",
"aus.basketball",
"nz.basketball",
"radio.am",
"radio.fm",
"c.la",
"certmgr.org",
"cx.ua",
"discourse.group",
"discourse.team",
"cleverapps.io",
"clerk.app",
"clerkstage.app",
"*.lcl.dev",
"*.lclstage.dev",
"*.stg.dev",
"*.stgstage.dev",
"clickrising.net",
"c66.me",
"cloud66.ws",
"cloud66.zone",
"jdevcloud.com",
"wpdevcloud.com",
"cloudaccess.host",
"freesite.host",
"cloudaccess.net",
"cloudcontrolled.com",
"cloudcontrolapp.com",
"*.cloudera.site",
"pages.dev",
"trycloudflare.com",
"workers.dev",
"wnext.app",
"co.ca",
"*.otap.co",
"co.cz",
"c.cdn77.org",
"cdn77-ssl.net",
"r.cdn77.net",
"rsc.cdn77.org",
"ssl.origin.cdn77-secure.org",
"cloudns.asia",
"cloudns.biz",
"cloudns.club",
"cloudns.cc",
"cloudns.eu",
"cloudns.in",
"cloudns.info",
"cloudns.org",
"cloudns.pro",
"cloudns.pw",
"cloudns.us",
"cnpy.gdn",
"codeberg.page",
"co.nl",
"co.no",
"webhosting.be",
"hosting-cluster.nl",
"ac.ru",
"edu.ru",
"gov.ru",
"int.ru",
"mil.ru",
"test.ru",
"dyn.cosidns.de",
"dynamisches-dns.de",
"dnsupdater.de",
"internet-dns.de",
"l-o-g-i-n.de",
"dynamic-dns.info",
"feste-ip.net",
"knx-server.net",
"static-access.net",
"realm.cz",
"*.cryptonomic.net",
"cupcake.is",
"curv.dev",
"*.customer-oci.com",
"*.oci.customer-oci.com",
"*.ocp.customer-oci.com",
"*.ocs.customer-oci.com",
"cyon.link",
"cyon.site",
"fnwk.site",
"folionetwork.site",
"platform0.app",
"daplie.me",
"localhost.daplie.me",
"dattolocal.com",
"dattorelay.com",
"dattoweb.com",
"mydatto.com",
"dattolocal.net",
"mydatto.net",
"biz.dk",
"co.dk",
"firm.dk",
"reg.dk",
"store.dk",
"dyndns.dappnode.io",
"*.dapps.earth",
"*.bzz.dapps.earth",
"builtwithdark.com",
"demo.datadetect.com",
"instance.datadetect.com",
"edgestack.me",
"ddns5.com",
"debian.net",
"deno.dev",
"deno-staging.dev",
"dedyn.io",
"deta.app",
"deta.dev",
"*.rss.my.id",
"*.diher.solutions",
"discordsays.com",
"discordsez.com",
"jozi.biz",
"dnshome.de",
"online.th",
"shop.th",
"drayddns.com",
"shoparena.pl",
"dreamhosters.com",
"mydrobo.com",
"drud.io",
"drud.us",
"duckdns.org",
"bip.sh",
"bitbridge.net",
"dy.fi",
"tunk.org",
"dyndns-at-home.com",
"dyndns-at-work.com",
"dyndns-blog.com",
"dyndns-free.com",
"dyndns-home.com",
"dyndns-ip.com",
"dyndns-mail.com",
"dyndns-office.com",
"dyndns-pics.com",
"dyndns-remote.com",
"dyndns-server.com",
"dyndns-web.com",
"dyndns-wiki.com",
"dyndns-work.com",
"dyndns.biz",
"dyndns.info",
"dyndns.org",
"dyndns.tv",
"at-band-camp.net",
"ath.cx",
"barrel-of-knowledge.info",
"barrell-of-knowledge.info",
"better-than.tv",
"blogdns.com",
"blogdns.net",
"blogdns.org",
"blogsite.org",
"boldlygoingnowhere.org",
"broke-it.net",
"buyshouses.net",
"cechire.com",
"dnsalias.com",
"dnsalias.net",
"dnsalias.org",
"dnsdojo.com",
"dnsdojo.net",
"dnsdojo.org",
"does-it.net",
"doesntexist.com",
"doesntexist.org",
"dontexist.com",
"dontexist.net",
"dontexist.org",
"doomdns.com",
"doomdns.org",
"dvrdns.org",
"dyn-o-saur.com",
"dynalias.com",
"dynalias.net",
"dynalias.org",
"dynathome.net",
"dyndns.ws",
"endofinternet.net",
"endofinternet.org",
"endoftheinternet.org",
"est-a-la-maison.com",
"est-a-la-masion.com",
"est-le-patron.com",
"est-mon-blogueur.com",
"for-better.biz",
"for-more.biz",
"for-our.info",
"for-some.biz",
"for-the.biz",
"forgot.her.name",
"forgot.his.name",
"from-ak.com",
"from-al.com",
"from-ar.com",
"from-az.net",
"from-ca.com",
"from-co.net",
"from-ct.com",
"from-dc.com",
"from-de.com",
"from-fl.com",
"from-ga.com",
"from-hi.com",
"from-ia.com",
"from-id.com",
"from-il.com",
"from-in.com",
"from-ks.com",
"from-ky.com",
"from-la.net",
"from-ma.com",
"from-md.com",
"from-me.org",
"from-mi.com",
"from-mn.com",
"from-mo.com",
"from-ms.com",
"from-mt.com",
"from-nc.com",
"from-nd.com",
"from-ne.com",
"from-nh.com",
"from-nj.com",
"from-nm.com",
"from-nv.com",
"from-ny.net",
"from-oh.com",
"from-ok.com",
"from-or.com",
"from-pa.com",
"from-pr.com",
"from-ri.com",
"from-sc.com",
"from-sd.com",
"from-tn.com",
"from-tx.com",
"from-ut.com",
"from-va.com",
"from-vt.com",
"from-wa.com",
"from-wi.com",
"from-wv.com",
"from-wy.com",
"ftpaccess.cc",
"fuettertdasnetz.de",
"game-host.org",
"game-server.cc",
"getmyip.com",
"gets-it.net",
"go.dyndns.org",
"gotdns.com",
"gotdns.org",
"groks-the.info",
"groks-this.info",
"ham-radio-op.net",
"here-for-more.info",
"hobby-site.com",
"hobby-site.org",
"home.dyndns.org",
"homedns.org",
"homeftp.net",
"homeftp.org",
"homeip.net",
"homelinux.com",
"homelinux.net",
"homelinux.org",
"homeunix.com",
"homeunix.net",
"homeunix.org",
"iamallama.com",
"in-the-band.net",
"is-a-anarchist.com",
"is-a-blogger.com",
"is-a-bookkeeper.com",
"is-a-bruinsfan.org",
"is-a-bulls-fan.com",
"is-a-candidate.org",
"is-a-caterer.com",
"is-a-celticsfan.org",
"is-a-chef.com",
"is-a-chef.net",
"is-a-chef.org",
"is-a-conservative.com",
"is-a-cpa.com",
"is-a-cubicle-slave.com",
"is-a-democrat.com",
"is-a-designer.com",
"is-a-doctor.com",
"is-a-financialadvisor.com",
"is-a-geek.com",
"is-a-geek.net",
"is-a-geek.org",
"is-a-green.com",
"is-a-guru.com",
"is-a-hard-worker.com",
"is-a-hunter.com",
"is-a-knight.org",
"is-a-landscaper.com",
"is-a-lawyer.com",
"is-a-liberal.com",
"is-a-libertarian.com",
"is-a-linux-user.org",
"is-a-llama.com",
"is-a-musician.com",
"is-a-nascarfan.com",
"is-a-nurse.com",
"is-a-painter.com",
"is-a-patsfan.org",
"is-a-personaltrainer.com",
"is-a-photographer.com",
"is-a-player.com",
"is-a-republican.com",
"is-a-rockstar.com",
"is-a-socialist.com",
"is-a-soxfan.org",
"is-a-student.com",
"is-a-teacher.com",
"is-a-techie.com",
"is-a-therapist.com",
"is-an-accountant.com",
"is-an-actor.com",
"is-an-actress.com",
"is-an-anarchist.com",
"is-an-artist.com",
"is-an-engineer.com",
"is-an-entertainer.com",
"is-by.us",
"is-certified.com",
"is-found.org",
"is-gone.com",
"is-into-anime.com",
"is-into-cars.com",
"is-into-cartoons.com",
"is-into-games.com",
"is-leet.com",
"is-lost.org",
"is-not-certified.com",
"is-saved.org",
"is-slick.com",
"is-uberleet.com",
"is-very-bad.org",
"is-very-evil.org",
"is-very-good.org",
"is-very-nice.org",
"is-very-sweet.org",
"is-with-theband.com",
"isa-geek.com",
"isa-geek.net",
"isa-geek.org",
"isa-hockeynut.com",
"issmarterthanyou.com",
"isteingeek.de",
"istmein.de",
"kicks-ass.net",
"kicks-ass.org",
"knowsitall.info",
"land-4-sale.us",
"lebtimnetz.de",
"leitungsen.de",
"likes-pie.com",
"likescandy.com",
"merseine.nu",
"mine.nu",
"misconfused.org",
"mypets.ws",
"myphotos.cc",
"neat-url.com",
"office-on-the.net",
"on-the-web.tv",
"podzone.net",
"podzone.org",
"readmyblog.org",
"saves-the-whales.com",
"scrapper-site.net",
"scrapping.cc",
"selfip.biz",
"selfip.com",
"selfip.info",
"selfip.net",
"selfip.org",
"sells-for-less.com",
"sells-for-u.com",
"sells-it.net",
"sellsyourhome.org",
"servebbs.com",
"servebbs.net",
"servebbs.org",
"serveftp.net",
"serveftp.org",
"servegame.org",
"shacknet.nu",
"simple-url.com",
"space-to-rent.com",
"stuff-4-sale.org",
"stuff-4-sale.us",
"teaches-yoga.com",
"thruhere.net",
"traeumtgerade.de",
"webhop.biz",
"webhop.info",
"webhop.net",
"webhop.org",
"worse-than.tv",
"writesthisblog.com",
"ddnss.de",
"dyn.ddnss.de",
"dyndns.ddnss.de",
"dyndns1.de",
"dyn-ip24.de",
"home-webserver.de",
"dyn.home-webserver.de",
"myhome-server.de",
"ddnss.org",
"definima.net",
"definima.io",
"ondigitalocean.app",
"*.digitaloceanspaces.com",
"bci.dnstrace.pro",
"ddnsfree.com",
"ddnsgeek.com",
"giize.com",
"gleeze.com",
"kozow.com",
"loseyourip.com",
"ooguy.com",
"theworkpc.com",
"casacam.net",
"dynu.net",
"accesscam.org",
"camdvr.org",
"freeddns.org",
"mywire.org",
"webredirect.org",
"myddns.rocks",
"blogsite.xyz",
"dynv6.net",
"e4.cz",
"eero.online",
"eero-stage.online",
"elementor.cloud",
"elementor.cool",
"en-root.fr",
"mytuleap.com",
"tuleap-partners.com",
"encr.app",
"encoreapi.com",
"onred.one",
"staging.onred.one",
"eu.encoway.cloud",
"eu.org",
"al.eu.org",
"asso.eu.org",
"at.eu.org",
"au.eu.org",
"be.eu.org",
"bg.eu.org",
"ca.eu.org",
"cd.eu.org",
"ch.eu.org",
"cn.eu.org",
"cy.eu.org",
"cz.eu.org",
"de.eu.org",
"dk.eu.org",
"edu.eu.org",
"ee.eu.org",
"es.eu.org",
"fi.eu.org",
"fr.eu.org",
"gr.eu.org",
"hr.eu.org",
"hu.eu.org",
"ie.eu.org",
"il.eu.org",
"in.eu.org",
"int.eu.org",
"is.eu.org",
"it.eu.org",
"jp.eu.org",
"kr.eu.org",
"lt.eu.org",
"lu.eu.org",
"lv.eu.org",
"mc.eu.org",
"me.eu.org",
"mk.eu.org",
"mt.eu.org",
"my.eu.org",
"net.eu.org",
"ng.eu.org",
"nl.eu.org",
"no.eu.org",
"nz.eu.org",
"paris.eu.org",
"pl.eu.org",
"pt.eu.org",
"q-a.eu.org",
"ro.eu.org",
"ru.eu.org",
"se.eu.org",
"si.eu.org",
"sk.eu.org",
"tr.eu.org",
"uk.eu.org",
"us.eu.org",
"eurodir.ru",
"eu-1.evennode.com",
"eu-2.evennode.com",
"eu-3.evennode.com",
"eu-4.evennode.com",
"us-1.evennode.com",
"us-2.evennode.com",
"us-3.evennode.com",
"us-4.evennode.com",
"twmail.cc",
"twmail.net",
"twmail.org",
"mymailer.com.tw",
"url.tw",
"onfabrica.com",
"apps.fbsbx.com",
"ru.net",
"adygeya.ru",
"bashkiria.ru",
"bir.ru",
"cbg.ru",
"com.ru",
"dagestan.ru",
"grozny.ru",
"kalmykia.ru",
"kustanai.ru",
"marine.ru",
"mordovia.ru",
"msk.ru",
"mytis.ru",
"nalchik.ru",
"nov.ru",
"pyatigorsk.ru",
"spb.ru",
"vladikavkaz.ru",
"vladimir.ru",
"abkhazia.su",
"adygeya.su",
"aktyubinsk.su",
"arkhangelsk.su",
"armenia.su",
"ashgabad.su",
"azerbaijan.su",
"balashov.su",
"bashkiria.su",
"bryansk.su",
"bukhara.su",
"chimkent.su",
"dagestan.su",
"east-kazakhstan.su",
"exnet.su",
"georgia.su",
"grozny.su",
"ivanovo.su",
"jambyl.su",
"kalmykia.su",
"kaluga.su",
"karacol.su",
"karaganda.su",
"karelia.su",
"khakassia.su",
"krasnodar.su",
"kurgan.su",
"kustanai.su",
"lenug.su",
"mangyshlak.su",
"mordovia.su",
"msk.su",
"murmansk.su",
"nalchik.su",
"navoi.su",
"north-kazakhstan.su",
"nov.su",
"obninsk.su",
"penza.su",
"pokrovsk.su",
"sochi.su",
"spb.su",
"tashkent.su",
"termez.su",
"togliatti.su",
"troitsk.su",
"tselinograd.su",
"tula.su",
"tuva.su",
"vladikavkaz.su",
"vladimir.su",
"vologda.su",
"channelsdvr.net",
"u.channelsdvr.net",
"edgecompute.app",
"fastly-terrarium.com",
"fastlylb.net",
"map.fastlylb.net",
"freetls.fastly.net",
"map.fastly.net",
"a.prod.fastly.net",
"global.prod.fastly.net",
"a.ssl.fastly.net",
"b.ssl.fastly.net",
"global.ssl.fastly.net",
"fastvps-server.com",
"fastvps.host",
"myfast.host",
"fastvps.site",
"myfast.space",
"fedorainfracloud.org",
"fedorapeople.org",
"cloud.fedoraproject.org",
"app.os.fedoraproject.org",
"app.os.stg.fedoraproject.org",
"conn.uk",
"copro.uk",
"hosp.uk",
"mydobiss.com",
"fh-muenster.io",
"filegear.me",
"filegear-au.me",
"filegear-de.me",
"filegear-gb.me",
"filegear-ie.me",
"filegear-jp.me",
"filegear-sg.me",
"firebaseapp.com",
"fireweb.app",
"flap.id",
"onflashdrive.app",
"fldrv.com",
"fly.dev",
"edgeapp.net",
"shw.io",
"flynnhosting.net",
"forgeblocks.com",
"id.forgerock.io",
"framer.app",
"framercanvas.com",
"*.frusky.de",
"ravpage.co.il",
"0e.vc",
"freebox-os.com",
"freeboxos.com",
"fbx-os.fr",
"fbxos.fr",
"freebox-os.fr",
"freeboxos.fr",
"freedesktop.org",
"freemyip.com",
"wien.funkfeuer.at",
"*.futurecms.at",
"*.ex.futurecms.at",
"*.in.futurecms.at",
"futurehosting.at",
"futuremailing.at",
"*.ex.ortsinfo.at",
"*.kunden.ortsinfo.at",
"*.statics.cloud",
"independent-commission.uk",
"independent-inquest.uk",
"independent-inquiry.uk",
"independent-panel.uk",
"independent-review.uk",
"public-inquiry.uk",
"royal-commission.uk",
"campaign.gov.uk",
"service.gov.uk",
"api.gov.uk",
"gehirn.ne.jp",
"usercontent.jp",
"gentapps.com",
"gentlentapis.com",
"lab.ms",
"cdn-edges.net",
"ghost.io",
"gsj.bz",
"githubusercontent.com",
"githubpreview.dev",
"github.io",
"gitlab.io",
"gitapp.si",
"gitpage.si",
"glitch.me",
"nog.community",
"co.ro",
"shop.ro",
"lolipop.io",
"angry.jp",
"babyblue.jp",
"babymilk.jp",
"backdrop.jp",
"bambina.jp",
"bitter.jp",
"blush.jp",
"boo.jp",
"boy.jp",
"boyfriend.jp",
"but.jp",
"candypop.jp",
"capoo.jp",
"catfood.jp",
"cheap.jp",
"chicappa.jp",
"chillout.jp",
"chips.jp",
"chowder.jp",
"chu.jp",
"ciao.jp",
"cocotte.jp",
"coolblog.jp",
"cranky.jp",
"cutegirl.jp",
"daa.jp",
"deca.jp",
"deci.jp",
"digick.jp",
"egoism.jp",
"fakefur.jp",
"fem.jp",
"flier.jp",
"floppy.jp",
"fool.jp",
"frenchkiss.jp",
"girlfriend.jp",
"girly.jp",
"gloomy.jp",
"gonna.jp",
"greater.jp",
"hacca.jp",
"heavy.jp",
"her.jp",
"hiho.jp",
"hippy.jp",
"holy.jp",
"hungry.jp",
"icurus.jp",
"itigo.jp",
"jellybean.jp",
"kikirara.jp",
"kill.jp",
"kilo.jp",
"kuron.jp",
"littlestar.jp",
"lolipopmc.jp",
"lolitapunk.jp",
"lomo.jp",
"lovepop.jp",
"lovesick.jp",
"main.jp",
"mods.jp",
"mond.jp",
"mongolian.jp",
"moo.jp",
"namaste.jp",
"nikita.jp",
"nobushi.jp",
"noor.jp",
"oops.jp",
"parallel.jp",
"parasite.jp",
"pecori.jp",
"peewee.jp",
"penne.jp",
"pepper.jp",
"perma.jp",
"pigboat.jp",
"pinoko.jp",
"punyu.jp",
"pupu.jp",
"pussycat.jp",
"pya.jp",
"raindrop.jp",
"readymade.jp",
"sadist.jp",
"schoolbus.jp",
"secret.jp",
"staba.jp",
"stripper.jp",
"sub.jp",
"sunnyday.jp",
"thick.jp",
"tonkotsu.jp",
"under.jp",
"upper.jp",
"velvet.jp",
"verse.jp",
"versus.jp",
"vivian.jp",
"watson.jp",
"weblike.jp",
"whitesnow.jp",
"zombie.jp",
"heteml.net",
"cloudapps.digital",
"london.cloudapps.digital",
"pymnt.uk",
"homeoffice.gov.uk",
"ro.im",
"goip.de",
"run.app",
"a.run.app",
"web.app",
"*.0emm.com",
"appspot.com",
"*.r.appspot.com",
"codespot.com",
"googleapis.com",
"googlecode.com",
"pagespeedmobilizer.com",
"publishproxy.com",
"withgoogle.com",
"withyoutube.com",
"*.gateway.dev",
"cloud.goog",
"translate.goog",
"*.usercontent.goog",
"cloudfunctions.net",
"blogspot.ae",
"blogspot.al",
"blogspot.am",
"blogspot.ba",
"blogspot.be",
"blogspot.bg",
"blogspot.bj",
"blogspot.ca",
"blogspot.cf",
"blogspot.ch",
"blogspot.cl",
"blogspot.co.at",
"blogspot.co.id",
"blogspot.co.il",
"blogspot.co.ke",
"blogspot.co.nz",
"blogspot.co.uk",
"blogspot.co.za",
"blogspot.com",
"blogspot.com.ar",
"blogspot.com.au",
"blogspot.com.br",
"blogspot.com.by",
"blogspot.com.co",
"blogspot.com.cy",
"blogspot.com.ee",
"blogspot.com.eg",
"blogspot.com.es",
"blogspot.com.mt",
"blogspot.com.ng",
"blogspot.com.tr",
"blogspot.com.uy",
"blogspot.cv",
"blogspot.cz",
"blogspot.de",
"blogspot.dk",
"blogspot.fi",
"blogspot.fr",
"blogspot.gr",
"blogspot.hk",
"blogspot.hr",
"blogspot.hu",
"blogspot.ie",
"blogspot.in",
"blogspot.is",
"blogspot.it",
"blogspot.jp",
"blogspot.kr",
"blogspot.li",
"blogspot.lt",
"blogspot.lu",
"blogspot.md",
"blogspot.mk",
"blogspot.mr",
"blogspot.mx",
"blogspot.my",
"blogspot.nl",
"blogspot.no",
"blogspot.pe",
"blogspot.pt",
"blogspot.qa",
"blogspot.re",
"blogspot.ro",
"blogspot.rs",
"blogspot.ru",
"blogspot.se",
"blogspot.sg",
"blogspot.si",
"blogspot.sk",
"blogspot.sn",
"blogspot.td",
"blogspot.tw",
"blogspot.ug",
"blogspot.vn",
"goupile.fr",
"gov.nl",
"awsmppl.com",
"gnstigbestellen.de",
"gnstigliefern.de",
"fin.ci",
"free.hr",
"caa.li",
"ua.rs",
"conf.se",
"hs.zone",
"hs.run",
"hashbang.sh",
"hasura.app",
"hasura-app.io",
"pages.it.hs-heilbronn.de",
"hepforge.org",
"herokuapp.com",
"herokussl.com",
"ravendb.cloud",
"myravendb.com",
"ravendb.community",
"ravendb.me",
"development.run",
"ravendb.run",
"homesklep.pl",
"secaas.hk",
"hoplix.shop",
"orx.biz",
"biz.gl",
"col.ng",
"firm.ng",
"gen.ng",
"ltd.ng",
"ngo.ng",
"edu.scot",
"sch.so",
"hostyhosting.io",
"hkkinen.fi",
"*.moonscale.io",
"moonscale.net",
"iki.fi",
"ibxos.it",
"iliadboxos.it",
"impertrixcdn.com",
"impertrix.com",
"smushcdn.com",
"wphostedmail.com",
"wpmucdn.com",
"tempurl.host",
"wpmudev.host",
"dyn-berlin.de",
"in-berlin.de",
"in-brb.de",
"in-butter.de",
"in-dsl.de",
"in-dsl.net",
"in-dsl.org",
"in-vpn.de",
"in-vpn.net",
"in-vpn.org",
"biz.at",
"info.at",
"info.cx",
"ac.leg.br",
"al.leg.br",
"am.leg.br",
"ap.leg.br",
"ba.leg.br",
"ce.leg.br",
"df.leg.br",
"es.leg.br",
"go.leg.br",
"ma.leg.br",
"mg.leg.br",
"ms.leg.br",
"mt.leg.br",
"pa.leg.br",
"pb.leg.br",
"pe.leg.br",
"pi.leg.br",
"pr.leg.br",
"rj.leg.br",
"rn.leg.br",
"ro.leg.br",
"rr.leg.br",
"rs.leg.br",
"sc.leg.br",
"se.leg.br",
"sp.leg.br",
"to.leg.br",
"pixolino.com",
"na4u.ru",
"iopsys.se",
"ipifony.net",
"iservschule.de",
"mein-iserv.de",
"schulplattform.de",
"schulserver.de",
"test-iserv.de",
"iserv.dev",
"iobb.net",
"mel.cloudlets.com.au",
"cloud.interhostsolutions.be",
"users.scale.virtualcloud.com.br",
"mycloud.by",
"alp1.ae.flow.ch",
"appengine.flow.ch",
"es-1.axarnet.cloud",
"diadem.cloud",
"vip.jelastic.cloud",
"jele.cloud",
"it1.eur.aruba.jenv-aruba.cloud",
"it1.jenv-aruba.cloud",
"keliweb.cloud",
"cs.keliweb.cloud",
"oxa.cloud",
"tn.oxa.cloud",
"uk.oxa.cloud",
"primetel.cloud",
"uk.primetel.cloud",
"ca.reclaim.cloud",
"uk.reclaim.cloud",
"us.reclaim.cloud",
"ch.trendhosting.cloud",
"de.trendhosting.cloud",
"jele.club",
"amscompute.com",
"clicketcloud.com",
"dopaas.com",
"hidora.com",
"paas.hosted-by-previder.com",
"rag-cloud.hosteur.com",
"rag-cloud-ch.hosteur.com",
"jcloud.ik-server.com",
"jcloud-ver-jpc.ik-server.com",
"demo.jelastic.com",
"kilatiron.com",
"paas.massivegrid.com",
"jed.wafaicloud.com",
"lon.wafaicloud.com",
"ryd.wafaicloud.com",
"j.scaleforce.com.cy",
"jelastic.dogado.eu",
"fi.cloudplatform.fi",
"demo.datacenter.fi",
"paas.datacenter.fi",
"jele.host",
"mircloud.host",
"paas.beebyte.io",
"sekd1.beebyteapp.io",
"jele.io",
"cloud-fr1.unispace.io",
"jc.neen.it",
"cloud.jelastic.open.tim.it",
"jcloud.kz",
"upaas.kazteleport.kz",
"cloudjiffy.net",
"fra1-de.cloudjiffy.net",
"west1-us.cloudjiffy.net",
"jls-sto1.elastx.net",
"jls-sto2.elastx.net",
"jls-sto3.elastx.net",
"faststacks.net",
"fr-1.paas.massivegrid.net",
"lon-1.paas.massivegrid.net",
"lon-2.paas.massivegrid.net",
"ny-1.paas.massivegrid.net",
"ny-2.paas.massivegrid.net",
"sg-1.paas.massivegrid.net",
"jelastic.saveincloud.net",
"nordeste-idc.saveincloud.net",
"j.scaleforce.net",
"jelastic.tsukaeru.net",
"sdscloud.pl",
"unicloud.pl",
"mircloud.ru",
"jelastic.regruhosting.ru",
"enscaled.sg",
"jele.site",
"jelastic.team",
"orangecloud.tn",
"j.layershift.co.uk",
"phx.enscaled.us",
"mircloud.us",
"myjino.ru",
"*.hosting.myjino.ru",
"*.landing.myjino.ru",
"*.spectrum.myjino.ru",
"*.vps.myjino.ru",
"jotelulu.cloud",
"*.triton.zone",
"*.cns.joyent.com",
"js.org",
"kaas.gg",
"khplay.nl",
"ktistory.com",
"kapsi.fi",
"keymachine.de",
"kinghost.net",
"uni5.net",
"knightpoint.systems",
"koobin.events",
"oya.to",
"kuleuven.cloud",
"ezproxy.kuleuven.be",
"co.krd",
"edu.krd",
"krellian.net",
"webthings.io",
"git-repos.de",
"lcube-server.de",
"svn-repos.de",
"leadpages.co",
"lpages.co",
"lpusercontent.com",
"lelux.site",
"co.business",
"co.education",
"co.events",
"co.financial",
"co.network",
"co.place",
"co.technology",
"app.lmpm.com",
"linkyard.cloud",
"linkyard-cloud.ch",
"members.linode.com",
"*.nodebalancer.linode.com",
"*.linodeobjects.com",
"ip.linodeusercontent.com",
"we.bs",
"*.user.localcert.dev",
"localzone.xyz",
"loginline.app",
"loginline.dev",
"loginline.io",
"loginline.services",
"loginline.site",
"servers.run",
"lohmus.me",
"krasnik.pl",
"leczna.pl",
"lubartow.pl",
"lublin.pl",
"poniatowa.pl",
"swidnik.pl",
"glug.org.uk",
"lug.org.uk",
"lugs.org.uk",
"barsy.bg",
"barsy.co.uk",
"barsyonline.co.uk",
"barsycenter.com",
"barsyonline.com",
"barsy.club",
"barsy.de",
"barsy.eu",
"barsy.in",
"barsy.info",
"barsy.io",
"barsy.me",
"barsy.menu",
"barsy.mobi",
"barsy.net",
"barsy.online",
"barsy.org",
"barsy.pro",
"barsy.pub",
"barsy.ro",
"barsy.shop",
"barsy.site",
"barsy.support",
"barsy.uk",
"*.magentosite.cloud",
"mayfirst.info",
"mayfirst.org",
"hb.cldmail.ru",
"cn.vu",
"mazeplay.com",
"mcpe.me",
"mcdir.me",
"mcdir.ru",
"mcpre.ru",
"vps.mcdir.ru",
"mediatech.by",
"mediatech.dev",
"hra.health",
"miniserver.com",
"memset.net",
"messerli.app",
"*.cloud.metacentrum.cz",
"custom.metacentrum.cz",
"flt.cloud.muni.cz",
"usr.cloud.muni.cz",
"meteorapp.com",
"eu.meteorapp.com",
"co.pl",
"*.azurecontainer.io",
"azurewebsites.net",
"azure-mobile.net",
"cloudapp.net",
"azurestaticapps.net",
"1.azurestaticapps.net",
"centralus.azurestaticapps.net",
"eastasia.azurestaticapps.net",
"eastus2.azurestaticapps.net",
"westeurope.azurestaticapps.net",
"westus2.azurestaticapps.net",
"csx.cc",
"mintere.site",
"forte.id",
"mozilla-iot.org",
"bmoattachments.org",
"net.ru",
"org.ru",
"pp.ru",
"hostedpi.com",
"customer.mythic-beasts.com",
"caracal.mythic-beasts.com",
"fentiger.mythic-beasts.com",
"lynx.mythic-beasts.com",
"ocelot.mythic-beasts.com",
"oncilla.mythic-beasts.com",
"onza.mythic-beasts.com",
"sphinx.mythic-beasts.com",
"vs.mythic-beasts.com",
"x.mythic-beasts.com",
"yali.mythic-beasts.com",
"cust.retrosnub.co.uk",
"ui.nabu.casa",
"pony.club",
"of.fashion",
"in.london",
"of.london",
"from.marketing",
"with.marketing",
"for.men",
"repair.men",
"and.mom",
"for.mom",
"for.one",
"under.one",
"for.sale",
"that.win",
"from.work",
"to.work",
"cloud.nospamproxy.com",
"netlify.app",
"4u.com",
"ngrok.io",
"nh-serv.co.uk",
"nfshost.com",
"*.developer.app",
"noop.app",
"*.northflank.app",
"*.build.run",
"*.code.run",
"*.database.run",
"*.migration.run",
"noticeable.news",
"dnsking.ch",
"mypi.co",
"n4t.co",
"001www.com",
"ddnslive.com",
"myiphost.com",
"forumz.info",
"16-b.it",
"32-b.it",
"64-b.it",
"soundcast.me",
"tcp4.me",
"dnsup.net",
"hicam.net",
"now-dns.net",
"ownip.net",
"vpndns.net",
"dynserv.org",
"now-dns.org",
"x443.pw",
"now-dns.top",
"ntdll.top",
"freeddns.us",
"crafting.xyz",
"zapto.xyz",
"nsupdate.info",
"nerdpol.ovh",
"blogsyte.com",
"brasilia.me",
"cable-modem.org",
"ciscofreak.com",
"collegefan.org",
"couchpotatofries.org",
"damnserver.com",
"ddns.me",
"ditchyourip.com",
"dnsfor.me",
"dnsiskinky.com",
"dvrcam.info",
"dynns.com",
"eating-organic.net",
"fantasyleague.cc",
"geekgalaxy.com",
"golffan.us",
"health-carereform.com",
"homesecuritymac.com",
"homesecuritypc.com",
"hopto.me",
"ilovecollege.info",
"loginto.me",
"mlbfan.org",
"mmafan.biz",
"myactivedirectory.com",
"mydissent.net",
"myeffect.net",
"mymediapc.net",
"mypsx.net",
"mysecuritycamera.com",
"mysecuritycamera.net",
"mysecuritycamera.org",
"net-freaks.com",
"nflfan.org",
"nhlfan.net",
"no-ip.ca",
"no-ip.co.uk",
"no-ip.net",
"noip.us",
"onthewifi.com",
"pgafan.net",
"point2this.com",
"pointto.us",
"privatizehealthinsurance.net",
"quicksytes.com",
"read-books.org",
"securitytactics.com",
"serveexchange.com",
"servehumour.com",
"servep2p.com",
"servesarcasm.com",
"stufftoread.com",
"ufcfan.org",
"unusualperson.com",
"workisboring.com",
"3utilities.com",
"bounceme.net",
"ddns.net",
"ddnsking.com",
"gotdns.ch",
"hopto.org",
"myftp.biz",
"myftp.org",
"myvnc.com",
"no-ip.biz",
"no-ip.info",
"no-ip.org",
"noip.me",
"redirectme.net",
"servebeer.com",
"serveblog.net",
"servecounterstrike.com",
"serveftp.com",
"servegame.com",
"servehalflife.com",
"servehttp.com",
"serveirc.com",
"serveminecraft.net",
"servemp3.com",
"servepics.com",
"servequake.com",
"sytes.net",
"webhop.me",
"zapto.org",
"stage.nodeart.io",
"pcloud.host",
"nyc.mn",
"static.observableusercontent.com",
"cya.gg",
"omg.lol",
"cloudycluster.net",
"omniwe.site",
"service.one",
"nid.io",
"opensocial.site",
"opencraft.hosting",
"orsites.com",
"operaunite.com",
"tech.orange",
"authgear-staging.com",
"authgearapps.com",
"skygearapp.com",
"outsystemscloud.com",
"*.webpaas.ovh.net",
"*.hosting.ovh.net",
"ownprovider.com",
"own.pm",
"*.owo.codes",
"ox.rs",
"oy.lc",
"pgfog.com",
"pagefrontapp.com",
"pagexl.com",
"*.paywhirl.com",
"bar0.net",
"bar1.net",
"bar2.net",
"rdv.to",
"art.pl",
"gliwice.pl",
"krakow.pl",
"poznan.pl",
"wroc.pl",
"zakopane.pl",
"pantheonsite.io",
"gotpantheon.com",
"mypep.link",
"perspecta.cloud",
"lk3.ru",
"on-web.fr",
"bc.platform.sh",
"ent.platform.sh",
"eu.platform.sh",
"us.platform.sh",
"*.platformsh.site",
"*.tst.site",
"platter-app.com",
"platter-app.dev",
"platterp.us",
"pdns.page",
"plesk.page",
"pleskns.com",
"dyn53.io",
"onporter.run",
"co.bn",
"postman-echo.com",
"pstmn.io",
"mock.pstmn.io",
"httpbin.org",
"prequalifyme.today",
"xen.prgmr.com",
"priv.at",
"prvcy.page",
"*.dweb.link",
"protonet.io",
"chirurgiens-dentistes-en-france.fr",
"byen.site",
"pubtls.org",
"pythonanywhere.com",
"eu.pythonanywhere.com",
"qoto.io",
"qualifioapp.com",
"qbuser.com",
"cloudsite.builders",
"instances.spawn.cc",
"instantcloud.cn",
"ras.ru",
"qa2.com",
"qcx.io",
"*.sys.qcx.io",
"dev-myqnapcloud.com",
"alpha-myqnapcloud.com",
"myqnapcloud.com",
"*.quipelements.com",
"vapor.cloud",
"vaporcloud.io",
"rackmaze.com",
"rackmaze.net",
"g.vbrplsbx.io",
"*.on-k3s.io",
"*.on-rancher.cloud",
"*.on-rio.io",
"readthedocs.io",
"rhcloud.com",
"app.render.com",
"onrender.com",
"repl.co",
"id.repl.co",
"repl.run",
"resindevice.io",
"devices.resinstaging.io",
"hzc.io",
"wellbeingzone.eu",
"wellbeingzone.co.uk",
"adimo.co.uk",
"itcouldbewor.se",
"git-pages.rit.edu",
"rocky.page",
".",
".",
".",
".",
".",
".",
".",
".",
".",
".",
"*.builder.code.com",
"*.dev-builder.code.com",
"*.stg-builder.code.com",
"sandcats.io",
"logoip.de",
"logoip.com",
"fr-par-1.baremetal.scw.cloud",
"fr-par-2.baremetal.scw.cloud",
"nl-ams-1.baremetal.scw.cloud",
"fnc.fr-par.scw.cloud",
"functions.fnc.fr-par.scw.cloud",
"k8s.fr-par.scw.cloud",
"nodes.k8s.fr-par.scw.cloud",
"s3.fr-par.scw.cloud",
"s3-website.fr-par.scw.cloud",
"whm.fr-par.scw.cloud",
"priv.instances.scw.cloud",
"pub.instances.scw.cloud",
"k8s.scw.cloud",
"k8s.nl-ams.scw.cloud",
"nodes.k8s.nl-ams.scw.cloud",
"s3.nl-ams.scw.cloud",
"s3-website.nl-ams.scw.cloud",
"whm.nl-ams.scw.cloud",
"k8s.pl-waw.scw.cloud",
"nodes.k8s.pl-waw.scw.cloud",
"s3.pl-waw.scw.cloud",
"s3-website.pl-waw.scw.cloud",
"scalebook.scw.cloud",
"smartlabeling.scw.cloud",
"dedibox.fr",
"schokokeks.net",
"gov.scot",
"service.gov.scot",
"scrysec.com",
"firewall-gateway.com",
"firewall-gateway.de",
"my-gateway.de",
"my-router.de",
"spdns.de",
"spdns.eu",
"firewall-gateway.net",
"my-firewall.org",
"myfirewall.org",
"spdns.org",
"seidat.net",
"sellfy.store",
"senseering.net",
"minisite.ms",
"magnet.page",
"biz.ua",
"co.ua",
"pp.ua",
"shiftcrypto.dev",
"shiftcrypto.io",
"shiftedit.io",
"myshopblocks.com",
"myshopify.com",
"shopitsite.com",
"shopware.store",
"mo-siemens.io",
"1kapp.com",
"appchizi.com",
"applinzi.com",
"sinaapp.com",
"vipsinaapp.com",
"siteleaf.net",
"bounty-full.com",
"alpha.bounty-full.com",
"beta.bounty-full.com",
"small-web.org",
"vp4.me",
"try-snowplow.com",
"srht.site",
"stackhero-network.com",
"musician.io",
"novecore.site",
"static.land",
"dev.static.land",
"sites.static.land",
"storebase.store",
"vps-host.net",
"atl.jelastic.vps-host.net",
"njs.jelastic.vps-host.net",
"ric.jelastic.vps-host.net",
"playstation-cloud.com",
"apps.lair.io",
"*.stolos.io",
"spacekit.io",
"customer.speedpartner.de",
"myspreadshop.at",
"myspreadshop.com.au",
"myspreadshop.be",
"myspreadshop.ca",
"myspreadshop.ch",
"myspreadshop.com",
"myspreadshop.de",
"myspreadshop.dk",
"myspreadshop.es",
"myspreadshop.fi",
"myspreadshop.fr",
"myspreadshop.ie",
"myspreadshop.it",
"myspreadshop.net",
"myspreadshop.nl",
"myspreadshop.no",
"myspreadshop.pl",
"myspreadshop.se",
"myspreadshop.co.uk",
"api.stdlib.com",
"storj.farm",
"utwente.io",
"soc.srcf.net",
"user.srcf.net",
"temp-dns.com",
"supabase.co",
"supabase.in",
"supabase.net",
"su.paba.se",
"*.s5y.io",
"*.sensiosite.cloud",
"syncloud.it",
"dscloud.biz",
"direct.quickconnect.cn",
"dsmynas.com",
"familyds.com",
"diskstation.me",
"dscloud.me",
"i234.me",
"myds.me",
"synology.me",
"dscloud.mobi",
"dsmynas.net",
"familyds.net",
"dsmynas.org",
"familyds.org",
"vpnplus.to",
"direct.quickconnect.to",
"tabitorder.co.il",
"taifun-dns.de",
"beta.tailscale.net",
"ts.net",
"gda.pl",
"gdansk.pl",
"gdynia.pl",
"med.pl",
"sopot.pl",
"site.tb-hosting.com",
"edugit.io",
"s3.teckids.org",
"telebit.app",
"telebit.io",
"*.telebit.xyz",
"gwiddle.co.uk",
"*.firenet.ch",
"*.svc.firenet.ch",
"reservd.com",
"thingdustdata.com",
"cust.dev.thingdust.io",
"cust.disrec.thingdust.io",
"cust.prod.thingdust.io",
"cust.testing.thingdust.io",
"reservd.dev.thingdust.io",
"reservd.disrec.thingdust.io",
"reservd.testing.thingdust.io",
"tickets.io",
"arvo.network",
"azimuth.network",
"tlon.network",
"torproject.net",
"pages.torproject.net",
"bloxcms.com",
"townnews-staging.com",
"tbits.me",
"12hp.at",
"2ix.at",
"4lima.at",
"lima-city.at",
"12hp.ch",
"2ix.ch",
"4lima.ch",
"lima-city.ch",
"trafficplex.cloud",
"de.cool",
"12hp.de",
"2ix.de",
"4lima.de",
"lima-city.de",
"1337.pictures",
"clan.rip",
"lima-city.rocks",
"webspace.rocks",
"lima.zone",
"*.transurl.be",
"*.transurl.eu",
"*.transurl.nl",
"site.transip.me",
"tuxfamily.org",
"dd-dns.de",
"diskstation.eu",
"diskstation.org",
"dray-dns.de",
"draydns.de",
"dyn-vpn.de",
"dynvpn.de",
"mein-vigor.de",
"my-vigor.de",
"my-wan.de",
"syno-ds.de",
"synology-diskstation.de",
"synology-ds.de",
"typedream.app",
"pro.typeform.com",
"uber.space",
"*.uberspace.de",
"hk.com",
"hk.org",
"ltd.hk",
"inc.hk",
"name.pm",
"sch.tf",
"biz.wf",
"sch.wf",
"org.yt",
"virtualuser.de",
"virtual-user.de",
"upli.io",
"urown.cloud",
"dnsupdate.info",
"lib.de.us",
"2038.io",
"vercel.app",
"vercel.dev",
"now.sh",
"router.management",
"v-info.info",
"voorloper.cloud",
"neko.am",
"nyaa.am",
"be.ax",
"cat.ax",
"es.ax",
"eu.ax",
"gg.ax",
"mc.ax",
"us.ax",
"xy.ax",
"nl.ci",
"xx.gl",
"app.gp",
"blog.gt",
"de.gt",
"to.gt",
"be.gy",
"cc.hn",
"blog.kg",
"io.kg",
"jp.kg",
"tv.kg",
"uk.kg",
"us.kg",
"de.ls",
"at.md",
"de.md",
"jp.md",
"to.md",
"indie.porn",
"vxl.sh",
"ch.tc",
"me.tc",
"we.tc",
"nyan.to",
"at.vg",
"blog.vu",
"dev.vu",
"me.vu",
"v.ua",
"*.vultrobjects.com",
"wafflecell.com",
"*.webhare.dev",
"reserve-online.net",
"reserve-online.com",
"bookonline.app",
"hotelwithflight.com",
"wedeploy.io",
"wedeploy.me",
"wedeploy.sh",
"remotewd.com",
"pages.wiardweb.com",
"wmflabs.org",
"toolforge.org",
"wmcloud.org",
"panel.gg",
"daemon.panel.gg",
"messwithdns.com",
"woltlab-demo.com",
"myforum.community",
"community-pro.de",
"diskussionsbereich.de",
"community-pro.net",
"meinforum.net",
"affinitylottery.org.uk",
"raffleentry.org.uk",
"weeklylottery.org.uk",
"wpenginepowered.com",
"js.wpenginepowered.com",
"wixsite.com",
"editorx.io",
"half.host",
"xnbay.com",
"u2.xnbay.com",
"u2-local.xnbay.com",
"cistron.nl",
"demon.nl",
"xs4all.space",
"yandexcloud.net",
"storage.yandexcloud.net",
"website.yandexcloud.net",
"official.academy",
"yolasite.com",
"ybo.faith",
"yombo.me",
"homelink.one",
"ybo.party",
"ybo.review",
"ybo.science",
"ybo.trade",
"ynh.fr",
"nohost.me",
"noho.st",
"za.net",
"za.org",
"bss.design",
"basicserver.io",
"virtualserver.io",
"enterprisecloud.nu"
]
},{}],63:[function(require,module,exports){
/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */
'use strict';


var Punycode = require('punycode');


var internals = {};


//
// Read rules from file.
//
internals.rules = require('./data/rules.json').map(function (rule) {

  return {
    rule: rule,
    suffix: rule.replace(/^(\*\.|\!)/, ''),
    punySuffix: -1,
    wildcard: rule.charAt(0) === '*',
    exception: rule.charAt(0) === '!'
  };
});


//
// Check is given string ends with `suffix`.
//
internals.endsWith = function (str, suffix) {

  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};


//
// Find rule for a given domain.
//
internals.findRule = function (domain) {

  var punyDomain = Punycode.toASCII(domain);
  return internals.rules.reduce(function (memo, rule) {

    if (rule.punySuffix === -1){
      rule.punySuffix = Punycode.toASCII(rule.suffix);
    }
    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {
      return memo;
    }
    // This has been commented out as it never seems to run. This is because
    // sub tlds always appear after their parents and we never find a shorter
    // match.
    //if (memo) {
    //  var memoSuffix = Punycode.toASCII(memo.suffix);
    //  if (memoSuffix.length >= punySuffix.length) {
    //    return memo;
    //  }
    //}
    return rule;
  }, null);
};


//
// Error codes and messages.
//
exports.errorCodes = {
  DOMAIN_TOO_SHORT: 'Domain name too short.',
  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',
  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',
  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',
  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',
  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',
  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'
};


//
// Validate domain name and throw if not valid.
//
// From wikipedia:
//
// Hostnames are composed of series of labels concatenated with dots, as are all
// domain names. Each label must be between 1 and 63 characters long, and the
// entire hostname (including the delimiting dots) has a maximum of 255 chars.
//
// Allowed chars:
//
// * `a-z`
// * `0-9`
// * `-` but not as a starting or ending character
// * `.` as a separator for the textual portions of a domain name
//
// * http://en.wikipedia.org/wiki/Domain_name
// * http://en.wikipedia.org/wiki/Hostname
//
internals.validate = function (input) {

  // Before we can validate we need to take care of IDNs with unicode chars.
  var ascii = Punycode.toASCII(input);

  if (ascii.length < 1) {
    return 'DOMAIN_TOO_SHORT';
  }
  if (ascii.length > 255) {
    return 'DOMAIN_TOO_LONG';
  }

  // Check each part's length and allowed chars.
  var labels = ascii.split('.');
  var label;

  for (var i = 0; i < labels.length; ++i) {
    label = labels[i];
    if (!label.length) {
      return 'LABEL_TOO_SHORT';
    }
    if (label.length > 63) {
      return 'LABEL_TOO_LONG';
    }
    if (label.charAt(0) === '-') {
      return 'LABEL_STARTS_WITH_DASH';
    }
    if (label.charAt(label.length - 1) === '-') {
      return 'LABEL_ENDS_WITH_DASH';
    }
    if (!/^[a-z0-9\-]+$/.test(label)) {
      return 'LABEL_INVALID_CHARS';
    }
  }
};


//
// Public API
//


//
// Parse domain.
//
exports.parse = function (input) {

  if (typeof input !== 'string') {
    throw new TypeError('Domain name must be a string.');
  }

  // Force domain to lowercase.
  var domain = input.slice(0).toLowerCase();

  // Handle FQDN.
  // TODO: Simply remove trailing dot?
  if (domain.charAt(domain.length - 1) === '.') {
    domain = domain.slice(0, domain.length - 1);
  }

  // Validate and sanitise input.
  var error = internals.validate(domain);
  if (error) {
    return {
      input: input,
      error: {
        message: exports.errorCodes[error],
        code: error
      }
    };
  }

  var parsed = {
    input: input,
    tld: null,
    sld: null,
    domain: null,
    subdomain: null,
    listed: false
  };

  var domainParts = domain.split('.');

  // Non-Internet TLD
  if (domainParts[domainParts.length - 1] === 'local') {
    return parsed;
  }

  var handlePunycode = function () {

    if (!/xn--/.test(domain)) {
      return parsed;
    }
    if (parsed.domain) {
      parsed.domain = Punycode.toASCII(parsed.domain);
    }
    if (parsed.subdomain) {
      parsed.subdomain = Punycode.toASCII(parsed.subdomain);
    }
    return parsed;
  };

  var rule = internals.findRule(domain);

  // Unlisted tld.
  if (!rule) {
    if (domainParts.length < 2) {
      return parsed;
    }
    parsed.tld = domainParts.pop();
    parsed.sld = domainParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join('.');
    if (domainParts.length) {
      parsed.subdomain = domainParts.pop();
    }
    return handlePunycode();
  }

  // At this point we know the public suffix is listed.
  parsed.listed = true;

  var tldParts = rule.suffix.split('.');
  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);

  if (rule.exception) {
    privateParts.push(tldParts.shift());
  }

  parsed.tld = tldParts.join('.');

  if (!privateParts.length) {
    return handlePunycode();
  }

  if (rule.wildcard) {
    tldParts.unshift(privateParts.pop());
    parsed.tld = tldParts.join('.');
  }

  if (!privateParts.length) {
    return handlePunycode();
  }

  parsed.sld = privateParts.pop();
  parsed.domain = [parsed.sld,  parsed.tld].join('.');

  if (privateParts.length) {
    parsed.subdomain = privateParts.join('.');
  }

  return handlePunycode();
};


//
// Get domain.
//
exports.get = function (domain) {

  if (!domain) {
    return null;
  }
  return exports.parse(domain).domain || null;
};


//
// Check whether domain belongs to a known public suffix.
//
exports.isValid = function (domain) {

  var parsed = exports.parse(domain);
  return Boolean(parsed.domain && parsed.listed);
};

},{"./data/rules.json":62,"punycode":20}],64:[function(require,module,exports){
'use strict';

/** Highest positive signed 32-bit float value */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUnicode = exports.toASCII = exports.encode = exports.default = exports.decode = void 0;
exports.ucs2decode = ucs2decode;
exports.ucs2encode = void 0;
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
  'overflow': 'Overflow: input needs wider integers to process',
  'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
  'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
  throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {String} A new string of characters returned by the callback
 * function.
 */
function mapDomain(domain, callback) {
  const parts = domain.split('@');
  let result = '';
  if (parts.length > 1) {
    // In email addresses, only the domain name should be punycoded. Leave
    // the local part (i.e. everything up to `@`) intact.
    result = parts[0] + '@';
    domain = parts[1];
  }
  // Avoid `split(regex)` for IE8 compatibility. See #17.
  domain = domain.replace(regexSeparators, '\x2E');
  const labels = domain.split('.');
  const encoded = map(labels, callback).join('.');
  return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      const extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = codePoints => String.fromCodePoint(...codePoints);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
exports.ucs2encode = ucs2encode;
const basicToDigit = function (codePoint) {
  if (codePoint >= 0x30 && codePoint < 0x3A) {
    return 26 + (codePoint - 0x30);
  }
  if (codePoint >= 0x41 && codePoint < 0x5B) {
    return codePoint - 0x41;
  }
  if (codePoint >= 0x61 && codePoint < 0x7B) {
    return codePoint - 0x61;
  }
  return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function (digit, flag) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function (delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for /* no initialization */
  (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function (input) {
  // Don't use UCS-2.
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;

  // Handle the basic code points: let `basic` be the number of input code
  // points before the last delimiter, or `0` if there is none, then copy
  // the first basic code points to the output.

  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    // if it's not a basic code point
    if (input.charCodeAt(j) >= 0x80) {
      error('not-basic');
    }
    output.push(input.charCodeAt(j));
  }

  // Main decoding loop: start just after the last delimiter if any basic code
  // points were copied; start at the beginning otherwise.

  for /* no final expression */
  (let index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
    // `index` is the index of the next character to be consumed.
    // Decode a generalized variable-length integer into `delta`,
    // which gets added to `i`. The overflow checking is easier
    // if we increase `i` as we go, then subtract off its starting
    // value at the end to obtain `delta`.
    const oldi = i;
    for /* no condition */
    (let w = 1, k = base;; k += base) {
      if (index >= inputLength) {
        error('invalid-input');
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base) {
        error('invalid-input');
      }
      if (digit > floor((maxInt - i) / w)) {
        error('overflow');
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error('overflow');
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);

    // `i` was supposed to wrap around from `out` to `0`,
    // incrementing `n` each time, so we'll fix that now:
    if (floor(i / out) > maxInt - n) {
      error('overflow');
    }
    n += floor(i / out);
    i %= out;

    // Insert `n` at position `i` of the output.
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
exports.decode = decode;
const encode = function (input) {
  const output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  const inputLength = input.length;

  // Initialize the state.
  let n = initialN;
  let delta = 0;
  let bias = initialBias;

  // Handle the basic code points.
  for (const currentValue of input) {
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;

  // `handledCPCount` is the number of code points that have been handled;
  // `basicLength` is the number of basic code points.

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next
    // larger one:
    let m = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    // but guard against overflow.
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error('overflow');
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input) {
      if (currentValue < n && ++delta > maxInt) {
        error('overflow');
      }
      if (currentValue === n) {
        // Represent delta as a generalized variable-length integer.
        let q = delta;
        for /* no condition */
        (let k = base;; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
exports.encode = encode;
const toUnicode = function (input) {
  return mapDomain(input, function (string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
exports.toUnicode = toUnicode;
const toASCII = function (input) {
  return mapDomain(input, function (string) {
    return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
  });
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
exports.toASCII = toASCII;
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  'version': '2.3.1',
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  'ucs2': {
    'decode': ucs2decode,
    'encode': ucs2encode
  },
  'decode': decode,
  'encode': encode,
  'toASCII': toASCII,
  'toUnicode': toUnicode
};
var _default = exports.default = punycode;

},{}],65:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],66:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],67:[function(require,module,exports){
"use strict";

var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false,
};

function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}

function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);

  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name = parsed.name;
  var value = parsed.value;

  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  try {
    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
  } catch (e) {
    console.error(
      "set-cookie-parser encountered an error while decoding a cookie with value '" +
        value +
        "'. Set options.decodeValues to false to disable this feature.",
      e
    );
  }

  var cookie = {
    name: name,
    value: value,
  };

  parts.forEach(function (part) {
    var sides = part.split("=");
    var key = sides.shift().trimLeft().toLowerCase();
    var value = sides.join("=");
    if (key === "expires") {
      cookie.expires = new Date(value);
    } else if (key === "max-age") {
      cookie.maxAge = parseInt(value, 10);
    } else if (key === "secure") {
      cookie.secure = true;
    } else if (key === "httponly") {
      cookie.httpOnly = true;
    } else if (key === "samesite") {
      cookie.sameSite = value;
    } else {
      cookie[key] = value;
    }
  });

  return cookie;
}

function parseNameValuePair(nameValuePairStr) {
  // Parses name-value-pair according to rfc6265bis draft

  var name = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
  } else {
    value = nameValuePairStr;
  }

  return { name: name, value: value };
}

function parse(input, options) {
  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }

  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      // for fetch responses - they combine headers of the same type in the headers array,
      // but getSetCookie returns an uncombined array
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      // fast-path for node.js (which automatically normalizes header names to lower-case
      input = input.headers["set-cookie"];
    } else {
      // slow-path for other environments - see #25
      var sch =
        input.headers[
          Object.keys(input.headers).find(function (key) {
            return key.toLowerCase() === "set-cookie";
          })
        ];
      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
      if (!sch && input.headers.cookie && !options.silent) {
        console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        );
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }

  options = options
    ? Object.assign({}, defaultParseOptions, options)
    : defaultParseOptions;

  if (!options.map) {
    return input.filter(isNonEmptyString).map(function (str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
      var cookie = parseString(str, options);
      cookies[cookie.name] = cookie;
      return cookies;
    }, cookies);
  }
}

/*
  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
  that are within a single set-cookie field-value, such as in the Expires portion.

  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
  React Native's fetch does this for *every* header, including set-cookie.

  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
*/
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }

  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;

  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }

  function notSpecialChar() {
    ch = cookiesString.charAt(pos);

    return ch !== "=" && ch !== ";" && ch !== ",";
  }

  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;

    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        // ',' is a cookie separator if we have later first '=', not ';' or ','
        lastComma = pos;
        pos += 1;

        skipWhitespace();
        nextStart = pos;

        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }

        // currently special character
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          // we found cookies separator
          cookiesSeparatorFound = true;
          // pos is inside the next cookie, so back up and return it.
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          // in param ',' or param separator ';',
          // we continue from that comma
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }

    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }

  return cookiesStrings;
}

module.exports = parse;
module.exports.parse = parse;
module.exports.parseString = parseString;
module.exports.splitCookiesString = splitCookiesString;

},{}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Errors: true,
  SPEC: true
};
exports.SPEC = exports.Errors = void 0;
var _contract = require("./contract.js");
Object.keys(_contract).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _contract[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _contract[key];
    }
  });
});
var Errors_1 = _interopRequireWildcard(require("./errors.js"));
exports.Errors = Errors_1;
var SPEC_1 = _interopRequireWildcard(require("./components.js"));
exports.SPEC = SPEC_1;
var _nonspec = require("./nonspec.js");
Object.keys(_nonspec).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _nonspec[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _nonspec[key];
    }
  });
});
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

},{"./components.js":68,"./contract.js":69,"./errors.js":70,"./nonspec.js":72}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ETransactionVersion3 = exports.ETransactionVersion2 = exports.ETransactionVersion = exports.ETransactionType = exports.ETransactionStatus = exports.ETransactionFinalityStatus = exports.ETransactionExecutionStatus = exports.ESimulationFlag = exports.EDataAvailabilityMode = exports.EDAMode = exports.EBlockTag = void 0;
// Enums Derived From Spec Types (require manual check for changes)
const ETransactionType = exports.ETransactionType = {
  DECLARE: 'DECLARE',
  DEPLOY: 'DEPLOY',
  DEPLOY_ACCOUNT: 'DEPLOY_ACCOUNT',
  INVOKE: 'INVOKE',
  L1_HANDLER: 'L1_HANDLER'
};
const ESimulationFlag = exports.ESimulationFlag = {
  SKIP_VALIDATE: 'SKIP_VALIDATE',
  SKIP_FEE_CHARGE: 'SKIP_FEE_CHARGE'
};
const ETransactionStatus = exports.ETransactionStatus = {
  RECEIVED: 'RECEIVED',
  REJECTED: 'REJECTED',
  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',
  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1'
};
const ETransactionFinalityStatus = exports.ETransactionFinalityStatus = {
  ACCEPTED_ON_L2: 'ACCEPTED_ON_L2',
  ACCEPTED_ON_L1: 'ACCEPTED_ON_L1'
};
const ETransactionExecutionStatus = exports.ETransactionExecutionStatus = {
  SUCCEEDED: 'SUCCEEDED',
  REVERTED: 'REVERTED'
};
const EBlockTag = exports.EBlockTag = {
  LATEST: 'latest',
  PENDING: 'pending'
};
// 'L1' | 'L2'
const EDataAvailabilityMode = exports.EDataAvailabilityMode = {
  L1: 'L1',
  L2: 'L2'
};
// 0 | 1
const EDAMode = exports.EDAMode = {
  L1: 0,
  L2: 1
};
/**
 * V_ Transaction versions HexString
 * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)
 */
const ETransactionVersion = exports.ETransactionVersion = {
  V0: '0x0',
  V1: '0x1',
  V2: '0x2',
  V3: '0x3',
  F0: '0x100000000000000000000000000000000',
  F1: '0x100000000000000000000000000000001',
  F2: '0x100000000000000000000000000000002',
  F3: '0x100000000000000000000000000000003'
};
/**
 * Old Transaction Versions
 */
const ETransactionVersion2 = exports.ETransactionVersion2 = {
  V0: '0x0',
  V1: '0x1',
  V2: '0x2',
  F0: '0x100000000000000000000000000000000',
  F1: '0x100000000000000000000000000000001',
  F2: '0x100000000000000000000000000000002'
};
/**
 * V3 Transaction Versions
 */
const ETransactionVersion3 = exports.ETransactionVersion3 = {
  V3: '0x3',
  F3: '0x100000000000000000000000000000003'
};

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  API: true,
  WALLET_API: true
};
exports.WALLET_API = exports.API = void 0;
var API_1 = _interopRequireWildcard(require("./api/index.js"));
exports.API = API_1;
Object.keys(API_1).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === API_1[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return API_1[key];
    }
  });
});
var WALLET_API_1 = _interopRequireWildcard(require("./wallet-api/index.js"));
exports.WALLET_API = WALLET_API_1;
Object.keys(WALLET_API_1).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === WALLET_API_1[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return WALLET_API_1[key];
    }
  });
});
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

},{"./api/index.js":71,"./wallet-api/index.js":79}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Permission = void 0;
const Permission = exports.Permission = {
  ACCOUNTS: 'accounts'
};

},{}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _constants = require("./constants.js");
Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constants[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});
var _typedData = require("./typedData.js");
Object.keys(_typedData).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _typedData[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _typedData[key];
    }
  });
});
var _StarknetWindowObject = require("./StarknetWindowObject.js");
Object.keys(_StarknetWindowObject).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _StarknetWindowObject[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _StarknetWindowObject[key];
    }
  });
});
var _components = require("./components.js");
Object.keys(_components).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _components[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _components[key];
    }
  });
});
var _methods = require("./methods.js");
Object.keys(_methods).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _methods[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _methods[key];
    }
  });
});
var _events = require("./events.js");
Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _events[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _events[key];
    }
  });
});
var _errors = require("./errors.js");
Object.keys(_errors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _errors[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _errors[key];
    }
  });
});

},{"./StarknetWindowObject.js":74,"./components.js":75,"./constants.js":76,"./errors.js":77,"./events.js":78,"./methods.js":80,"./typedData.js":81}],80:[function(require,module,exports){
"use strict";

var _constants = require("./constants.js");
var Errors = _interopRequireWildcard(require("./errors.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

},{"./constants.js":76,"./errors.js":77}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypedDataRevision = void 0;
const TypedDataRevision = exports.TypedDataRevision = {
  ACTIVE: '1',
  LEGACY: '0'
};

},{}],82:[function(require,module,exports){
/*!
 * Copyright (c) 2015-2020, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";

const punycode = require("punycode/");
const urlParse = require("url-parse");
const pubsuffix = require("./pubsuffix-psl");
const Store = require("./store").Store;
const MemoryCookieStore = require("./memstore").MemoryCookieStore;
const pathMatch = require("./pathMatch").pathMatch;
const validators = require("./validators.js");
const VERSION = require("./version");
const {
  fromCallback
} = require("universalify");
const {
  getCustomInspectSymbol
} = require("./utilHelper");

// From RFC6265 S4.1.1
// note that it excludes \x3B ";"
const COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
const CONTROL_CHARS = /[\x00-\x1F]/;

// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
// the "relaxed" mode, see:
// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
const TERMINATORS = ["\n", "\r", "\0"];

// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
// Note ';' is \x3B
const PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

// date-time parsing constants (RFC6265 S5.1.1)

const DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
const MONTH_TO_NUM = {
  jan: 0,
  feb: 1,
  mar: 2,
  apr: 3,
  may: 4,
  jun: 5,
  jul: 6,
  aug: 7,
  sep: 8,
  oct: 9,
  nov: 10,
  dec: 11
};
const MAX_TIME = 2147483647000; // 31-bit max
const MIN_TIME = 0; // 31-bit min
const SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
function checkSameSiteContext(value) {
  validators.validate(validators.isNonEmptyString(value), value);
  const context = String(value).toLowerCase();
  if (context === "none" || context === "lax" || context === "strict") {
    return context;
  } else {
    return null;
  }
}
const PrefixSecurityEnum = Object.freeze({
  SILENT: "silent",
  STRICT: "strict",
  DISABLED: "unsafe-disabled"
});

// Dumped from ip-regex@4.0.0, with the following changes:
// * all capturing groups converted to non-capturing -- "(?:)"
// * support for IPv6 Scoped Literal ("%eth1") removed
// * lowercase hexadecimal only
const IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
const IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);

/*
 * Parses a Natural number (i.e., non-negative integer) with either the
 *    <min>*<max>DIGIT ( non-digit *OCTET )
 * or
 *    <min>*<max>DIGIT
 * grammar (RFC6265 S5.1.1).
 *
 * The "trailingOK" boolean controls if the grammar accepts a
 * "( non-digit *OCTET )" trailer.
 */
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  let count = 0;
  while (count < token.length) {
    const c = token.charCodeAt(count);
    // "non-digit = %x00-2F / %x3A-FF"
    if (c <= 0x2f || c >= 0x3a) {
      break;
    }
    count++;
  }

  // constrain to a minimum and maximum number of digits.
  if (count < minDigits || count > maxDigits) {
    return null;
  }
  if (!trailingOK && count != token.length) {
    return null;
  }
  return parseInt(token.substr(0, count), 10);
}
function parseTime(token) {
  const parts = token.split(":");
  const result = [0, 0, 0];

  /* RF6256 S5.1.1:
   *      time            = hms-time ( non-digit *OCTET )
   *      hms-time        = time-field ":" time-field ":" time-field
   *      time-field      = 1*2DIGIT
   */

  if (parts.length !== 3) {
    return null;
  }
  for (let i = 0; i < 3; i++) {
    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
    // followed by "( non-digit *OCTET )" so therefore the last time-field can
    // have a trailer
    const trailingOK = i == 2;
    const num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) {
      return null;
    }
    result[i] = num;
  }
  return result;
}
function parseMonth(token) {
  token = String(token).substr(0, 3).toLowerCase();
  const num = MONTH_TO_NUM[token];
  return num >= 0 ? num : null;
}

/*
 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
 */
function parseDate(str) {
  if (!str) {
    return;
  }

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  const tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }
  let hour = null;
  let minute = null;
  let second = null;
  let dayOfMonth = null;
  let month = null;
  let year = null;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].trim();
    if (!token.length) {
      continue;
    }
    let result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (second === null) {
      result = parseTime(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (dayOfMonth === null) {
      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 1, 2, true);
      if (result !== null) {
        dayOfMonth = result;
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (month === null) {
      result = parseMonth(token);
      if (result !== null) {
        month = result;
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the
     * year production, set the found-year flag and set the year-value to the
     * number denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (year === null) {
      // "year = 2*4DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 2, 4, true);
      if (result !== null) {
        year = result;
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (year >= 70 && year <= 99) {
          year += 1900;
        } else if (year >= 0 && year <= 69) {
          year += 2000;
        }
      }
    }
  }

  /* RFC 6265 S5.1.1
   * "5. Abort these steps and fail to parse the cookie-date if:
   *     *  at least one of the found-day-of-month, found-month, found-
   *        year, or found-time flags is not set,
   *     *  the day-of-month-value is less than 1 or greater than 31,
   *     *  the year-value is less than 1601,
   *     *  the hour-value is greater than 23,
   *     *  the minute-value is greater than 59, or
   *     *  the second-value is greater than 59.
   *     (Note that leap seconds cannot be represented in this syntax.)"
   *
   * So, in order as above:
   */
  if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
    return;
  }
  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}
function formatDate(date) {
  validators.validate(validators.isDate(date), date);
  return date.toUTCString();
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./, ""); // S4.1.2.3 & S5.2.3: ignore leading .

  if (IP_V6_REGEX_OBJECT.test(str)) {
    str = str.replace("[", "").replace("]", "");
  }

  // convert to IDN if any non-ASCII characters
  if (punycode && /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }
  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * S5.1.3:
   * "A string domain-matches a given domain string if at least one of the
   * following conditions hold:"
   *
   * " o The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)"
   */
  if (str == domStr) {
    return true;
  }

  /* " o All of the following [three] conditions hold:" */

  /* "* The domain string is a suffix of the string" */
  const idx = str.lastIndexOf(domStr);
  if (idx <= 0) {
    return false; // it's a non-match (-1) or prefix (0)
  }

  // next, check it's a proper suffix
  // e.g., "a.b.c".indexOf("b.c") === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) {
    return false; // it's not a suffix
  }

  /* "  * The last character of the string that is not included in the
   * domain string is a %x2E (".") character." */
  if (str.substr(idx - 1, 1) !== ".") {
    return false; // doesn't align on "."
  }

  /* "  * The string is a host name (i.e., not an IP address)." */
  if (IP_REGEX_LOWERCASE.test(str)) {
    return false; // it's an IP address
  }
  return true;
}

// RFC6265 S5.1.4 Paths and Path-Match

/*
 * "The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:"
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // "2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
  if (!path || path.substr(0, 1) !== "/") {
    return "/";
  }

  // "3. If the uri-path contains no more than one %x2F ("/") character, output
  // %x2F ("/") and skip the remaining step."
  if (path === "/") {
    return path;
  }
  const rightSlash = path.lastIndexOf("/");
  if (rightSlash === 0) {
    return "/";
  }

  // "4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F ("/")."
  return path.slice(0, rightSlash);
}
function trimTerminator(str) {
  if (validators.isEmptyString(str)) return str;
  for (let t = 0; t < TERMINATORS.length; t++) {
    const terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx !== -1) {
      str = str.substr(0, terminatorIdx);
    }
  }
  return str;
}
function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);
  validators.validate(validators.isString(cookiePair), cookiePair);
  let firstEq = cookiePair.indexOf("=");
  if (looseMode) {
    if (firstEq === 0) {
      // '=' is immediately at start
      cookiePair = cookiePair.substr(1);
      firstEq = cookiePair.indexOf("="); // might still need to split on '='
    }
  } else {
    // non-loose mode
    if (firstEq <= 0) {
      // no '=' or is at start
      return; // needs to have non-empty "cookie-name"
    }
  }
  let cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq + 1).trim();
  }
  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return;
  }
  const c = new Cookie();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}
function parse(str, options) {
  if (!options || typeof options !== "object") {
    options = {};
  }
  if (validators.isEmptyString(str) || !validators.isString(str)) {
    return null;
  }
  str = str.trim();

  // We use a regex to parse the "name-value-pair" part of S5.2
  const firstSemi = str.indexOf(";"); // S5.2 step 1
  const cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
  const c = parseCookiePair(cookiePair, !!options.loose);
  if (!c) {
    return;
  }
  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (";") in question)." plus later on in the same section
  // "discard the first ";" and trim".
  const unparsed = str.slice(firstSemi + 1).trim();

  // "If the unparsed-attributes string is empty, skip the rest of these
  // steps."
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items "[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections" for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the "attribute-value of the last attribute in the
   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  const cookie_avs = unparsed.split(";");
  while (cookie_avs.length) {
    const av = cookie_avs.shift().trim();
    if (av.length === 0) {
      // happens if ";;" appears
      continue;
    }
    const av_sep = av.indexOf("=");
    let av_key, av_value;
    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0, av_sep);
      av_value = av.substr(av_sep + 1);
    }
    av_key = av_key.trim().toLowerCase();
    if (av_value) {
      av_value = av_value.trim();
    }
    switch (av_key) {
      case "expires":
        // S5.2.1
        if (av_value) {
          const exp = parseDate(av_value);
          // "If the attribute-value failed to parse as a cookie date, ignore the
          // cookie-av."
          if (exp) {
            // over and underflow not realistically a concern: V8's getTime() seems to
            // store something larger than a 32-bit time_t (even with 32-bit node)
            c.expires = exp;
          }
        }
        break;
      case "max-age":
        // S5.2.2
        if (av_value) {
          // "If the first character of the attribute-value is not a DIGIT or a "-"
          // character ...[or]... If the remainder of attribute-value contains a
          // non-DIGIT character, ignore the cookie-av."
          if (/^-?[0-9]+$/.test(av_value)) {
            const delta = parseInt(av_value, 10);
            // "If delta-seconds is less than or equal to zero (0), let expiry-time
            // be the earliest representable date and time."
            c.setMaxAge(delta);
          }
        }
        break;
      case "domain":
        // S5.2.3
        // "If the attribute-value is empty, the behavior is undefined.  However,
        // the user agent SHOULD ignore the cookie-av entirely."
        if (av_value) {
          // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
          // (".") character."
          const domain = av_value.trim().replace(/^\./, "");
          if (domain) {
            // "Convert the cookie-domain to lower case."
            c.domain = domain.toLowerCase();
          }
        }
        break;
      case "path":
        // S5.2.4
        /*
         * "If the attribute-value is empty or if the first character of the
         * attribute-value is not %x2F ("/"):
         *   Let cookie-path be the default-path.
         * Otherwise:
         *   Let cookie-path be the attribute-value."
         *
         * We'll represent the default-path as null since it depends on the
         * context of the parsing.
         */
        c.path = av_value && av_value[0] === "/" ? av_value : null;
        break;
      case "secure":
        // S5.2.5
        /*
         * "If the attribute-name case-insensitively matches the string "Secure",
         * the user agent MUST append an attribute to the cookie-attribute-list
         * with an attribute-name of Secure and an empty attribute-value."
         */
        c.secure = true;
        break;
      case "httponly":
        // S5.2.6 -- effectively the same as 'secure'
        c.httpOnly = true;
        break;
      case "samesite":
        // RFC6265bis-02 S5.3.7
        const enforcement = av_value ? av_value.toLowerCase() : "";
        switch (enforcement) {
          case "strict":
            c.sameSite = "strict";
            break;
          case "lax":
            c.sameSite = "lax";
            break;
          case "none":
            c.sameSite = "none";
            break;
          default:
            c.sameSite = undefined;
            break;
        }
        break;
      default:
        c.extensions = c.extensions || [];
        c.extensions.push(av);
        break;
    }
  }
  return c;
}

/**
 *  If the cookie-name begins with a case-sensitive match for the
 *  string "__Secure-", abort these steps and ignore the cookie
 *  entirely unless the cookie's secure-only-flag is true.
 * @param cookie
 * @returns boolean
 */
function isSecurePrefixConditionMet(cookie) {
  validators.validate(validators.isObject(cookie), cookie);
  return !cookie.key.startsWith("__Secure-") || cookie.secure;
}

/**
 *  If the cookie-name begins with a case-sensitive match for the
 *  string "__Host-", abort these steps and ignore the cookie
 *  entirely unless the cookie meets all the following criteria:
 *    1.  The cookie's secure-only-flag is true.
 *    2.  The cookie's host-only-flag is true.
 *    3.  The cookie-attribute-list contains an attribute with an
 *        attribute-name of "Path", and the cookie's path is "/".
 * @param cookie
 * @returns boolean
 */
function isHostPrefixConditionMet(cookie) {
  validators.validate(validators.isObject(cookie));
  return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
}

// avoid the V8 deoptimization monster!
function jsonParse(str) {
  let obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}
function fromJSON(str) {
  if (!str || validators.isEmptyString(str)) {
    return null;
  }
  let obj;
  if (typeof str === "string") {
    obj = jsonParse(str);
    if (obj instanceof Error) {
      return null;
    }
  } else {
    // assume it's an Object
    obj = str;
  }
  const c = new Cookie();
  for (let i = 0; i < Cookie.serializableProperties.length; i++) {
    const prop = Cookie.serializableProperties[i];
    if (obj[prop] === undefined || obj[prop] === cookieDefaults[prop]) {
      continue; // leave as prototype default
    }
    if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
      if (obj[prop] === null) {
        c[prop] = null;
      } else {
        c[prop] = obj[prop] == "Infinity" ? "Infinity" : new Date(obj[prop]);
      }
    } else {
      c[prop] = obj[prop];
    }
  }
  return c;
}

/* Section 5.4 part 2:
 * "*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times."
 */

function cookieCompare(a, b) {
  validators.validate(validators.isObject(a), a);
  validators.validate(validators.isObject(b), b);
  let cmp = 0;

  // descending for length: b CMP a
  const aPathLen = a.path ? a.path.length : 0;
  const bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }

  // ascending for time: a CMP b
  const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
  const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }

  // break ties for the same millisecond (precision of JavaScript's clock)
  cmp = a.creationIndex - b.creationIndex;
  return cmp;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  validators.validate(validators.isString(path));
  if (path === "/") {
    return ["/"];
  }
  const permutations = [path];
  while (path.length > 1) {
    const lindex = path.lastIndexOf("/");
    if (lindex === 0) {
      break;
    }
    path = path.substr(0, lindex);
    permutations.push(path);
  }
  permutations.push("/");
  return permutations;
}
function getCookieContext(url) {
  if (url instanceof Object) {
    return url;
  }
  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
  // Therefore, we will just skip decoding for such URIs.
  try {
    url = decodeURI(url);
  } catch (err) {
    // Silently swallow error
  }
  return urlParse(url);
}
const cookieDefaults = {
  // the order in which the RFC has them:
  key: "",
  value: "",
  expires: "Infinity",
  maxAge: null,
  domain: null,
  path: null,
  secure: false,
  httpOnly: false,
  extensions: null,
  // set by the CookieJar:
  hostOnly: null,
  pathIsDefault: null,
  creation: null,
  lastAccessed: null,
  sameSite: undefined
};
class Cookie {
  constructor(options = {}) {
    const customInspectSymbol = getCustomInspectSymbol();
    if (customInspectSymbol) {
      this[customInspectSymbol] = this.inspect;
    }
    Object.assign(this, cookieDefaults, options);
    this.creation = this.creation || new Date();

    // used to break creation ties in cookieCompare():
    Object.defineProperty(this, "creationIndex", {
      configurable: false,
      enumerable: false,
      // important for assert.deepEqual checks
      writable: true,
      value: ++Cookie.cookiesCreated
    });
  }
  inspect() {
    const now = Date.now();
    const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
    const createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?";
    const accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
    return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
  }
  toJSON() {
    const obj = {};
    for (const prop of Cookie.serializableProperties) {
      if (this[prop] === cookieDefaults[prop]) {
        continue; // leave as prototype default
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (this[prop] === null) {
          obj[prop] = null;
        } else {
          obj[prop] = this[prop] == "Infinity" // intentionally not ===
          ? "Infinity" : this[prop].toISOString();
        }
      } else if (prop === "maxAge") {
        if (this[prop] !== null) {
          // again, intentionally not ===
          obj[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
        }
      } else {
        if (this[prop] !== cookieDefaults[prop]) {
          obj[prop] = this[prop];
        }
      }
    }
    return obj;
  }
  clone() {
    return fromJSON(this.toJSON());
  }
  validate() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false; // "Max-Age=" non-zero-digit *DIGIT
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    const cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
      }
      const suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        // it's a public suffix
        return false;
      }
    }
    return true;
  }
  setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || "Infinity";
    }
  }
  setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString(); // so JSON.stringify() works
    } else {
      this.maxAge = age;
    }
  }
  cookieString() {
    let val = this.value;
    if (val == null) {
      val = "";
    }
    if (this.key === "") {
      return val;
    }
    return `${this.key}=${val}`;
  }

  // gives Set-Cookie header format
  toString() {
    let str = this.cookieString();
    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += `; Expires=${formatDate(this.expires)}`;
      } else {
        str += `; Expires=${this.expires}`;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += `; Max-Age=${this.maxAge}`;
    }
    if (this.domain && !this.hostOnly) {
      str += `; Domain=${this.domain}`;
    }
    if (this.path) {
      str += `; Path=${this.path}`;
    }
    if (this.secure) {
      str += "; Secure";
    }
    if (this.httpOnly) {
      str += "; HttpOnly";
    }
    if (this.sameSite && this.sameSite !== "none") {
      const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
      str += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
    }
    if (this.extensions) {
      this.extensions.forEach(ext => {
        str += `; ${ext}`;
      });
    }
    return str;
  }

  // TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere)
  // S5.3 says to give the "latest representable date" for which we use Infinity
  // For "expired" we use 0
  TTL(now) {
    /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
     * attribute, the Max-Age attribute has precedence and controls the
     * expiration date of the cookie.
     * (Concurs with S5.3 step 3)
     */
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
    }
    let expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }
      if (expires == Infinity) {
        return Infinity;
      }
      return expires.getTime() - (now || Date.now());
    }
    return Infinity;
  }

  // expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere)
  expiryTime(now) {
    if (this.maxAge != null) {
      const relativeTo = now || this.creation || new Date();
      const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
      return relativeTo.getTime() + age;
    }
    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  }

  // expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
  // elsewhere), except it returns a Date
  expiryDate(now) {
    const millisec = this.expiryTime(now);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  }

  // This replaces the "persistent-flag" parts of S5.3 step 3
  isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  }

  // Mostly S5.1.2 and S5.2.3:
  canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  }
  cdomain() {
    return this.canonicalizedDomain();
  }
}
Cookie.cookiesCreated = 0;
Cookie.parse = parse;
Cookie.fromJSON = fromJSON;
Cookie.serializableProperties = Object.keys(cookieDefaults);
Cookie.sameSiteLevel = {
  strict: 3,
  lax: 2,
  none: 1
};
Cookie.sameSiteCanonical = {
  strict: "Strict",
  lax: "Lax"
};
function getNormalizedPrefixSecurity(prefixSecurity) {
  if (prefixSecurity != null) {
    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    /* The three supported options */
    switch (normalizedPrefixSecurity) {
      case PrefixSecurityEnum.STRICT:
      case PrefixSecurityEnum.SILENT:
      case PrefixSecurityEnum.DISABLED:
        return normalizedPrefixSecurity;
    }
  }
  /* Default is SILENT */
  return PrefixSecurityEnum.SILENT;
}
class CookieJar {
  constructor(store, options = {
    rejectPublicSuffixes: true
  }) {
    if (typeof options === "boolean") {
      options = {
        rejectPublicSuffixes: options
      };
    }
    validators.validate(validators.isObject(options), options);
    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    this.enableLooseMode = !!options.looseMode;
    this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
    this.store = store || new MemoryCookieStore();
    this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
    this._cloneSync = syncWrap("clone");
    this._importCookiesSync = syncWrap("_importCookies");
    this.getCookiesSync = syncWrap("getCookies");
    this.getCookieStringSync = syncWrap("getCookieString");
    this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
    this.removeAllCookiesSync = syncWrap("removeAllCookies");
    this.setCookieSync = syncWrap("setCookie");
    this.serializeSync = syncWrap("serialize");
  }
  setCookie(cookie, url, options, cb) {
    validators.validate(validators.isNonEmptyString(url), cb, options);
    let err;
    if (validators.isFunction(url)) {
      cb = url;
      return cb(new Error("No URL was specified"));
    }
    const context = getCookieContext(url);
    if (validators.isFunction(options)) {
      cb = options;
      options = {};
    }
    validators.validate(validators.isFunction(cb), cb);
    if (!validators.isNonEmptyString(cookie) && !validators.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
      return cb(null);
    }
    const host = canonicalDomain(context.hostname);
    const loose = options.loose || this.enableLooseMode;
    let sameSiteContext = null;
    if (options.sameSiteContext) {
      sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      if (!sameSiteContext) {
        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }

    // S5.3 step 1
    if (typeof cookie === "string" || cookie instanceof String) {
      cookie = Cookie.parse(cookie, {
        loose: loose
      });
      if (!cookie) {
        err = new Error("Cookie failed to parse");
        return cb(options.ignoreError ? null : err);
      }
    } else if (!(cookie instanceof Cookie)) {
      // If you're seeing this error, and are passing in a Cookie object,
      // it *might* be a Cookie object from another loaded version of tough-cookie.
      err = new Error("First argument to setCookie must be a Cookie object or string");
      return cb(options.ignoreError ? null : err);
    }

    // S5.3 step 2
    const now = options.now || new Date(); // will assign later to save effort in the face of errors

    // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

    // S5.3 step 4: NOOP; domain is null by default

    // S5.3 step 5: public suffixes
    if (this.rejectPublicSuffixes && cookie.domain) {
      const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
        allowSpecialUseDomain: this.allowSpecialUseDomain,
        ignoreError: options.ignoreError
      });
      if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
        // e.g. "com"
        err = new Error("Cookie has domain set to a public suffix");
        return cb(options.ignoreError ? null : err);
      }
    }

    // S5.3 step 6:
    if (cookie.domain) {
      if (!domainMatch(host, cookie.cdomain(), false)) {
        err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`);
        return cb(options.ignoreError ? null : err);
      }
      if (cookie.hostOnly == null) {
        // don't reset if already set
        cookie.hostOnly = false;
      }
    } else {
      cookie.hostOnly = true;
      cookie.domain = host;
    }

    //S5.2.4 If the attribute-value is empty or if the first character of the
    //attribute-value is not %x2F ("/"):
    //Let cookie-path be the default-path.
    if (!cookie.path || cookie.path[0] !== "/") {
      cookie.path = defaultPath(context.pathname);
      cookie.pathIsDefault = true;
    }

    // S5.3 step 8: NOOP; secure attribute
    // S5.3 step 9: NOOP; httpOnly attribute

    // S5.3 step 10
    if (options.http === false && cookie.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }

    // 6252bis-02 S5.4 Step 13 & 14:
    if (cookie.sameSite !== "none" && cookie.sameSite !== undefined && sameSiteContext) {
      // "If the cookie's "same-site-flag" is not "None", and the cookie
      //  is being set from a context whose "site for cookies" is not an
      //  exact match for request-uri's host's registered domain, then
      //  abort these steps and ignore the newly created cookie entirely."
      if (sameSiteContext === "none") {
        err = new Error("Cookie is SameSite but this is a cross-origin request");
        return cb(options.ignoreError ? null : err);
      }
    }

    /* 6265bis-02 S5.4 Steps 15 & 16 */
    const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
    const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
    /* If prefix checking is not disabled ...*/
    if (!prefixSecurityDisabled) {
      let errorFound = false;
      let errorMsg;
      /* Check secure prefix condition */
      if (!isSecurePrefixConditionMet(cookie)) {
        errorFound = true;
        errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
      } else if (!isHostPrefixConditionMet(cookie)) {
        /* Check host prefix condition */
        errorFound = true;
        errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
      }
      if (errorFound) {
        return cb(options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg));
      }
    }
    const store = this.store;
    if (!store.updateCookie) {
      store.updateCookie = function (oldCookie, newCookie, cb) {
        this.putCookie(newCookie, cb);
      };
    }
    function withCookie(err, oldCookie) {
      if (err) {
        return cb(err);
      }
      const next = function (err) {
        if (err) {
          return cb(err);
        } else {
          cb(null, cookie);
        }
      };
      if (oldCookie) {
        // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
        // domain, and path as the newly created cookie:"
        if (options.http === false && oldCookie.httpOnly) {
          // step 11.2
          err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err);
        }
        cookie.creation = oldCookie.creation; // step 11.3
        cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
        cookie.lastAccessed = now;
        // Step 11.4 (delete cookie) is implied by just setting the new one:
        store.updateCookie(oldCookie, cookie, next); // step 12
      } else {
        cookie.creation = cookie.lastAccessed = now;
        store.putCookie(cookie, next); // step 12
      }
    }
    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
  }

  // RFC6365 S5.4
  getCookies(url, options, cb) {
    validators.validate(validators.isNonEmptyString(url), cb, url);
    const context = getCookieContext(url);
    if (validators.isFunction(options)) {
      cb = options;
      options = {};
    }
    validators.validate(validators.isObject(options), cb, options);
    validators.validate(validators.isFunction(cb), cb);
    const host = canonicalDomain(context.hostname);
    const path = context.pathname || "/";
    let secure = options.secure;
    if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
      secure = true;
    }
    let sameSiteLevel = 0;
    if (options.sameSiteContext) {
      const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
      sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
      if (!sameSiteLevel) {
        return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
      }
    }
    let http = options.http;
    if (http == null) {
      http = true;
    }
    const now = options.now || Date.now();
    const expireCheck = options.expire !== false;
    const allPaths = !!options.allPaths;
    const store = this.store;
    function matchingCookie(c) {
      // "Either:
      //   The cookie's host-only-flag is true and the canonicalized
      //   request-host is identical to the cookie's domain.
      // Or:
      //   The cookie's host-only-flag is false and the canonicalized
      //   request-host domain-matches the cookie's domain."
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }

      // "The request-uri's path path-matches the cookie's path."
      if (!allPaths && !pathMatch(path, c.path)) {
        return false;
      }

      // "If the cookie's secure-only-flag is true, then the request-uri's
      // scheme must denote a "secure" protocol"
      if (c.secure && !secure) {
        return false;
      }

      // "If the cookie's http-only-flag is true, then exclude the cookie if the
      // cookie-string is being generated for a "non-HTTP" API"
      if (c.httpOnly && !http) {
        return false;
      }

      // RFC6265bis-02 S5.3.7
      if (sameSiteLevel) {
        const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
        if (cookieLevel > sameSiteLevel) {
          // only allow cookies at or below the request level
          return false;
        }
      }

      // deferred from S5.3
      // non-RFC: allow retention of expired cookies by choice
      if (expireCheck && c.expiryTime() <= now) {
        store.removeCookie(c.domain, c.path, c.key, () => {}); // result ignored
        return false;
      }
      return true;
    }
    store.findCookies(host, allPaths ? null : path, this.allowSpecialUseDomain, (err, cookies) => {
      if (err) {
        return cb(err);
      }
      cookies = cookies.filter(matchingCookie);

      // sorting of S5.4 part 2
      if (options.sort !== false) {
        cookies = cookies.sort(cookieCompare);
      }

      // S5.4 part 3
      const now = new Date();
      for (const cookie of cookies) {
        cookie.lastAccessed = now;
      }
      // TODO persist lastAccessed

      cb(null, cookies);
    });
  }
  getCookieString(...args) {
    const cb = args.pop();
    validators.validate(validators.isFunction(cb), cb);
    const next = function (err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.sort(cookieCompare).map(c => c.cookieString()).join("; "));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  }
  getSetCookieStrings(...args) {
    const cb = args.pop();
    validators.validate(validators.isFunction(cb), cb);
    const next = function (err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(null, cookies.map(c => {
          return c.toString();
        }));
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  }
  serialize(cb) {
    validators.validate(validators.isFunction(cb), cb);
    let type = this.store.constructor.name;
    if (validators.isObject(type)) {
      type = null;
    }

    // update README.md "Serialization Format" if you change this, please!
    const serialized = {
      // The version of tough-cookie that serialized this jar. Generally a good
      // practice since future versions can make data import decisions based on
      // known past behavior. When/if this matters, use `semver`.
      version: `tough-cookie@${VERSION}`,
      // add the store type, to make humans happy:
      storeType: type,
      // CookieJar configuration:
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      enableLooseMode: !!this.enableLooseMode,
      allowSpecialUseDomain: !!this.allowSpecialUseDomain,
      prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
      // this gets filled from getAllCookies:
      cookies: []
    };
    if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
      return cb(new Error("store does not support getAllCookies and cannot be serialized"));
    }
    this.store.getAllCookies((err, cookies) => {
      if (err) {
        return cb(err);
      }
      serialized.cookies = cookies.map(cookie => {
        // convert to serialized 'raw' cookies
        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;

        // Remove the index so new ones get assigned during deserialization
        delete cookie.creationIndex;
        return cookie;
      });
      return cb(null, serialized);
    });
  }
  toJSON() {
    return this.serializeSync();
  }

  // use the class method CookieJar.deserialize instead of calling this directly
  _importCookies(serialized, cb) {
    let cookies = serialized.cookies;
    if (!cookies || !Array.isArray(cookies)) {
      return cb(new Error("serialized jar has no cookies array"));
    }
    cookies = cookies.slice(); // do not modify the original

    const putNext = err => {
      if (err) {
        return cb(err);
      }
      if (!cookies.length) {
        return cb(err, this);
      }
      let cookie;
      try {
        cookie = fromJSON(cookies.shift());
      } catch (e) {
        return cb(e);
      }
      if (cookie === null) {
        return putNext(null); // skip this cookie
      }
      this.store.putCookie(cookie, putNext);
    };
    putNext();
  }
  clone(newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }
    this.serialize((err, serialized) => {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(serialized, newStore, cb);
    });
  }
  cloneSync(newStore) {
    if (arguments.length === 0) {
      return this._cloneSync();
    }
    if (!newStore.synchronous) {
      throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
    }
    return this._cloneSync(newStore);
  }
  removeAllCookies(cb) {
    validators.validate(validators.isFunction(cb), cb);
    const store = this.store;

    // Check that the store implements its own removeAllCookies(). The default
    // implementation in Store will immediately call the callback with a "not
    // implemented" Error.
    if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
      return store.removeAllCookies(cb);
    }
    store.getAllCookies((err, cookies) => {
      if (err) {
        return cb(err);
      }
      if (cookies.length === 0) {
        return cb(null);
      }
      let completedCount = 0;
      const removeErrors = [];
      function removeCookieCb(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }
        completedCount++;
        if (completedCount === cookies.length) {
          return cb(removeErrors.length ? removeErrors[0] : null);
        }
      }
      cookies.forEach(cookie => {
        store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
      });
    });
  }
  static deserialize(strOrObj, store, cb) {
    if (arguments.length !== 3) {
      // store is optional
      cb = store;
      store = null;
    }
    validators.validate(validators.isFunction(cb), cb);
    let serialized;
    if (typeof strOrObj === "string") {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }
    const jar = new CookieJar(store, {
      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
      looseMode: serialized.enableLooseMode,
      allowSpecialUseDomain: serialized.allowSpecialUseDomain,
      prefixSecurity: serialized.prefixSecurity
    });
    jar._importCookies(serialized, err => {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  }
  static deserializeSync(strOrObj, store) {
    const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
    const jar = new CookieJar(store, {
      rejectPublicSuffixes: serialized.rejectPublicSuffixes,
      looseMode: serialized.enableLooseMode
    });

    // catch this mistake early:
    if (!jar.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    jar._importCookiesSync(serialized);
    return jar;
  }
}
CookieJar.fromJSON = CookieJar.deserializeSync;
["_importCookies", "clone", "getCookies", "getCookieString", "getSetCookieStrings", "removeAllCookies", "serialize", "setCookie"].forEach(name => {
  CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
});
CookieJar.deserialize = fromCallback(CookieJar.deserialize);

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function (...args) {
    if (!this.store.synchronous) {
      throw new Error("CookieJar store is not synchronous; use async API instead.");
    }
    let syncErr, syncResult;
    this[method](...args, (err, result) => {
      syncErr = err;
      syncResult = result;
    });
    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}
exports.version = VERSION;
exports.CookieJar = CookieJar;
exports.Cookie = Cookie;
exports.Store = Store;
exports.MemoryCookieStore = MemoryCookieStore;
exports.parseDate = parseDate;
exports.formatDate = formatDate;
exports.parse = parse;
exports.fromJSON = fromJSON;
exports.domainMatch = domainMatch;
exports.defaultPath = defaultPath;
exports.pathMatch = pathMatch;
exports.getPublicSuffix = pubsuffix.getPublicSuffix;
exports.cookieCompare = cookieCompare;
exports.permuteDomain = require("./permuteDomain").permuteDomain;
exports.permutePath = permutePath;
exports.canonicalDomain = canonicalDomain;
exports.PrefixSecurityEnum = PrefixSecurityEnum;
exports.ParameterError = validators.ParameterError;

},{"./memstore":83,"./pathMatch":84,"./permuteDomain":85,"./pubsuffix-psl":86,"./store":87,"./utilHelper":88,"./validators.js":89,"./version":90,"punycode/":64,"universalify":91,"url-parse":94}],83:[function(require,module,exports){
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const { fromCallback } = require("universalify");
const Store = require("./store").Store;
const permuteDomain = require("./permuteDomain").permuteDomain;
const pathMatch = require("./pathMatch").pathMatch;
const { getCustomInspectSymbol, getUtilInspect } = require("./utilHelper");

class MemoryCookieStore extends Store {
  constructor() {
    super();
    this.synchronous = true;
    this.idx = Object.create(null);
    const customInspectSymbol = getCustomInspectSymbol();
    if (customInspectSymbol) {
      this[customInspectSymbol] = this.inspect;
    }
  }

  inspect() {
    const util = { inspect: getUtilInspect(inspectFallback) };
    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;
  }

  findCookie(domain, path, key, cb) {
    if (!this.idx[domain]) {
      return cb(null, undefined);
    }
    if (!this.idx[domain][path]) {
      return cb(null, undefined);
    }
    return cb(null, this.idx[domain][path][key] || null);
  }
  findCookies(domain, path, allowSpecialUseDomain, cb) {
    const results = [];
    if (typeof allowSpecialUseDomain === "function") {
      cb = allowSpecialUseDomain;
      allowSpecialUseDomain = true;
    }
    if (!domain) {
      return cb(null, []);
    }

    let pathMatcher;
    if (!path) {
      // null means "all paths"
      pathMatcher = function matchAll(domainIndex) {
        for (const curPath in domainIndex) {
          const pathIndex = domainIndex[curPath];
          for (const key in pathIndex) {
            results.push(pathIndex[key]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        //NOTE: we should use path-match algorithm from S5.1.4 here
        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
        Object.keys(domainIndex).forEach(cookiePath => {
          if (pathMatch(path, cookiePath)) {
            const pathIndex = domainIndex[cookiePath];
            for (const key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        });
      };
    }

    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
    const idx = this.idx;
    domains.forEach(curDomain => {
      const domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });

    cb(null, results);
  }

  putCookie(cookie, cb) {
    if (!this.idx[cookie.domain]) {
      this.idx[cookie.domain] = Object.create(null);
    }
    if (!this.idx[cookie.domain][cookie.path]) {
      this.idx[cookie.domain][cookie.path] = Object.create(null);
    }
    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    cb(null);
  }
  updateCookie(oldCookie, newCookie, cb) {
    // updateCookie() may avoid updating cookies that are identical.  For example,
    // lastAccessed may not be important to some stores and an equality
    // comparison could exclude that field.
    this.putCookie(newCookie, cb);
  }
  removeCookie(domain, path, key, cb) {
    if (
      this.idx[domain] &&
      this.idx[domain][path] &&
      this.idx[domain][path][key]
    ) {
      delete this.idx[domain][path][key];
    }
    cb(null);
  }
  removeCookies(domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  }
  removeAllCookies(cb) {
    this.idx = Object.create(null);
    return cb(null);
  }
  getAllCookies(cb) {
    const cookies = [];
    const idx = this.idx;

    const domains = Object.keys(idx);
    domains.forEach(domain => {
      const paths = Object.keys(idx[domain]);
      paths.forEach(path => {
        const keys = Object.keys(idx[domain][path]);
        keys.forEach(key => {
          if (key !== null) {
            cookies.push(idx[domain][path][key]);
          }
        });
      });
    });

    // Sort by creationIndex so deserializing retains the creation order.
    // When implementing your own store, this SHOULD retain the order too
    cookies.sort((a, b) => {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });

    cb(null, cookies);
  }
}

[
  "findCookie",
  "findCookies",
  "putCookie",
  "updateCookie",
  "removeCookie",
  "removeCookies",
  "removeAllCookies",
  "getAllCookies"
].forEach(name => {
  MemoryCookieStore.prototype[name] = fromCallback(
    MemoryCookieStore.prototype[name]
  );
});

exports.MemoryCookieStore = MemoryCookieStore;

function inspectFallback(val) {
  const domains = Object.keys(val);
  if (domains.length === 0) {
    return "[Object: null prototype] {}";
  }
  let result = "[Object: null prototype] {\n";
  Object.keys(val).forEach((domain, i) => {
    result += formatDomain(domain, val[domain]);
    if (i < domains.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += "}";
  return result;
}

function formatDomain(domainName, domainValue) {
  const indent = "  ";
  let result = `${indent}'${domainName}': [Object: null prototype] {\n`;
  Object.keys(domainValue).forEach((path, i, paths) => {
    result += formatPath(path, domainValue[path]);
    if (i < paths.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += `${indent}}`;
  return result;
}

function formatPath(pathName, pathValue) {
  const indent = "    ";
  let result = `${indent}'${pathName}': [Object: null prototype] {\n`;
  Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
    const cookie = pathValue[cookieName];
    result += `      ${cookieName}: ${cookie.inspect()}`;
    if (i < cookieNames.length - 1) {
      result += ",";
    }
    result += "\n";
  });
  result += `${indent}}`;
  return result;
}

exports.inspectFallback = inspectFallback;

},{"./pathMatch":84,"./permuteDomain":85,"./store":87,"./utilHelper":88,"universalify":91}],84:[function(require,module,exports){
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/*
 * "A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:"
 */
function pathMatch(reqPath, cookiePath) {
  // "o  The cookie-path and the request-path are identical."
  if (cookiePath === reqPath) {
    return true;
  }

  const idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    // "o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F ("/")."
    if (cookiePath.substr(-1) === "/") {
      return true;
    }

    // " o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F ("/") character."
    if (reqPath.substr(cookiePath.length, 1) === "/") {
      return true;
    }
  }

  return false;
}

exports.pathMatch = pathMatch;

},{}],85:[function(require,module,exports){
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const pubsuffix = require("./pubsuffix-psl");

// Gives the permutation of all possible domainMatch()es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.

function permuteDomain(domain, allowSpecialUseDomain) {
  const pubSuf = pubsuffix.getPublicSuffix(domain, {
    allowSpecialUseDomain: allowSpecialUseDomain
  });

  if (!pubSuf) {
    return null;
  }
  if (pubSuf == domain) {
    return [domain];
  }

  // Nuke trailing dot
  if (domain.slice(-1) == ".") {
    domain = domain.slice(0, -1);
  }

  const prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
  const parts = prefix.split(".").reverse();
  let cur = pubSuf;
  const permutations = [cur];
  while (parts.length) {
    cur = `${parts.shift()}.${cur}`;
    permutations.push(cur);
  }
  return permutations;
}

exports.permuteDomain = permuteDomain;

},{"./pubsuffix-psl":86}],86:[function(require,module,exports){
/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
const psl = require("psl");

// RFC 6761
const SPECIAL_USE_DOMAINS = [
  "local",
  "example",
  "invalid",
  "localhost",
  "test"
];

const SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];

function getPublicSuffix(domain, options = {}) {
  const domainParts = domain.split(".");
  const topLevelDomain = domainParts[domainParts.length - 1];
  const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
  const ignoreError = !!options.ignoreError;

  if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    if (domainParts.length > 1) {
      const secondLevelDomain = domainParts[domainParts.length - 2];
      // In aforementioned example, the eTLD/pubSuf will be apple.localhost
      return `${secondLevelDomain}.${topLevelDomain}`;
    } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
      // For a single word special use domain, e.g. 'localhost' or 'invalid', per RFC 6761,
      // "Application software MAY recognize {localhost/invalid} names as special, or
      // MAY pass them to name resolution APIs as they would for other domain names."
      return `${topLevelDomain}`;
    }
  }

  if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
    throw new Error(
      `Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`
    );
  }

  return psl.get(domain);
}

exports.getPublicSuffix = getPublicSuffix;

},{"psl":63}],87:[function(require,module,exports){
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/*jshint unused:false */

class Store {
  constructor() {
    this.synchronous = false;
  }

  findCookie(domain, path, key, cb) {
    throw new Error("findCookie is not implemented");
  }

  findCookies(domain, path, allowSpecialUseDomain, cb) {
    throw new Error("findCookies is not implemented");
  }

  putCookie(cookie, cb) {
    throw new Error("putCookie is not implemented");
  }

  updateCookie(oldCookie, newCookie, cb) {
    // recommended default implementation:
    // return this.putCookie(newCookie, cb);
    throw new Error("updateCookie is not implemented");
  }

  removeCookie(domain, path, key, cb) {
    throw new Error("removeCookie is not implemented");
  }

  removeCookies(domain, path, cb) {
    throw new Error("removeCookies is not implemented");
  }

  removeAllCookies(cb) {
    throw new Error("removeAllCookies is not implemented");
  }

  getAllCookies(cb) {
    throw new Error(
      "getAllCookies is not implemented (therefore jar cannot be serialized)"
    );
  }
}

exports.Store = Store;

},{}],88:[function(require,module,exports){
function requireUtil() {
  try {
    // eslint-disable-next-line no-restricted-modules
    return require("util");
  } catch (e) {
    return null;
  }
}

// for v10.12.0+
function lookupCustomInspectSymbol() {
  return Symbol.for("nodejs.util.inspect.custom");
}

// for older node environments
function tryReadingCustomSymbolFromUtilInspect(options) {
  const _requireUtil = options.requireUtil || requireUtil;
  const util = _requireUtil();
  return util ? util.inspect.custom : null;
}

exports.getUtilInspect = function getUtilInspect(fallback, options = {}) {
  const _requireUtil = options.requireUtil || requireUtil;
  const util = _requireUtil();
  return function inspect(value, showHidden, depth) {
    return util ? util.inspect(value, showHidden, depth) : fallback(value);
  };
};

exports.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
  const _lookupCustomInspectSymbol =
    options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;

  // get custom inspect symbol for node environments
  return (
    _lookupCustomInspectSymbol() ||
    tryReadingCustomSymbolFromUtilInspect(options)
  );
};

},{"util":23}],89:[function(require,module,exports){
/* ************************************************************************************
Extracted from check-types.js
https://gitlab.com/philbooth/check-types.js

MIT License

Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019 Phil Booth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

************************************************************************************ */
"use strict";

/* Validation functions copied from check-types package - https://www.npmjs.com/package/check-types */
function isFunction(data) {
  return typeof data === "function";
}

function isNonEmptyString(data) {
  return isString(data) && data !== "";
}

function isDate(data) {
  return isInstanceStrict(data, Date) && isInteger(data.getTime());
}

function isEmptyString(data) {
  return data === "" || (data instanceof String && data.toString() === "");
}

function isString(data) {
  return typeof data === "string" || data instanceof String;
}

function isObject(data) {
  return toString.call(data) === "[object Object]";
}
function isInstanceStrict(data, prototype) {
  try {
    return data instanceof prototype;
  } catch (error) {
    return false;
  }
}

function isInteger(data) {
  return typeof data === "number" && data % 1 === 0;
}
/* End validation functions */

function validate(bool, cb, options) {
  if (!isFunction(cb)) {
    options = cb;
    cb = null;
  }
  if (!isObject(options)) options = { Error: "Failed Check" };
  if (!bool) {
    if (cb) {
      cb(new ParameterError(options));
    } else {
      throw new ParameterError(options);
    }
  }
}

class ParameterError extends Error {
  constructor(...params) {
    super(...params);
  }
}

exports.ParameterError = ParameterError;
exports.isFunction = isFunction;
exports.isNonEmptyString = isNonEmptyString;
exports.isDate = isDate;
exports.isEmptyString = isEmptyString;
exports.isString = isString;
exports.isObject = isObject;
exports.validate = validate;

},{}],90:[function(require,module,exports){
// generated by genversion
module.exports = '4.1.3'

},{}],91:[function(require,module,exports){
'use strict'

exports.fromCallback = function (fn) {
  return Object.defineProperty(function () {
    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)
    else {
      return new Promise((resolve, reject) => {
        arguments[arguments.length] = (err, res) => {
          if (err) return reject(err)
          resolve(res)
        }
        arguments.length++
        fn.apply(this, arguments)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function () {
    const cb = arguments[arguments.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, arguments)
    else {
      delete arguments[arguments.length - 1]
      arguments.length--
      fn.apply(this, arguments).then(r => cb(null, r), cb)
    }
  }, 'name', { value: fn.name })
}

},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mixin = Mixin;
exports.settings = exports.mix = exports.hasMixin = exports.decorate = void 0;
/**
 * Utility function that works like `Object.apply`, but copies getters and setters properly as well.  Additionally gives
 * the option to exclude properties by name.
 */
const copyProps = (dest, src, exclude = []) => {
  const props = Object.getOwnPropertyDescriptors(src);
  for (let prop of exclude) delete props[prop];
  Object.defineProperties(dest, props);
};
/**
 * Returns the full chain of prototypes up until Object.prototype given a starting object.  The order of prototypes will
 * be closest to farthest in the chain.
 */
const protoChain = (obj, currentChain = [obj]) => {
  const proto = Object.getPrototypeOf(obj);
  if (proto === null) return currentChain;
  return protoChain(proto, [...currentChain, proto]);
};
/**
 * Identifies the nearest ancestor common to all the given objects in their prototype chains.  For most unrelated
 * objects, this function should return Object.prototype.
 */
const nearestCommonProto = (...objs) => {
  if (objs.length === 0) return undefined;
  let commonProto = undefined;
  const protoChains = objs.map(obj => protoChain(obj));
  while (protoChains.every(protoChain => protoChain.length > 0)) {
    const protos = protoChains.map(protoChain => protoChain.pop());
    const potentialCommonProto = protos[0];
    if (protos.every(proto => proto === potentialCommonProto)) commonProto = potentialCommonProto;else break;
  }
  return commonProto;
};
/**
 * Creates a new prototype object that is a mixture of the given prototypes.  The mixing is achieved by first
 * identifying the nearest common ancestor and using it as the prototype for a new object.  Then all properties/methods
 * downstream of this prototype (ONLY downstream) are copied into the new object.
 *
 * The resulting prototype is more performant than softMixProtos(...), as well as ES5 compatible.  However, it's not as
 * flexible as updates to the source prototypes aren't captured by the mixed result.  See softMixProtos for why you may
 * want to use that instead.
 */
const hardMixProtos = (ingredients, constructor, exclude = []) => {
  var _a;
  const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
  const mixedProto = Object.create(base);
  // Keeps track of prototypes we've already visited to avoid copying the same properties multiple times.  We init the
  // list with the proto chain below the nearest common ancestor because we don't want any of those methods mixed in
  // when they will already be accessible via prototype access.
  const visitedProtos = protoChain(base);
  for (let prototype of ingredients) {
    let protos = protoChain(prototype);
    // Apply the prototype chain in reverse order so that old methods don't override newer ones.
    for (let i = protos.length - 1; i >= 0; i--) {
      let newProto = protos[i];
      if (visitedProtos.indexOf(newProto) === -1) {
        copyProps(mixedProto, newProto, ['constructor', ...exclude]);
        visitedProtos.push(newProto);
      }
    }
  }
  mixedProto.constructor = constructor;
  return mixedProto;
};
const unique = arr => arr.filter((e, i) => arr.indexOf(e) == i);

/**
 * Finds the ingredient with the given prop, searching in reverse order and breadth-first if searching ingredient
 * prototypes is required.
 */
const getIngredientWithProp = (prop, ingredients) => {
  const protoChains = ingredients.map(ingredient => protoChain(ingredient));
  // since we search breadth-first, we need to keep track of our depth in the prototype chains
  let protoDepth = 0;
  // not all prototype chains are the same depth, so this remains true as long as at least one of the ingredients'
  // prototype chains has an object at this depth
  let protosAreLeftToSearch = true;
  while (protosAreLeftToSearch) {
    // with the start of each horizontal slice, we assume this is the one that's deeper than any of the proto chains
    protosAreLeftToSearch = false;
    // scan through the ingredients right to left
    for (let i = ingredients.length - 1; i >= 0; i--) {
      const searchTarget = protoChains[i][protoDepth];
      if (searchTarget !== undefined && searchTarget !== null) {
        // if we find something, this is proof that this horizontal slice potentially more objects to search
        protosAreLeftToSearch = true;
        // eureka, we found it
        if (Object.getOwnPropertyDescriptor(searchTarget, prop) != undefined) {
          return protoChains[i][0];
        }
      }
    }
    protoDepth++;
  }
  return undefined;
};
/**
 * "Mixes" ingredients by wrapping them in a Proxy.  The optional prototype argument allows the mixed object to sit
 * downstream of an existing prototype chain.  Note that "properties" cannot be added, deleted, or modified.
 */
const proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
  getPrototypeOf() {
    return prototype;
  },
  setPrototypeOf() {
    throw Error('Cannot set prototype of Proxies created by ts-mixer');
  },
  getOwnPropertyDescriptor(_, prop) {
    return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
  },
  defineProperty() {
    throw new Error('Cannot define new properties on Proxies created by ts-mixer');
  },
  has(_, prop) {
    return getIngredientWithProp(prop, ingredients) !== undefined || prototype[prop] !== undefined;
  },
  get(_, prop) {
    return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
  },
  set(_, prop, val) {
    const ingredientWithProp = getIngredientWithProp(prop, ingredients);
    if (ingredientWithProp === undefined) throw new Error('Cannot set new properties on Proxies created by ts-mixer');
    ingredientWithProp[prop] = val;
    return true;
  },
  deleteProperty() {
    throw new Error('Cannot delete properties on Proxies created by ts-mixer');
  },
  ownKeys() {
    return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter(key => curr.indexOf(key) < 0)));
  }
});
/**
 * Creates a new proxy-prototype object that is a "soft" mixture of the given prototypes.  The mixing is achieved by
 * proxying all property access to the ingredients.  This is not ES5 compatible and less performant.  However, any
 * changes made to the source prototypes will be reflected in the proxy-prototype, which may be desirable.
 */
const softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, {
  constructor
}]);
const settings = exports.settings = {
  initFunction: null,
  staticsStrategy: 'copy',
  prototypeStrategy: 'copy',
  decoratorInheritance: 'deep'
};

// Keeps track of constituent classes for every mixin class created by ts-mixer.
const mixins = new WeakMap();
const getMixinsForClass = clazz => mixins.get(clazz);
const registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
const hasMixin = (instance, mixin) => {
  if (instance instanceof mixin) return true;
  const constructor = instance.constructor;
  const visited = new Set();
  let frontier = new Set();
  frontier.add(constructor);
  while (frontier.size > 0) {
    // check if the frontier has the mixin we're looking for.  if not, we can say we visited every item in the frontier
    if (frontier.has(mixin)) return true;
    frontier.forEach(item => visited.add(item));
    // build a new frontier based on the associated mixin classes and prototype chains of each frontier item
    const newFrontier = new Set();
    frontier.forEach(item => {
      var _a;
      const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map(proto => proto.constructor).filter(item => item !== null);
      if (itemConstituents) itemConstituents.forEach(constituent => {
        if (!visited.has(constituent) && !frontier.has(constituent)) newFrontier.add(constituent);
      });
    });
    // we have a new frontier, now search again
    frontier = newFrontier;
  }
  // if we get here, we couldn't find the mixin anywhere in the prototype chain or associated mixin classes
  return false;
};
exports.hasMixin = hasMixin;
const mergeObjectsOfDecorators = (o1, o2) => {
  var _a, _b;
  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
  const mergedObject = {};
  for (let key of allKeys) mergedObject[key] = unique([...((_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : []), ...((_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : [])]);
  return mergedObject;
};
const mergePropertyAndMethodDecorators = (d1, d2) => {
  var _a, _b, _c, _d;
  return {
    property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
  };
};
const mergeDecorators = (d1, d2) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    class: unique([...((_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : []), ...((_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : [])]),
    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
    instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
  };
};
const decorators = new Map();
const findAllConstituentClasses = (...classes) => {
  var _a;
  const allClasses = new Set();
  const frontier = new Set([...classes]);
  while (frontier.size > 0) {
    for (let clazz of frontier) {
      const protoChainClasses = protoChain(clazz.prototype).map(proto => proto.constructor);
      const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
      const newClasses = potentiallyNewClasses.filter(c => !allClasses.has(c));
      for (let newClass of newClasses) frontier.add(newClass);
      allClasses.add(clazz);
      frontier.delete(clazz);
    }
  }
  return [...allClasses];
};
const deepDecoratorSearch = (...classes) => {
  const decoratorsForClassChain = findAllConstituentClasses(...classes).map(clazz => decorators.get(clazz)).filter(decorators => !!decorators);
  if (decoratorsForClassChain.length == 0) return {};
  if (decoratorsForClassChain.length == 1) return decoratorsForClassChain[0];
  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const directDecoratorSearch = (...classes) => {
  const classDecorators = classes.map(clazz => getDecoratorsForClass(clazz));
  if (classDecorators.length === 0) return {};
  if (classDecorators.length === 1) return classDecorators[0];
  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
};
const getDecoratorsForClass = clazz => {
  let decoratorsForClass = decorators.get(clazz);
  if (!decoratorsForClass) {
    decoratorsForClass = {};
    decorators.set(clazz, decoratorsForClass);
  }
  return decoratorsForClass;
};
const decorateClass = decorator => clazz => {
  const decoratorsForClass = getDecoratorsForClass(clazz);
  let classDecorators = decoratorsForClass.class;
  if (!classDecorators) {
    classDecorators = [];
    decoratorsForClass.class = classDecorators;
  }
  classDecorators.push(decorator);
  return decorator(clazz);
};
const decorateMember = decorator => (object, key, ...otherArgs) => {
  var _a, _b, _c;
  const decoratorTargetType = typeof object === 'function' ? 'static' : 'instance';
  const decoratorType = typeof object[key] === 'function' ? 'method' : 'property';
  const clazz = decoratorTargetType === 'static' ? object : object.constructor;
  const decoratorsForClass = getDecoratorsForClass(clazz);
  const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType]) !== null && _a !== void 0 ? _a : {};
  decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
  let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType]) !== null && _b !== void 0 ? _b : {};
  decoratorsForTargetType[decoratorType] = decoratorsForType;
  let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key]) !== null && _c !== void 0 ? _c : [];
  decoratorsForType[key] = decoratorsForKey;
  // @ts-ignore: array is type `A[] | B[]` and item is type `A | B`, so technically a type error, but it's fine
  decoratorsForKey.push(decorator);
  // @ts-ignore
  return decorator(object, key, ...otherArgs);
};
const decorate = decorator => (...args) => {
  if (args.length === 1) return decorateClass(decorator)(args[0]);
  return decorateMember(decorator)(...args);
};
exports.decorate = decorate;
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map(constructor => constructor.prototype);
  // Here we gather up the init functions of the ingredient prototypes, combine them into one init function, and
  // attach it to the mixed class prototype.  The reason we do this is because we want the init functions to mix
  // similarly to constructors -- not methods, which simply override each other.
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map(proto => proto[initFunctionName]).filter(func => typeof func === 'function');
    const combinedInitFunction = function (...args) {
      for (let initFunction of initFunctions) initFunction.apply(this, args);
    };
    const extraProto = {
      [initFunctionName]: combinedInitFunction
    };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
    // @ts-ignore: potentially abstract class
    copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === 'function') this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === 'copy' ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === 'copy' ? hardMixProtos(constructors, null, ['prototype']) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== 'none') {
    const classDecorators = settings.decoratorInheritance === 'deep' ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
const applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
  const propDecorators = propAndMethodDecorators.property;
  const methodDecorators = propAndMethodDecorators.method;
  if (propDecorators) for (let key in propDecorators) for (let decorator of propDecorators[key]) decorator(target, key);
  if (methodDecorators) for (let key in methodDecorators) for (let decorator of methodDecorators[key]) decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
};
/**
 * A decorator version of the `Mixin` function.  You'll want to use this instead of `Mixin` for mixing generic classes.
 */
const mix = (...ingredients) => decoratedClass => {
  // @ts-ignore
  const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
  Object.defineProperty(mixedClass, 'name', {
    value: decoratedClass.name,
    writable: false
  });
  return mixedClass;
};
exports.mix = mix;

},{}],93:[function(require,module,exports){
(function (name, context, definition) {
  if (typeof module !== 'undefined' && module.exports) module.exports = definition();
  else if (typeof define === 'function' && define.amd) define(definition);
  else context[name] = definition();
})('urljoin', this, function () {

  function normalize (strArray) {
    var resultArray = [];
    if (strArray.length === 0) { return ''; }

    if (typeof strArray[0] !== 'string') {
      throw new TypeError('Url must be a string. Received ' + strArray[0]);
    }

    // If the first part is a plain protocol, we combine it with the next part.
    if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
      var first = strArray.shift();
      strArray[0] = first + strArray[0];
    }

    // There must be two or three slashes in the file protocol, two slashes in anything else.
    if (strArray[0].match(/^file:\/\/\//)) {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1:///');
    } else {
      strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, '$1://');
    }

    for (var i = 0; i < strArray.length; i++) {
      var component = strArray[i];

      if (typeof component !== 'string') {
        throw new TypeError('Url must be a string. Received ' + component);
      }

      if (component === '') { continue; }

      if (i > 0) {
        // Removing the starting slashes for each component but the first.
        component = component.replace(/^[\/]+/, '');
      }
      if (i < strArray.length - 1) {
        // Removing the ending slashes for each component but the last.
        component = component.replace(/[\/]+$/, '');
      } else {
        // For the last component we will combine multiple slashes to a single one.
        component = component.replace(/[\/]+$/, '/');
      }

      resultArray.push(component);

    }

    var str = resultArray.join('/');
    // Each input component is now separated by a single slash except the possible first plain protocol part.

    // remove trailing slash before parameters or hash
    str = str.replace(/\/(\?|&|#[^!])/g, '$1');

    // replace ? in parameters with &
    var parts = str.split('?');
    str = parts.shift() + (parts.length > 0 ? '?': '') + parts.join('&');

    return str;
  }

  return function () {
    var input;

    if (typeof arguments[0] === 'object') {
      input = arguments[0];
    } else {
      input = [].slice.call(arguments);
    }

    return normalize(input);
  };

});

},{}],94:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"querystringify":65,"requires-port":66}],95:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DOMException = void 0;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.fetch = fetch;
/* eslint-disable no-prototype-builtins */
var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self ||
// eslint-disable-next-line no-undef
typeof global !== 'undefined' && global || {};
var support = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob: 'FileReader' in g && 'Blob' in g && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value;
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};
Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = function () {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : 'utf-8';
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('');
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function (body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };
  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function () {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error('could not read as ArrayBuffer');
    }
  };
  this.text = function () {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }
  this.json = function () {
    return this.text().then(JSON.parse);
  };
  return this;
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }
  this._initBody(body);
  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};
function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders.split('\r').map(function (header) {
    return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
  }).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn('Response ' + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function () {
  var response = new Response(null, {
    status: 200,
    statusText: ''
  });
  response.ok = false;
  response.status = 0;
  response.type = 'error';
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }
  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};
var DOMException = exports.DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  exports.DOMException = DOMException = function (message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function () {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      setTimeout(function () {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function () {
      setTimeout(function () {
        reject(new TypeError('Network request failed'));
      }, 0);
    };
    xhr.ontimeout = function () {
      setTimeout(function () {
        reject(new TypeError('Network request timed out'));
      }, 0);
    };
    xhr.onabort = function () {
      setTimeout(function () {
        reject(new DOMException('Aborted', 'AbortError'));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }
    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob';
      } else if (support.arrayBuffer) {
        xhr.responseType = 'arraybuffer';
      }
    }
    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function (name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function (value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);
      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch;
  g.Headers = Headers;
  g.Request = Request;
  g.Response = Response;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],96:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = void 0;
var constants_1 = require("../constants");
var provider_1 = require("../provider");
var signer_1 = require("../signer");
var types_1 = require("../types");
var api_1 = require("../types/api");
var calldata_1 = require("../utils/calldata");
var contract_1 = require("../utils/contract");
var events_1 = require("../utils/events");
var hash_1 = require("../utils/hash");
var num_1 = require("../utils/num");
var provider_2 = require("../utils/provider");
var shortString_1 = require("../utils/shortString");
var stark_1 = require("../utils/stark");
var transaction_1 = require("../utils/transaction");
var typedData_1 = require("../utils/typedData");
var Account = /** @class */ (function (_super) {
    __extends(Account, _super);
    function Account(providerOrOptions, address, pkOrSigner, cairoVersion, transactionVersion // TODO: Discuss this, set to v2 for backward compatibility
    ) {
        if (transactionVersion === void 0) { transactionVersion = api_1.ETransactionVersion.V2; }
        var _this = _super.call(this, providerOrOptions) || this;
        _this.deploySelf = _this.deployAccount;
        _this.address = address.toLowerCase();
        _this.signer =
            (0, shortString_1.isString)(pkOrSigner) || pkOrSigner instanceof Uint8Array
                ? new signer_1.Signer(pkOrSigner)
                : pkOrSigner;
        if (cairoVersion) {
            _this.cairoVersion = cairoVersion.toString();
        }
        _this.transactionVersion = transactionVersion;
        return _this;
    }
    // provided version or contract based preferred transactionVersion
    Account.prototype.getPreferredVersion = function (type12, type3) {
        if (this.transactionVersion === api_1.ETransactionVersion.V3)
            return type3;
        if (this.transactionVersion === api_1.ETransactionVersion.V2)
            return type12;
        return api_1.ETransactionVersion.V3;
    };
    Account.prototype.getNonce = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.getNonceForAddress.call(this, this.address, blockIdentifier)];
            });
        });
    };
    Account.prototype.getNonceSafe = function (nonce) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, error_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 4, , 5]);
                        _a = num_1.toBigInt;
                        if (!(nonce !== null && nonce !== void 0)) return [3 /*break*/, 1];
                        _b = nonce;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getNonce()];
                    case 2:
                        _b = (_c.sent());
                        _c.label = 3;
                    case 3: return [2 /*return*/, _a.apply(void 0, [_b])];
                    case 4:
                        error_1 = _c.sent();
                        return [2 /*return*/, 0n];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the Cairo version from the network and sets `cairoVersion` if not already set in the constructor.
     * @param classHash if provided detects Cairo version from classHash, otherwise from the account address
     */
    Account.prototype.getCairoVersion = function (classHash) {
        return __awaiter(this, void 0, void 0, function () {
            var cairo, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.cairoVersion) return [3 /*break*/, 5];
                        if (!classHash) return [3 /*break*/, 2];
                        return [4 /*yield*/, _super.prototype.getContractVersion.call(this, undefined, classHash)];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, _super.prototype.getContractVersion.call(this, this.address)];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        cairo = (_a).cairo;
                        this.cairoVersion = cairo;
                        _b.label = 5;
                    case 5: return [2 /*return*/, this.cairoVersion];
                }
            });
        });
    };
    Account.prototype.estimateFee = function (calls_1) {
        return __awaiter(this, arguments, void 0, function (calls, estimateFeeDetails) {
            if (estimateFeeDetails === void 0) { estimateFeeDetails = {}; }
            return __generator(this, function (_a) {
                return [2 /*return*/, this.estimateInvokeFee(calls, estimateFeeDetails)];
            });
        });
    };
    Account.prototype.estimateInvokeFee = function (calls_1) {
        return __awaiter(this, arguments, void 0, function (calls, details) {
            var providedNonce, blockIdentifier, providedVersion, _a, skipValidate, transactions, nonce, _b, _c, version, chainId, signerDetails, _d, invocation;
            var _e;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        providedNonce = details.nonce, blockIdentifier = details.blockIdentifier, providedVersion = details.version, _a = details.skipValidate, skipValidate = _a === void 0 ? true : _a;
                        transactions = Array.isArray(calls) ? calls : [calls];
                        _b = num_1.toBigInt;
                        if (!(providedNonce !== null && providedNonce !== void 0)) return [3 /*break*/, 1];
                        _c = providedNonce;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getNonce()];
                    case 2:
                        _c = (_f.sent());
                        _f.label = 3;
                    case 3:
                        nonce = _b.apply(void 0, [_c]);
                        version = (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.F1, api_1.ETransactionVersion.F3), (0, stark_1.toFeeVersion)(providedVersion));
                        return [4 /*yield*/, this.getChainId()];
                    case 4:
                        chainId = _f.sent();
                        _d = [__assign({}, (0, stark_1.v3Details)(details))];
                        _e = { walletAddress: this.address, nonce: nonce, maxFee: constants_1.ZERO, version: version, chainId: chainId };
                        return [4 /*yield*/, this.getCairoVersion()];
                    case 5:
                        signerDetails = __assign.apply(void 0, _d.concat([(_e.cairoVersion = _f.sent(), _e.skipValidate = skipValidate, _e)]));
                        return [4 /*yield*/, this.buildInvocation(transactions, signerDetails)];
                    case 6:
                        invocation = _f.sent();
                        return [2 /*return*/, _super.prototype.getInvokeEstimateFee.call(this, __assign({}, invocation), __assign(__assign({}, (0, stark_1.v3Details)(details)), { version: version, nonce: nonce }), blockIdentifier, details.skipValidate)];
                }
            });
        });
    };
    Account.prototype.estimateDeclareFee = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var blockIdentifier, providedNonce, providedVersion, _a, skipValidate, nonce, _b, _c, version, chainId, declareContractTransaction;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        blockIdentifier = details.blockIdentifier, providedNonce = details.nonce, providedVersion = details.version, _a = details.skipValidate, skipValidate = _a === void 0 ? true : _a;
                        _b = num_1.toBigInt;
                        if (!(providedNonce !== null && providedNonce !== void 0)) return [3 /*break*/, 1];
                        _c = providedNonce;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getNonce()];
                    case 2:
                        _c = (_d.sent());
                        _d.label = 3;
                    case 3:
                        nonce = _b.apply(void 0, [_c]);
                        version = (0, stark_1.toTransactionVersion)(!(0, contract_1.isSierra)(payload.contract)
                            ? api_1.ETransactionVersion.F1
                            : this.getPreferredVersion(api_1.ETransactionVersion.F2, api_1.ETransactionVersion.F3), (0, stark_1.toFeeVersion)(providedVersion));
                        return [4 /*yield*/, this.getChainId()];
                    case 4:
                        chainId = _d.sent();
                        return [4 /*yield*/, this.buildDeclarePayload(payload, __assign(__assign({}, (0, stark_1.v3Details)(details)), { nonce: nonce, chainId: chainId, version: version, walletAddress: this.address, maxFee: constants_1.ZERO, cairoVersion: undefined, // unused parameter
                                skipValidate: skipValidate }))];
                    case 5:
                        declareContractTransaction = _d.sent();
                        return [2 /*return*/, _super.prototype.getDeclareEstimateFee.call(this, declareContractTransaction, __assign(__assign({}, (0, stark_1.v3Details)(details)), { version: version, nonce: nonce }), blockIdentifier, details.skipValidate)];
                }
            });
        });
    };
    Account.prototype.estimateAccountDeployFee = function (_a) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var blockIdentifier, providedVersion, _c, skipValidate, version, nonce, chainId, payload;
            var classHash = _b.classHash, _d = _b.addressSalt, addressSalt = _d === void 0 ? 0 : _d, _e = _b.constructorCalldata, constructorCalldata = _e === void 0 ? [] : _e, contractAddress = _b.contractAddress;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        blockIdentifier = details.blockIdentifier, providedVersion = details.version, _c = details.skipValidate, skipValidate = _c === void 0 ? true : _c;
                        version = (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.F1, api_1.ETransactionVersion.F3), (0, stark_1.toFeeVersion)(providedVersion));
                        nonce = constants_1.ZERO;
                        return [4 /*yield*/, this.getChainId()];
                    case 1:
                        chainId = _f.sent();
                        return [4 /*yield*/, this.buildAccountDeployPayload({ classHash: classHash, addressSalt: addressSalt, constructorCalldata: constructorCalldata, contractAddress: contractAddress }, __assign(__assign({}, (0, stark_1.v3Details)(details)), { nonce: nonce, chainId: chainId, version: version, walletAddress: this.address, maxFee: constants_1.ZERO, cairoVersion: undefined, // unused parameter,
                                skipValidate: skipValidate }))];
                    case 2:
                        payload = _f.sent();
                        return [2 /*return*/, _super.prototype.getDeployAccountEstimateFee.call(this, __assign({}, payload), __assign(__assign({}, (0, stark_1.v3Details)(details)), { version: version, nonce: nonce }), blockIdentifier, details.skipValidate)];
                }
            });
        });
    };
    Account.prototype.estimateDeployFee = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var calls;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_a) {
                calls = this.buildUDCContractPayload(payload);
                return [2 /*return*/, this.estimateInvokeFee(calls, details)];
            });
        });
    };
    Account.prototype.estimateFeeBulk = function (invocations_1) {
        return __awaiter(this, arguments, void 0, function (invocations, details) {
            var nonce, blockIdentifier, version, skipValidate, accountInvocations;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nonce = details.nonce, blockIdentifier = details.blockIdentifier, version = details.version, skipValidate = details.skipValidate;
                        return [4 /*yield*/, this.accountInvocationsFactory(invocations, __assign(__assign({}, (0, stark_1.v3Details)(details)), { versions: [
                                    api_1.ETransactionVersion.F1, // non-sierra
                                    (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.F2, api_1.ETransactionVersion.F3), version), // sierra
                                ], nonce: nonce, blockIdentifier: blockIdentifier, skipValidate: skipValidate }))];
                    case 1:
                        accountInvocations = _a.sent();
                        return [2 /*return*/, _super.prototype.getEstimateFeeBulk.call(this, accountInvocations, {
                                blockIdentifier: blockIdentifier,
                                skipValidate: skipValidate,
                            })];
                }
            });
        });
    };
    Account.prototype.simulateTransaction = function (invocations_1) {
        return __awaiter(this, arguments, void 0, function (invocations, details) {
            var nonce, blockIdentifier, _a, skipValidate, skipExecute, version, accountInvocations;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        nonce = details.nonce, blockIdentifier = details.blockIdentifier, _a = details.skipValidate, skipValidate = _a === void 0 ? true : _a, skipExecute = details.skipExecute, version = details.version;
                        return [4 /*yield*/, this.accountInvocationsFactory(invocations, __assign(__assign({}, (0, stark_1.v3Details)(details)), { versions: [
                                    api_1.ETransactionVersion.V1, // non-sierra
                                    (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.V2, api_1.ETransactionVersion.V3), version),
                                ], nonce: nonce, blockIdentifier: blockIdentifier, skipValidate: skipValidate }))];
                    case 1:
                        accountInvocations = _b.sent();
                        return [2 /*return*/, _super.prototype.getSimulateTransaction.call(this, accountInvocations, {
                                blockIdentifier: blockIdentifier,
                                skipValidate: skipValidate,
                                skipExecute: skipExecute,
                            })];
                }
            });
        });
    };
    Account.prototype.execute = function (transactions_1, arg2_1) {
        return __awaiter(this, arguments, void 0, function (transactions, arg2, transactionsDetail) {
            var details, calls, nonce, _a, _b, version, estimate, chainId, signerDetails, _c, signature, calldata, _d, _e;
            var _f;
            var _g;
            if (transactionsDetail === void 0) { transactionsDetail = {}; }
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        details = arg2 === undefined || Array.isArray(arg2) ? transactionsDetail : arg2;
                        calls = Array.isArray(transactions) ? transactions : [transactions];
                        _a = num_1.toBigInt;
                        if (!((_g = details.nonce) !== null && _g !== void 0)) return [3 /*break*/, 1];
                        _b = _g;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getNonce()];
                    case 2:
                        _b = (_h.sent());
                        _h.label = 3;
                    case 3:
                        nonce = _a.apply(void 0, [_b]);
                        version = (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.V1, api_1.ETransactionVersion.V3), // TODO: does this depend on cairo version ?
                        details.version);
                        return [4 /*yield*/, this.getUniversalSuggestedFee(version, { type: types_1.TransactionType.INVOKE, payload: transactions }, __assign(__assign({}, details), { version: version }))];
                    case 4:
                        estimate = _h.sent();
                        return [4 /*yield*/, this.getChainId()];
                    case 5:
                        chainId = _h.sent();
                        _c = [__assign({}, (0, stark_1.v3Details)(details))];
                        _f = { resourceBounds: estimate.resourceBounds, walletAddress: this.address, nonce: nonce, maxFee: estimate.maxFee, version: version, chainId: chainId };
                        return [4 /*yield*/, this.getCairoVersion()];
                    case 6:
                        signerDetails = __assign.apply(void 0, _c.concat([(_f.cairoVersion = _h.sent(), _f)]));
                        return [4 /*yield*/, this.signer.signTransaction(calls, signerDetails)];
                    case 7:
                        signature = _h.sent();
                        _d = transaction_1.getExecuteCalldata;
                        _e = [calls];
                        return [4 /*yield*/, this.getCairoVersion()];
                    case 8:
                        calldata = _d.apply(void 0, _e.concat([_h.sent()]));
                        return [2 /*return*/, this.invokeFunction({ contractAddress: this.address, calldata: calldata, signature: signature }, __assign(__assign({}, (0, stark_1.v3Details)(details)), { resourceBounds: estimate.resourceBounds, nonce: nonce, maxFee: estimate.maxFee, version: version }))];
                }
            });
        });
    };
    /**
     * First check if contract is already declared, if not declare it
     * If contract already declared returned transaction_hash is ''.
     * Method will pass even if contract is already declared
     * @param transactionsDetail (optional)
     */
    Account.prototype.declareIfNot = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, transactionsDetail) {
            var declareContractPayload, error_2;
            if (transactionsDetail === void 0) { transactionsDetail = {}; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        declareContractPayload = (0, contract_1.extractContractHashes)(payload);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.getClassByHash(declareContractPayload.classHash)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_2 = _a.sent();
                        return [2 /*return*/, this.declare(payload, transactionsDetail)];
                    case 4: return [2 /*return*/, {
                            transaction_hash: '',
                            class_hash: declareContractPayload.classHash,
                        }];
                }
            });
        });
    };
    Account.prototype.declare = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var declareContractPayload, nonce, providedVersion, version, estimate, declareDetails, _a, _b, _c, declareContractTransaction;
            var _d;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        declareContractPayload = (0, contract_1.extractContractHashes)(payload);
                        nonce = details.nonce, providedVersion = details.version;
                        version = (0, stark_1.toTransactionVersion)(!(0, contract_1.isSierra)(payload.contract)
                            ? api_1.ETransactionVersion.V1
                            : this.getPreferredVersion(api_1.ETransactionVersion.V2, api_1.ETransactionVersion.V3), providedVersion);
                        return [4 /*yield*/, this.getUniversalSuggestedFee(version, {
                                type: types_1.TransactionType.DECLARE,
                                payload: declareContractPayload,
                            }, __assign(__assign({}, details), { version: version }))];
                    case 1:
                        estimate = _e.sent();
                        _a = [__assign({}, (0, stark_1.v3Details)(details))];
                        _d = { resourceBounds: estimate.resourceBounds, maxFee: estimate.maxFee };
                        _b = num_1.toBigInt;
                        if (!(nonce !== null && nonce !== void 0)) return [3 /*break*/, 2];
                        _c = nonce;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.getNonce()];
                    case 3:
                        _c = (_e.sent());
                        _e.label = 4;
                    case 4:
                        _d.nonce = _b.apply(void 0, [_c]), _d.version = version;
                        return [4 /*yield*/, this.getChainId()];
                    case 5:
                        declareDetails = __assign.apply(void 0, _a.concat([(_d.chainId = _e.sent(), _d.walletAddress = this.address, _d.cairoVersion = undefined, _d)]));
                        return [4 /*yield*/, this.buildDeclarePayload(declareContractPayload, declareDetails)];
                    case 6:
                        declareContractTransaction = _e.sent();
                        return [2 /*return*/, this.declareContract(declareContractTransaction, declareDetails)];
                }
            });
        });
    };
    Account.prototype.deploy = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var _a, calls, addresses, invokeResponse;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = (0, transaction_1.buildUDCCall)(payload, this.address), calls = _a.calls, addresses = _a.addresses;
                        return [4 /*yield*/, this.execute(calls, undefined, details)];
                    case 1:
                        invokeResponse = _b.sent();
                        return [2 /*return*/, __assign(__assign({}, invokeResponse), { contract_address: addresses })];
                }
            });
        });
    };
    Account.prototype.deployContract = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var deployTx, txReceipt;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deploy(payload, details)];
                    case 1:
                        deployTx = _a.sent();
                        return [4 /*yield*/, this.waitForTransaction(deployTx.transaction_hash)];
                    case 2:
                        txReceipt = _a.sent();
                        return [2 /*return*/, (0, events_1.parseUDCEvent)(txReceipt)];
                }
            });
        });
    };
    Account.prototype.declareAndDeploy = function (payload_1) {
        return __awaiter(this, arguments, void 0, function (payload, details) {
            var constructorCalldata, salt, unique, declare, tx, deploy;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        constructorCalldata = payload.constructorCalldata, salt = payload.salt, unique = payload.unique;
                        return [4 /*yield*/, this.declareIfNot(payload, details)];
                    case 1:
                        declare = _a.sent();
                        if (!(declare.transaction_hash !== '')) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.waitForTransaction(declare.transaction_hash)];
                    case 2:
                        tx = _a.sent();
                        declare = __assign(__assign({}, declare), tx);
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.deployContract({ classHash: declare.class_hash, salt: salt, unique: unique, constructorCalldata: constructorCalldata }, details)];
                    case 4:
                        deploy = _a.sent();
                        return [2 /*return*/, { declare: __assign({}, declare), deploy: deploy }];
                }
            });
        });
    };
    Account.prototype.deployAccount = function (_a) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var version, nonce, chainId, compiledCalldata, contractAddress, estimate, signature;
            var classHash = _b.classHash, _c = _b.constructorCalldata, constructorCalldata = _c === void 0 ? [] : _c, _d = _b.addressSalt, addressSalt = _d === void 0 ? 0 : _d, providedContractAddress = _b.contractAddress;
            if (details === void 0) { details = {}; }
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        version = (0, stark_1.toTransactionVersion)(this.getPreferredVersion(api_1.ETransactionVersion.V1, api_1.ETransactionVersion.V3), details.version);
                        nonce = constants_1.ZERO;
                        return [4 /*yield*/, this.getChainId()];
                    case 1:
                        chainId = _e.sent();
                        compiledCalldata = calldata_1.CallData.compile(constructorCalldata);
                        contractAddress = providedContractAddress !== null && providedContractAddress !== void 0 ? providedContractAddress : (0, hash_1.calculateContractAddressFromHash)(addressSalt, classHash, compiledCalldata, 0);
                        return [4 /*yield*/, this.getUniversalSuggestedFee(version, {
                                type: types_1.TransactionType.DEPLOY_ACCOUNT,
                                payload: {
                                    classHash: classHash,
                                    constructorCalldata: compiledCalldata,
                                    addressSalt: addressSalt,
                                    contractAddress: contractAddress,
                                },
                            }, details)];
                    case 2:
                        estimate = _e.sent();
                        return [4 /*yield*/, this.signer.signDeployAccountTransaction(__assign(__assign({}, (0, stark_1.v3Details)(details)), { classHash: classHash, constructorCalldata: compiledCalldata, contractAddress: contractAddress, addressSalt: addressSalt, chainId: chainId, resourceBounds: estimate.resourceBounds, maxFee: estimate.maxFee, version: version, nonce: nonce }))];
                    case 3:
                        signature = _e.sent();
                        return [2 /*return*/, this.deployAccountContract({ classHash: classHash, addressSalt: addressSalt, constructorCalldata: constructorCalldata, signature: signature }, __assign(__assign({}, (0, stark_1.v3Details)(details)), { nonce: nonce, resourceBounds: estimate.resourceBounds, maxFee: estimate.maxFee, version: version }))];
                }
            });
        });
    };
    Account.prototype.signMessage = function (typedData) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.signer.signMessage(typedData, this.address)];
            });
        });
    };
    Account.prototype.hashMessage = function (typedData) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, typedData_1.getMessageHash)(typedData, this.address)];
            });
        });
    };
    Account.prototype.verifyMessageHash = function (hash, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var knownSigVerificationFName, knownSignatureResponse, error, _i, knownSigVerificationFName_1, SigVerificationFName, resp, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        knownSigVerificationFName = signatureVerificationFunctionName
                            ? [signatureVerificationFunctionName]
                            : ['isValidSignature', 'is_valid_signature'];
                        knownSignatureResponse = signatureVerificationResponse || {
                            okResponse: [
                            // any non-nok response is true
                            ],
                            nokResponse: [
                                '0x0', // Devnet
                                '0x00', // OpenZeppelin 0.7.0 to 0.9.0 invalid signature
                            ],
                            error: [
                                'argent/invalid-signature', // ArgentX 0.3.0 to 0.3.1
                                'is invalid, with respect to the public key', // OpenZeppelin until 0.6.1, Braavos 0.0.11
                                'INVALID_SIG', // Braavos 1.0.0
                            ],
                        };
                        _i = 0, knownSigVerificationFName_1 = knownSigVerificationFName;
                        _a.label = 1;
                    case 1:
                        if (!(_i < knownSigVerificationFName_1.length)) return [3 /*break*/, 6];
                        SigVerificationFName = knownSigVerificationFName_1[_i];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.callContract({
                                contractAddress: this.address,
                                entrypoint: SigVerificationFName,
                                calldata: calldata_1.CallData.compile({
                                    hash: (0, num_1.toBigInt)(hash).toString(),
                                    signature: (0, stark_1.formatSignature)(signature),
                                }),
                            })];
                    case 3:
                        resp = _a.sent();
                        // Response NOK Signature
                        if (knownSignatureResponse.nokResponse.includes(resp[0].toString())) {
                            return [2 /*return*/, false];
                        }
                        // Response OK Signature
                        // Empty okResponse assume all non-nok responses are valid signatures
                        // OpenZeppelin 0.7.0 to 0.9.0, ArgentX 0.3.0 to 0.3.1 & Braavos Cairo 0.0.11 to 1.0.0 valid signature
                        if (knownSignatureResponse.okResponse.length === 0 ||
                            knownSignatureResponse.okResponse.includes(resp[0].toString())) {
                            return [2 /*return*/, true];
                        }
                        throw Error('signatureVerificationResponse Error: response is not part of known responses');
                    case 4:
                        err_1 = _a.sent();
                        // Known NOK Errors
                        if (knownSignatureResponse.error.some(function (errMessage) {
                            return err_1.message.includes(errMessage);
                        })) {
                            return [2 /*return*/, false];
                        }
                        // Unknown Error
                        error = err_1;
                        return [3 /*break*/, 5];
                    case 5:
                        _i++;
                        return [3 /*break*/, 1];
                    case 6: throw Error("Signature verification Error: ".concat(error));
                }
            });
        });
    };
    Account.prototype.verifyMessage = function (typedData, signature, signatureVerificationFunctionName, signatureVerificationResponse) {
        return __awaiter(this, void 0, void 0, function () {
            var hash;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.hashMessage(typedData)];
                    case 1:
                        hash = _a.sent();
                        return [2 /*return*/, this.verifyMessageHash(hash, signature, signatureVerificationFunctionName, signatureVerificationResponse)];
                }
            });
        });
    };
    /*
     * Support methods
     */
    Account.prototype.getUniversalSuggestedFee = function (version_1, _a, details_1) {
        return __awaiter(this, arguments, void 0, function (version, _b, details) {
            var maxFee, resourceBounds, _c, _d;
            var _e, _f;
            var type = _b.type, payload = _b.payload;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        maxFee = 0;
                        resourceBounds = (0, stark_1.estimateFeeToBounds)(constants_1.ZERO);
                        if (!(version === api_1.ETransactionVersion.V3)) return [3 /*break*/, 4];
                        if (!((_e = details.resourceBounds) !== null && _e !== void 0)) return [3 /*break*/, 1];
                        _c = _e;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.getSuggestedFee({ type: type, payload: payload }, details)];
                    case 2:
                        _c = (_g.sent()).resourceBounds;
                        _g.label = 3;
                    case 3:
                        resourceBounds = _c;
                        return [3 /*break*/, 8];
                    case 4:
                        if (!((_f = details.maxFee) !== null && _f !== void 0)) return [3 /*break*/, 5];
                        _d = _f;
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, this.getSuggestedFee({ type: type, payload: payload }, details)];
                    case 6:
                        _d = (_g.sent()).suggestedMaxFee;
                        _g.label = 7;
                    case 7:
                        maxFee = _d;
                        _g.label = 8;
                    case 8: return [2 /*return*/, {
                            maxFee: maxFee,
                            resourceBounds: resourceBounds,
                        }];
                }
            });
        });
    };
    Account.prototype.getSuggestedFee = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var feeEstimate, _c;
            var type = _b.type, payload = _b.payload;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = type;
                        switch (_c) {
                            case types_1.TransactionType.INVOKE: return [3 /*break*/, 1];
                            case types_1.TransactionType.DECLARE: return [3 /*break*/, 3];
                            case types_1.TransactionType.DEPLOY_ACCOUNT: return [3 /*break*/, 5];
                            case types_1.TransactionType.DEPLOY: return [3 /*break*/, 7];
                        }
                        return [3 /*break*/, 9];
                    case 1: return [4 /*yield*/, this.estimateInvokeFee(payload, details)];
                    case 2:
                        feeEstimate = _d.sent();
                        return [3 /*break*/, 10];
                    case 3: return [4 /*yield*/, this.estimateDeclareFee(payload, details)];
                    case 4:
                        feeEstimate = _d.sent();
                        return [3 /*break*/, 10];
                    case 5: return [4 /*yield*/, this.estimateAccountDeployFee(payload, details)];
                    case 6:
                        feeEstimate = _d.sent();
                        return [3 /*break*/, 10];
                    case 7: return [4 /*yield*/, this.estimateDeployFee(payload, details)];
                    case 8:
                        feeEstimate = _d.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        feeEstimate = {
                            gas_consumed: 0n,
                            gas_price: 0n,
                            overall_fee: constants_1.ZERO,
                            unit: 'FRI',
                            suggestedMaxFee: constants_1.ZERO,
                            resourceBounds: (0, stark_1.estimateFeeToBounds)(constants_1.ZERO),
                            data_gas_consumed: 0n,
                            data_gas_price: 0n,
                        };
                        return [3 /*break*/, 10];
                    case 10: return [2 /*return*/, feeEstimate];
                }
            });
        });
    };
    Account.prototype.buildInvocation = function (call, details) {
        return __awaiter(this, void 0, void 0, function () {
            var calldata, _a, _b, signature, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = transaction_1.getExecuteCalldata;
                        _b = [call];
                        return [4 /*yield*/, this.getCairoVersion()];
                    case 1:
                        calldata = _a.apply(void 0, _b.concat([_d.sent()]));
                        if (!!details.skipValidate) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.signer.signTransaction(call, details)];
                    case 2:
                        _c = _d.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _c = [];
                        _d.label = 4;
                    case 4:
                        signature = _c;
                        return [2 /*return*/, __assign(__assign({}, (0, stark_1.v3Details)(details)), { contractAddress: this.address, calldata: calldata, signature: signature })];
                }
            });
        });
    };
    Account.prototype.buildDeclarePayload = function (payload, details) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, classHash, contract, compiledClassHash, compressedCompiledContract, signature, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = (0, contract_1.extractContractHashes)(payload), classHash = _a.classHash, contract = _a.contract, compiledClassHash = _a.compiledClassHash;
                        compressedCompiledContract = (0, provider_2.parseContract)(contract);
                        if (typeof compiledClassHash === 'undefined' &&
                            (details.version === api_1.ETransactionVersion3.F3 || details.version === api_1.ETransactionVersion3.V3)) {
                            throw Error('V3 Transaction work with Cairo1 Contracts and require compiledClassHash');
                        }
                        if (!!details.skipValidate) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signer.signDeclareTransaction(__assign(__assign(__assign({}, details), (0, stark_1.v3Details)(details)), { classHash: classHash, compiledClassHash: compiledClassHash, senderAddress: details.walletAddress }))];
                    case 1:
                        _b = _c.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _b = [];
                        _c.label = 3;
                    case 3:
                        signature = _b;
                        return [2 /*return*/, {
                                senderAddress: details.walletAddress,
                                signature: signature,
                                contract: compressedCompiledContract,
                                compiledClassHash: compiledClassHash,
                            }];
                }
            });
        });
    };
    Account.prototype.buildAccountDeployPayload = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var compiledCalldata, contractAddress, signature, _c;
            var classHash = _b.classHash, _d = _b.addressSalt, addressSalt = _d === void 0 ? 0 : _d, _e = _b.constructorCalldata, constructorCalldata = _e === void 0 ? [] : _e, providedContractAddress = _b.contractAddress;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        compiledCalldata = calldata_1.CallData.compile(constructorCalldata);
                        contractAddress = providedContractAddress !== null && providedContractAddress !== void 0 ? providedContractAddress : (0, hash_1.calculateContractAddressFromHash)(addressSalt, classHash, compiledCalldata, 0);
                        if (!!details.skipValidate) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signer.signDeployAccountTransaction(__assign(__assign(__assign({}, details), (0, stark_1.v3Details)(details)), { classHash: classHash, contractAddress: contractAddress, addressSalt: addressSalt, constructorCalldata: compiledCalldata }))];
                    case 1:
                        _c = _f.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _c = [];
                        _f.label = 3;
                    case 3:
                        signature = _c;
                        return [2 /*return*/, __assign(__assign({}, (0, stark_1.v3Details)(details)), { classHash: classHash, addressSalt: addressSalt, constructorCalldata: compiledCalldata, signature: signature })];
                }
            });
        });
    };
    Account.prototype.buildUDCContractPayload = function (payload) {
        var calls = [].concat(payload).map(function (it) {
            var _a = it, classHash = _a.classHash, _b = _a.salt, salt = _b === void 0 ? '0' : _b, _c = _a.unique, unique = _c === void 0 ? true : _c, _d = _a.constructorCalldata, constructorCalldata = _d === void 0 ? [] : _d;
            var compiledConstructorCallData = calldata_1.CallData.compile(constructorCalldata);
            return {
                contractAddress: constants_1.UDC.ADDRESS,
                entrypoint: constants_1.UDC.ENTRYPOINT,
                calldata: __spreadArray([
                    classHash,
                    salt,
                    (0, num_1.toCairoBool)(unique),
                    compiledConstructorCallData.length
                ], compiledConstructorCallData, true),
            };
        });
        return calls;
    };
    Account.prototype.accountInvocationsFactory = function (invocations, details) {
        return __awaiter(this, void 0, void 0, function () {
            var nonce, blockIdentifier, _a, skipValidate, safeNonce, chainId, versions, tx0Payload, cairoVersion, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        nonce = details.nonce, blockIdentifier = details.blockIdentifier, _a = details.skipValidate, skipValidate = _a === void 0 ? true : _a;
                        return [4 /*yield*/, this.getNonceSafe(nonce)];
                    case 1:
                        safeNonce = _c.sent();
                        return [4 /*yield*/, this.getChainId()];
                    case 2:
                        chainId = _c.sent();
                        versions = details.versions.map(function (it) { return (0, stark_1.toTransactionVersion)(it); });
                        tx0Payload = 'payload' in invocations[0] ? invocations[0].payload : invocations[0];
                        if (!(invocations[0].type === types_1.TransactionType.DEPLOY_ACCOUNT)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getCairoVersion(tx0Payload.classHash)];
                    case 3:
                        _b = _c.sent();
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, this.getCairoVersion()];
                    case 5:
                        _b = _c.sent();
                        _c.label = 6;
                    case 6:
                        cairoVersion = _b;
                        return [2 /*return*/, Promise.all([].concat(invocations).map(function (transaction, index) { return __awaiter(_this, void 0, void 0, function () {
                                var txPayload, signerDetails, common, versionX, payload, versionX, calls, payload, versionX, payload, versionX, payload;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            txPayload = 'payload' in transaction ? transaction.payload : transaction;
                                            signerDetails = __assign(__assign({}, (0, stark_1.v3Details)(details)), { walletAddress: this.address, nonce: (0, num_1.toBigInt)(Number(safeNonce) + index), maxFee: constants_1.ZERO, chainId: chainId, cairoVersion: cairoVersion, version: '', skipValidate: skipValidate });
                                            common = {
                                                type: transaction.type,
                                                nonce: (0, num_1.toBigInt)(Number(safeNonce) + index),
                                                blockIdentifier: blockIdentifier,
                                                version: '',
                                            };
                                            if (!(transaction.type === types_1.TransactionType.INVOKE)) return [3 /*break*/, 2];
                                            versionX = (0, stark_1.reduceV2)(versions[1]);
                                            signerDetails.version = versionX;
                                            common.version = versionX;
                                            return [4 /*yield*/, this.buildInvocation([].concat(txPayload), signerDetails)];
                                        case 1:
                                            payload = _a.sent();
                                            return [2 /*return*/, __assign(__assign({}, common), payload)];
                                        case 2:
                                            if (!(transaction.type === types_1.TransactionType.DEPLOY)) return [3 /*break*/, 4];
                                            versionX = (0, stark_1.reduceV2)(versions[1]);
                                            signerDetails.version = versionX;
                                            common.version = versionX;
                                            calls = this.buildUDCContractPayload(txPayload);
                                            return [4 /*yield*/, this.buildInvocation(calls, signerDetails)];
                                        case 3:
                                            payload = _a.sent();
                                            return [2 /*return*/, __assign(__assign(__assign({}, common), payload), { type: types_1.TransactionType.INVOKE })];
                                        case 4:
                                            if (!(transaction.type === types_1.TransactionType.DECLARE)) return [3 /*break*/, 6];
                                            versionX = !(0, contract_1.isSierra)(txPayload.contract) ? versions[0] : versions[1];
                                            signerDetails.version = versionX;
                                            common.version = versionX;
                                            return [4 /*yield*/, this.buildDeclarePayload(txPayload, signerDetails)];
                                        case 5:
                                            payload = _a.sent();
                                            return [2 /*return*/, __assign(__assign({}, common), payload)];
                                        case 6:
                                            if (!(transaction.type === types_1.TransactionType.DEPLOY_ACCOUNT)) return [3 /*break*/, 8];
                                            versionX = (0, stark_1.reduceV2)(versions[1]);
                                            signerDetails.version = versionX;
                                            common.version = versionX;
                                            return [4 /*yield*/, this.buildAccountDeployPayload(txPayload, signerDetails)];
                                        case 7:
                                            payload = _a.sent();
                                            return [2 /*return*/, __assign(__assign({}, common), payload)];
                                        case 8: throw Error("accountInvocationsFactory: unsupported transaction type: ".concat(transaction));
                                    }
                                });
                            }); }))];
                }
            });
        });
    };
    Account.prototype.getStarkName = function () {
        return __awaiter(this, arguments, void 0, function (address, // default to the wallet address
        StarknetIdContract) {
            if (address === void 0) { address = this.address; }
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.getStarkName.call(this, address, StarknetIdContract)];
            });
        });
    };
    return Account;
}(provider_1.Provider));
exports.Account = Account;

},{"../constants":102,"../provider":111,"../signer":116,"../types":128,"../types/api":119,"../utils/calldata":152,"../utils/contract":161,"../utils/events":165,"../utils/hash":168,"../utils/num":175,"../utils/provider":176,"../utils/shortString":180,"../utils/stark":181,"../utils/transaction":183,"../utils/typedData":185}],97:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./default"), exports);
__exportStar(require("./interface"), exports);

},{"./default":96,"./interface":98}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountInterface = void 0;
var provider_1 = require("../provider");
var AccountInterface = /** @class */ (function (_super) {
    __extends(AccountInterface, _super);
    function AccountInterface() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AccountInterface;
}(provider_1.ProviderInterface));
exports.AccountInterface = AccountInterface;

},{"../provider":111}],99:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPC07 = exports.RPC06 = void 0;
exports.RPC06 = require("./rpc_0_6");
exports.RPC07 = require("./rpc_0_7");
__exportStar(require("./rpc_0_7"), exports);

},{"./rpc_0_6":100,"./rpc_0_7":101}],100:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcChannel = void 0;
var constants_1 = require("../constants");
var errors_1 = require("../provider/errors");
var types_1 = require("../types");
var api_1 = require("../types/api");
var calldata_1 = require("../utils/calldata");
var contract_1 = require("../utils/contract");
var eth_1 = require("../utils/eth");
var fetchPonyfill_1 = require("../utils/fetchPonyfill");
var hash_1 = require("../utils/hash");
var json_1 = require("../utils/json");
var num_1 = require("../utils/num");
var provider_1 = require("../utils/provider");
var stark_1 = require("../utils/stark");
var transaction_1 = require("../utils/transaction");
var defaultOptions = {
    headers: { 'Content-Type': 'application/json' },
    blockIdentifier: types_1.BlockTag.PENDING,
    retries: 200,
};
var RpcChannel = /** @class */ (function () {
    function RpcChannel(optionsOrProvider) {
        var _a = optionsOrProvider || {}, nodeUrl = _a.nodeUrl, retries = _a.retries, headers = _a.headers, blockIdentifier = _a.blockIdentifier, chainId = _a.chainId, specVersion = _a.specVersion, waitMode = _a.waitMode;
        if (Object.values(constants_1.NetworkName).includes(nodeUrl)) {
            this.nodeUrl = (0, provider_1.getDefaultNodeUrl)(nodeUrl, optionsOrProvider === null || optionsOrProvider === void 0 ? void 0 : optionsOrProvider.default);
        }
        else if (nodeUrl) {
            this.nodeUrl = nodeUrl;
        }
        else {
            this.nodeUrl = (0, provider_1.getDefaultNodeUrl)(undefined, optionsOrProvider === null || optionsOrProvider === void 0 ? void 0 : optionsOrProvider.default);
        }
        this.retries = retries || defaultOptions.retries;
        this.headers = __assign(__assign({}, defaultOptions.headers), headers);
        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;
        this.chainId = chainId;
        this.specVersion = specVersion;
        this.waitMode = waitMode || false;
        this.requestId = 0;
    }
    RpcChannel.prototype.setChainId = function (chainId) {
        this.chainId = chainId;
    };
    RpcChannel.prototype.fetch = function (method, params, id) {
        if (id === void 0) { id = 0; }
        var rpcRequestBody = __assign({ id: id, jsonrpc: '2.0', method: method }, (params && { params: params }));
        return (0, fetchPonyfill_1.default)(this.nodeUrl, {
            method: 'POST',
            body: (0, json_1.stringify)(rpcRequestBody),
            headers: this.headers,
        });
    };
    RpcChannel.prototype.errorHandler = function (method, params, rpcError, otherError) {
        if (rpcError) {
            var code = rpcError.code, message = rpcError.message, data = rpcError.data;
            throw new errors_1.LibraryError("RPC: ".concat(method, " with params ").concat((0, json_1.stringify)(params, null, 2), "\n\n        ").concat(code, ": ").concat(message, ": ").concat((0, json_1.stringify)(data)));
        }
        if (otherError instanceof errors_1.LibraryError) {
            throw otherError;
        }
        if (otherError) {
            throw Error(otherError.message);
        }
    };
    RpcChannel.prototype.fetchEndpoint = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var rawResult, _a, error, result, error_1;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, this.fetch(method, params, (this.requestId += 1))];
                    case 1:
                        rawResult = _c.sent();
                        return [4 /*yield*/, rawResult.json()];
                    case 2:
                        _a = _c.sent(), error = _a.error, result = _a.result;
                        this.errorHandler(method, params, error);
                        return [2 /*return*/, result];
                    case 3:
                        error_1 = _c.sent();
                        this.errorHandler(method, params, (_b = error_1 === null || error_1 === void 0 ? void 0 : error_1.response) === null || _b === void 0 ? void 0 : _b.data, error_1);
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    RpcChannel.prototype.getChainId = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!((_c = this.chainId) !== null && _c !== void 0)) return [3 /*break*/, 1];
                        _a = _c;
                        return [3 /*break*/, 3];
                    case 1:
                        _b = this;
                        return [4 /*yield*/, this.fetchEndpoint('starknet_chainId')];
                    case 2:
                        _a = (_b.chainId = (_d.sent()));
                        _d.label = 3;
                    case 3:
                        _a;
                        return [2 /*return*/, this.chainId];
                }
            });
        });
    };
    RpcChannel.prototype.getSpecVersion = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!((_c = this.specVersion) !== null && _c !== void 0)) return [3 /*break*/, 1];
                        _a = _c;
                        return [3 /*break*/, 3];
                    case 1:
                        _b = this;
                        return [4 /*yield*/, this.fetchEndpoint('starknet_specVersion')];
                    case 2:
                        _a = (_b.specVersion = (_d.sent()));
                        _d.label = 3;
                    case 3:
                        _a;
                        return [2 /*return*/, this.specVersion];
                }
            });
        });
    };
    RpcChannel.prototype.getNonceForAddress = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getNonce', {
            contract_address: contract_address,
            block_id: block_id,
        });
    };
    /**
     * Get the most recent accepted block hash and number
     */
    RpcChannel.prototype.getBlockLatestAccepted = function () {
        return this.fetchEndpoint('starknet_blockHashAndNumber');
    };
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    RpcChannel.prototype.getBlockNumber = function () {
        return this.fetchEndpoint('starknet_blockNumber');
    };
    RpcChannel.prototype.getBlockWithTxHashes = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockWithTxs = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockStateUpdate = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getStateUpdate', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockTransactionsTraces = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockTransactionCount = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id: block_id });
    };
    RpcChannel.prototype.getTransactionByHash = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_getTransactionByHash', {
            transaction_hash: transaction_hash,
        });
    };
    RpcChannel.prototype.getTransactionByBlockIdAndIndex = function (blockIdentifier, index) {
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id: block_id, index: index });
    };
    RpcChannel.prototype.getTransactionReceipt = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash: transaction_hash });
    };
    RpcChannel.prototype.getTransactionTrace = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash: transaction_hash });
    };
    /**
     * Get the status of a transaction
     */
    RpcChannel.prototype.getTransactionStatus = function (transactionHash) {
        var transaction_hash = (0, num_1.toHex)(transactionHash);
        return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash: transaction_hash });
    };
    /**
     * @param invocations AccountInvocations
     * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    RpcChannel.prototype.simulateTransaction = function (invocations, simulateTransactionOptions) {
        var _this = this;
        if (simulateTransactionOptions === void 0) { simulateTransactionOptions = {}; }
        var _a = simulateTransactionOptions.blockIdentifier, blockIdentifier = _a === void 0 ? this.blockIdentifier : _a, _b = simulateTransactionOptions.skipValidate, skipValidate = _b === void 0 ? true : _b, _c = simulateTransactionOptions.skipFeeCharge, skipFeeCharge = _c === void 0 ? true : _c;
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        var simulationFlags = [];
        if (skipValidate)
            simulationFlags.push(api_1.RPCSPEC06.ESimulationFlag.SKIP_VALIDATE);
        if (skipFeeCharge)
            simulationFlags.push(api_1.RPCSPEC06.ESimulationFlag.SKIP_FEE_CHARGE);
        return this.fetchEndpoint('starknet_simulateTransactions', {
            block_id: block_id,
            transactions: invocations.map(function (it) { return _this.buildTransaction(it); }),
            simulation_flags: simulationFlags,
        });
    };
    RpcChannel.prototype.waitForTransaction = function (txHash, options) {
        return __awaiter(this, void 0, void 0, function () {
            var transactionHash, retries, onchain, isErrorState, retryInterval, errorStates, successStates, txStatus, executionStatus, finalityStatus, error, message, error, error_2, txReceipt, error_3;
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        transactionHash = (0, num_1.toHex)(txHash);
                        retries = this.retries;
                        onchain = false;
                        isErrorState = false;
                        retryInterval = (_a = options === null || options === void 0 ? void 0 : options.retryInterval) !== null && _a !== void 0 ? _a : 5000;
                        errorStates = (_b = options === null || options === void 0 ? void 0 : options.errorStates) !== null && _b !== void 0 ? _b : [
                            api_1.RPCSPEC06.ETransactionStatus.REJECTED,
                            // TODO: commented out to preserve the long-standing behavior of "reverted" not being treated as an error by default
                            // should decide which behavior to keep in the future
                            // RPC.ETransactionExecutionStatus.REVERTED,
                        ];
                        successStates = (_c = options === null || options === void 0 ? void 0 : options.successStates) !== null && _c !== void 0 ? _c : [
                            api_1.RPCSPEC06.ETransactionExecutionStatus.SUCCEEDED,
                            api_1.RPCSPEC06.ETransactionStatus.ACCEPTED_ON_L2,
                            api_1.RPCSPEC06.ETransactionStatus.ACCEPTED_ON_L1,
                        ];
                        _d.label = 1;
                    case 1:
                        if (!!onchain) return [3 /*break*/, 7];
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, (0, provider_1.wait)(retryInterval)];
                    case 2:
                        // eslint-disable-next-line no-await-in-loop
                        _d.sent();
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.getTransactionStatus(transactionHash)];
                    case 4:
                        // eslint-disable-next-line no-await-in-loop
                        txStatus = _d.sent();
                        executionStatus = txStatus.execution_status;
                        finalityStatus = txStatus.finality_status;
                        if (!finalityStatus) {
                            error = new Error('waiting for transaction status');
                            throw error;
                        }
                        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
                            message = "".concat(executionStatus, ": ").concat(finalityStatus);
                            error = new Error(message);
                            error.response = txStatus;
                            isErrorState = true;
                            throw error;
                        }
                        else if (successStates.includes(executionStatus) ||
                            successStates.includes(finalityStatus)) {
                            onchain = true;
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        error_2 = _d.sent();
                        if (error_2 instanceof Error && isErrorState) {
                            throw error_2;
                        }
                        if (retries <= 0) {
                            throw new Error("waitForTransaction timed-out with retries ".concat(this.retries));
                        }
                        return [3 /*break*/, 6];
                    case 6:
                        retries -= 1;
                        return [3 /*break*/, 1];
                    case 7:
                        txReceipt = null;
                        _d.label = 8;
                    case 8:
                        if (!(txReceipt === null)) return [3 /*break*/, 14];
                        _d.label = 9;
                    case 9:
                        _d.trys.push([9, 11, , 12]);
                        return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];
                    case 10:
                        // eslint-disable-next-line no-await-in-loop
                        txReceipt = _d.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        error_3 = _d.sent();
                        if (retries <= 0) {
                            throw new Error("waitForTransaction timed-out with retries ".concat(this.retries));
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        retries -= 1;
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, (0, provider_1.wait)(retryInterval)];
                    case 13:
                        // eslint-disable-next-line no-await-in-loop
                        _d.sent();
                        return [3 /*break*/, 8];
                    case 14: return [2 /*return*/, txReceipt];
                }
            });
        });
    };
    RpcChannel.prototype.getStorageAt = function (contractAddress, key, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var parsedKey = (0, num_1.toStorageKey)(key);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getStorageAt', {
            contract_address: contract_address,
            key: parsedKey,
            block_id: block_id,
        });
    };
    RpcChannel.prototype.getClassHashAt = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClassHashAt', {
            block_id: block_id,
            contract_address: contract_address,
        });
    };
    RpcChannel.prototype.getClass = function (classHash, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var class_hash = (0, num_1.toHex)(classHash);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClass', {
            class_hash: class_hash,
            block_id: block_id,
        });
    };
    RpcChannel.prototype.getClassAt = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClassAt', {
            block_id: block_id,
            contract_address: contract_address,
        });
    };
    RpcChannel.prototype.getEstimateFee = function (invocations_1, _a) {
        return __awaiter(this, arguments, void 0, function (invocations, _b) {
            var block_id, flags, _c, _d;
            var _this = this;
            var _e = _b.blockIdentifier, blockIdentifier = _e === void 0 ? this.blockIdentifier : _e, _f = _b.skipValidate, skipValidate = _f === void 0 ? true : _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        block_id = new provider_1.Block(blockIdentifier).identifier;
                        flags = {};
                        _c = provider_1.isVersion;
                        _d = ['0.5'];
                        return [4 /*yield*/, this.getSpecVersion()];
                    case 1:
                        if (!_c.apply(void 0, _d.concat([_g.sent()]))) {
                            flags = {
                                simulation_flags: skipValidate ? [api_1.RPCSPEC06.ESimulationFlag.SKIP_VALIDATE] : [],
                            };
                        } // else v(0.5) no flags
                        return [2 /*return*/, this.fetchEndpoint('starknet_estimateFee', __assign({ request: invocations.map(function (it) { return _this.buildTransaction(it, 'fee'); }), block_id: block_id }, flags))];
                }
            });
        });
    };
    RpcChannel.prototype.invoke = function (functionInvocation, details) {
        return __awaiter(this, void 0, void 0, function () {
            var promise, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(0, provider_1.isV3Tx)(details)) {
                            // V1
                            promise = this.fetchEndpoint('starknet_addInvokeTransaction', {
                                invoke_transaction: {
                                    sender_address: functionInvocation.contractAddress,
                                    calldata: calldata_1.CallData.toHex(functionInvocation.calldata),
                                    type: api_1.RPCSPEC06.ETransactionType.INVOKE,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    version: api_1.RPCSPEC06.ETransactionVersion.V1,
                                    signature: (0, stark_1.signatureToHexArray)(functionInvocation.signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else {
                            // V3
                            promise = this.fetchEndpoint('starknet_addInvokeTransaction', {
                                invoke_transaction: {
                                    type: api_1.RPCSPEC06.ETransactionType.INVOKE,
                                    sender_address: functionInvocation.contractAddress,
                                    calldata: calldata_1.CallData.toHex(functionInvocation.calldata),
                                    version: api_1.RPCSPEC06.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(functionInvocation.signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    account_deployment_data: details.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _b = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _a = _b.apply(this, [(_c.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _a = promise;
                        _c.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
    RpcChannel.prototype.declare = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var promise, _c, _d;
            var contract = _b.contract, signature = _b.signature, senderAddress = _b.senderAddress, compiledClassHash = _b.compiledClassHash;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!(0, contract_1.isSierra)(contract) && !(0, provider_1.isV3Tx)(details)) {
                            // V1 Cairo 0
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC06.ETransactionType.DECLARE,
                                    contract_class: {
                                        program: contract.program,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    version: api_1.RPCSPEC06.ETransactionVersion.V1,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    sender_address: senderAddress,
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else if ((0, contract_1.isSierra)(contract) && !(0, provider_1.isV3Tx)(details)) {
                            // V2 Cairo1
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC06.ETransactionType.DECLARE,
                                    contract_class: {
                                        sierra_program: (0, stark_1.decompressProgram)(contract.sierra_program),
                                        contract_class_version: contract.contract_class_version,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    compiled_class_hash: compiledClassHash || '',
                                    version: api_1.RPCSPEC06.ETransactionVersion.V2,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    sender_address: senderAddress,
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else if ((0, contract_1.isSierra)(contract) && (0, provider_1.isV3Tx)(details)) {
                            // V3 Cairo1
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC06.ETransactionType.DECLARE,
                                    sender_address: senderAddress,
                                    compiled_class_hash: compiledClassHash || '',
                                    version: api_1.RPCSPEC06.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    contract_class: {
                                        sierra_program: (0, stark_1.decompressProgram)(contract.sierra_program),
                                        contract_class_version: contract.contract_class_version,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    account_deployment_data: details.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        else {
                            throw Error('declare unspotted parameters');
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _d = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _c = _d.apply(this, [(_e.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _c = promise;
                        _e.label = 3;
                    case 3: return [2 /*return*/, _c];
                }
            });
        });
    };
    RpcChannel.prototype.deployAccount = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var promise, _c, _d;
            var classHash = _b.classHash, constructorCalldata = _b.constructorCalldata, addressSalt = _b.addressSalt, signature = _b.signature;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!(0, provider_1.isV3Tx)(details)) {
                            // v1
                            promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {
                                deploy_account_transaction: {
                                    constructor_calldata: calldata_1.CallData.toHex(constructorCalldata || []),
                                    class_hash: (0, num_1.toHex)(classHash),
                                    contract_address_salt: (0, num_1.toHex)(addressSalt || 0),
                                    type: api_1.RPCSPEC06.ETransactionType.DEPLOY_ACCOUNT,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    version: api_1.RPCSPEC06.ETransactionVersion.V1,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else {
                            // v3
                            promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {
                                deploy_account_transaction: {
                                    type: api_1.RPCSPEC06.ETransactionType.DEPLOY_ACCOUNT,
                                    version: api_1.RPCSPEC06.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    contract_address_salt: (0, num_1.toHex)(addressSalt || 0),
                                    constructor_calldata: calldata_1.CallData.toHex(constructorCalldata || []),
                                    class_hash: (0, num_1.toHex)(classHash),
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _d = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _c = _d.apply(this, [(_e.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _c = promise;
                        _e.label = 3;
                    case 3: return [2 /*return*/, _c];
                }
            });
        });
    };
    RpcChannel.prototype.callContract = function (call, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_call', {
            request: {
                contract_address: call.contractAddress,
                entry_point_selector: (0, hash_1.getSelectorFromName)(call.entrypoint),
                calldata: calldata_1.CallData.toHex(call.calldata),
            },
            block_id: block_id,
        });
    };
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    RpcChannel.prototype.estimateMessageFee = function (message, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var from_address = message.from_address, to_address = message.to_address, entry_point_selector = message.entry_point_selector, payload = message.payload;
        var formattedMessage = {
            from_address: (0, eth_1.validateAndParseEthAddress)(from_address),
            to_address: (0, num_1.toHex)(to_address),
            entry_point_selector: (0, hash_1.getSelector)(entry_point_selector),
            payload: (0, num_1.getHexStringArray)(payload),
        };
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_estimateMessageFee', {
            message: formattedMessage,
            block_id: block_id,
        });
    };
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    RpcChannel.prototype.getSyncingStats = function () {
        return this.fetchEndpoint('starknet_syncing');
    };
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    RpcChannel.prototype.getEvents = function (eventFilter) {
        return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });
    };
    RpcChannel.prototype.buildTransaction = function (invocation, versionType) {
        var defaultVersions = (0, transaction_1.getVersionsByType)(versionType);
        var details;
        if (!(0, provider_1.isV3Tx)(invocation)) {
            // V0,V1,V2
            details = {
                signature: (0, stark_1.signatureToHexArray)(invocation.signature),
                nonce: (0, num_1.toHex)(invocation.nonce),
                max_fee: (0, num_1.toHex)(invocation.maxFee || 0),
            };
        }
        else {
            // V3
            details = {
                signature: (0, stark_1.signatureToHexArray)(invocation.signature),
                nonce: (0, num_1.toHex)(invocation.nonce),
                resource_bounds: invocation.resourceBounds,
                tip: (0, num_1.toHex)(invocation.tip),
                paymaster_data: invocation.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
                fee_data_availability_mode: invocation.feeDataAvailabilityMode,
                account_deployment_data: invocation.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
            };
        }
        if (invocation.type === types_1.TransactionType.INVOKE) {
            return __assign({ 
                // v0 v1 v3
                type: api_1.RPCSPEC06.ETransactionType.INVOKE, sender_address: invocation.contractAddress, calldata: calldata_1.CallData.toHex(invocation.calldata), version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, details);
        }
        if (invocation.type === types_1.TransactionType.DECLARE) {
            if (!(0, contract_1.isSierra)(invocation.contract)) {
                // Cairo 0 - v1
                return __assign({ type: invocation.type, contract_class: invocation.contract, sender_address: invocation.senderAddress, version: (0, num_1.toHex)(invocation.version || defaultVersions.v1) }, details);
            }
            return __assign({ 
                // Cairo 1 - v2 v3
                type: invocation.type, contract_class: __assign(__assign({}, invocation.contract), { sierra_program: (0, stark_1.decompressProgram)(invocation.contract.sierra_program) }), compiled_class_hash: invocation.compiledClassHash || '', sender_address: invocation.senderAddress, version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, details);
        }
        if (invocation.type === types_1.TransactionType.DEPLOY_ACCOUNT) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var account_deployment_data = details.account_deployment_data, restDetails = __rest(details, ["account_deployment_data"]);
            // v1 v3
            return __assign({ type: invocation.type, constructor_calldata: calldata_1.CallData.toHex(invocation.constructorCalldata || []), class_hash: (0, num_1.toHex)(invocation.classHash), contract_address_salt: (0, num_1.toHex)(invocation.addressSalt || 0), version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, restDetails);
        }
        throw Error('RPC buildTransaction received unknown TransactionType');
    };
    return RpcChannel;
}());
exports.RpcChannel = RpcChannel;

},{"../constants":102,"../provider/errors":108,"../types":128,"../types/api":119,"../utils/calldata":152,"../utils/contract":161,"../utils/eth":164,"../utils/fetchPonyfill":166,"../utils/hash":168,"../utils/json":173,"../utils/num":175,"../utils/provider":176,"../utils/stark":181,"../utils/transaction":183}],101:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcChannel = void 0;
var constants_1 = require("../constants");
var errors_1 = require("../provider/errors");
var types_1 = require("../types");
var api_1 = require("../types/api");
var calldata_1 = require("../utils/calldata");
var contract_1 = require("../utils/contract");
var eth_1 = require("../utils/eth");
var fetchPonyfill_1 = require("../utils/fetchPonyfill");
var hash_1 = require("../utils/hash");
var json_1 = require("../utils/json");
var num_1 = require("../utils/num");
var provider_1 = require("../utils/provider");
var stark_1 = require("../utils/stark");
var transaction_1 = require("../utils/transaction");
var defaultOptions = {
    headers: { 'Content-Type': 'application/json' },
    blockIdentifier: types_1.BlockTag.PENDING,
    retries: 200,
};
var RpcChannel = /** @class */ (function () {
    function RpcChannel(optionsOrProvider) {
        var _a = optionsOrProvider || {}, nodeUrl = _a.nodeUrl, retries = _a.retries, headers = _a.headers, blockIdentifier = _a.blockIdentifier, chainId = _a.chainId, specVersion = _a.specVersion, waitMode = _a.waitMode, transactionRetryIntervalFallback = _a.transactionRetryIntervalFallback;
        if (Object.values(constants_1.NetworkName).includes(nodeUrl)) {
            this.nodeUrl = (0, provider_1.getDefaultNodeUrl)(nodeUrl, optionsOrProvider === null || optionsOrProvider === void 0 ? void 0 : optionsOrProvider.default);
        }
        else if (nodeUrl) {
            this.nodeUrl = nodeUrl;
        }
        else {
            this.nodeUrl = (0, provider_1.getDefaultNodeUrl)(undefined, optionsOrProvider === null || optionsOrProvider === void 0 ? void 0 : optionsOrProvider.default);
        }
        this.retries = retries || defaultOptions.retries;
        this.headers = __assign(__assign({}, defaultOptions.headers), headers);
        this.blockIdentifier = blockIdentifier || defaultOptions.blockIdentifier;
        this.chainId = chainId;
        this.specVersion = specVersion;
        this.waitMode = waitMode || false;
        this.requestId = 0;
        this.transactionRetryIntervalFallback = transactionRetryIntervalFallback;
    }
    Object.defineProperty(RpcChannel.prototype, "transactionRetryIntervalDefault", {
        get: function () {
            var _a;
            return (_a = this.transactionRetryIntervalFallback) !== null && _a !== void 0 ? _a : 5000;
        },
        enumerable: false,
        configurable: true
    });
    RpcChannel.prototype.setChainId = function (chainId) {
        this.chainId = chainId;
    };
    RpcChannel.prototype.fetch = function (method, params, id) {
        if (id === void 0) { id = 0; }
        var rpcRequestBody = __assign({ id: id, jsonrpc: '2.0', method: method }, (params && { params: params }));
        return (0, fetchPonyfill_1.default)(this.nodeUrl, {
            method: 'POST',
            body: (0, json_1.stringify)(rpcRequestBody),
            headers: this.headers,
        });
    };
    RpcChannel.prototype.errorHandler = function (method, params, rpcError, otherError) {
        if (rpcError) {
            var code = rpcError.code, message = rpcError.message, data = rpcError.data;
            throw new errors_1.LibraryError("RPC: ".concat(method, " with params ").concat((0, json_1.stringify)(params, null, 2), "\n \n        ").concat(code, ": ").concat(message, ": ").concat((0, json_1.stringify)(data)));
        }
        if (otherError instanceof errors_1.LibraryError) {
            throw otherError;
        }
        if (otherError) {
            throw Error(otherError.message);
        }
    };
    RpcChannel.prototype.fetchEndpoint = function (method, params) {
        return __awaiter(this, void 0, void 0, function () {
            var rawResult, _a, error, result, error_1;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, this.fetch(method, params, (this.requestId += 1))];
                    case 1:
                        rawResult = _c.sent();
                        return [4 /*yield*/, rawResult.json()];
                    case 2:
                        _a = _c.sent(), error = _a.error, result = _a.result;
                        this.errorHandler(method, params, error);
                        return [2 /*return*/, result];
                    case 3:
                        error_1 = _c.sent();
                        this.errorHandler(method, params, (_b = error_1 === null || error_1 === void 0 ? void 0 : error_1.response) === null || _b === void 0 ? void 0 : _b.data, error_1);
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    RpcChannel.prototype.getChainId = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!((_c = this.chainId) !== null && _c !== void 0)) return [3 /*break*/, 1];
                        _a = _c;
                        return [3 /*break*/, 3];
                    case 1:
                        _b = this;
                        return [4 /*yield*/, this.fetchEndpoint('starknet_chainId')];
                    case 2:
                        _a = (_b.chainId = (_d.sent()));
                        _d.label = 3;
                    case 3:
                        _a;
                        return [2 /*return*/, this.chainId];
                }
            });
        });
    };
    RpcChannel.prototype.getSpecVersion = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!((_c = this.specVersion) !== null && _c !== void 0)) return [3 /*break*/, 1];
                        _a = _c;
                        return [3 /*break*/, 3];
                    case 1:
                        _b = this;
                        return [4 /*yield*/, this.fetchEndpoint('starknet_specVersion')];
                    case 2:
                        _a = (_b.specVersion = (_d.sent()));
                        _d.label = 3;
                    case 3:
                        _a;
                        return [2 /*return*/, this.specVersion];
                }
            });
        });
    };
    RpcChannel.prototype.getNonceForAddress = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getNonce', {
            contract_address: contract_address,
            block_id: block_id,
        });
    };
    /**
     * Get the most recent accepted block hash and number
     */
    RpcChannel.prototype.getBlockLatestAccepted = function () {
        return this.fetchEndpoint('starknet_blockHashAndNumber');
    };
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    RpcChannel.prototype.getBlockNumber = function () {
        return this.fetchEndpoint('starknet_blockNumber');
    };
    RpcChannel.prototype.getBlockWithTxHashes = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockWithTxHashes', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockWithTxs = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockWithTxs', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockWithReceipts = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockWithReceipts', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockStateUpdate = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getStateUpdate', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockTransactionsTraces = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_traceBlockTransactions', { block_id: block_id });
    };
    RpcChannel.prototype.getBlockTransactionCount = function (blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getBlockTransactionCount', { block_id: block_id });
    };
    RpcChannel.prototype.getTransactionByHash = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_getTransactionByHash', {
            transaction_hash: transaction_hash,
        });
    };
    RpcChannel.prototype.getTransactionByBlockIdAndIndex = function (blockIdentifier, index) {
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getTransactionByBlockIdAndIndex', { block_id: block_id, index: index });
    };
    RpcChannel.prototype.getTransactionReceipt = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_getTransactionReceipt', { transaction_hash: transaction_hash });
    };
    RpcChannel.prototype.getTransactionTrace = function (txHash) {
        var transaction_hash = (0, num_1.toHex)(txHash);
        return this.fetchEndpoint('starknet_traceTransaction', { transaction_hash: transaction_hash });
    };
    /**
     * Get the status of a transaction
     */
    RpcChannel.prototype.getTransactionStatus = function (transactionHash) {
        var transaction_hash = (0, num_1.toHex)(transactionHash);
        return this.fetchEndpoint('starknet_getTransactionStatus', { transaction_hash: transaction_hash });
    };
    /**
     * @param invocations AccountInvocations
     * @param simulateTransactionOptions blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    RpcChannel.prototype.simulateTransaction = function (invocations, simulateTransactionOptions) {
        var _this = this;
        if (simulateTransactionOptions === void 0) { simulateTransactionOptions = {}; }
        var _a = simulateTransactionOptions.blockIdentifier, blockIdentifier = _a === void 0 ? this.blockIdentifier : _a, _b = simulateTransactionOptions.skipValidate, skipValidate = _b === void 0 ? true : _b, _c = simulateTransactionOptions.skipFeeCharge, skipFeeCharge = _c === void 0 ? true : _c;
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        var simulationFlags = [];
        if (skipValidate)
            simulationFlags.push(api_1.RPCSPEC07.ESimulationFlag.SKIP_VALIDATE);
        if (skipFeeCharge)
            simulationFlags.push(api_1.RPCSPEC07.ESimulationFlag.SKIP_FEE_CHARGE);
        return this.fetchEndpoint('starknet_simulateTransactions', {
            block_id: block_id,
            transactions: invocations.map(function (it) { return _this.buildTransaction(it); }),
            simulation_flags: simulationFlags,
        });
    };
    RpcChannel.prototype.waitForTransaction = function (txHash, options) {
        return __awaiter(this, void 0, void 0, function () {
            var transactionHash, retries, onchain, isErrorState, retryInterval, errorStates, successStates, txStatus, executionStatus, finalityStatus, error, message, error, error_2, txReceipt, error_3;
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        transactionHash = (0, num_1.toHex)(txHash);
                        retries = this.retries;
                        onchain = false;
                        isErrorState = false;
                        retryInterval = (_a = options === null || options === void 0 ? void 0 : options.retryInterval) !== null && _a !== void 0 ? _a : this.transactionRetryIntervalDefault;
                        errorStates = (_b = options === null || options === void 0 ? void 0 : options.errorStates) !== null && _b !== void 0 ? _b : [
                            api_1.RPCSPEC07.ETransactionStatus.REJECTED,
                            // TODO: commented out to preserve the long-standing behavior of "reverted" not being treated as an error by default
                            // should decide which behavior to keep in the future
                            // RPC.ETransactionExecutionStatus.REVERTED,
                        ];
                        successStates = (_c = options === null || options === void 0 ? void 0 : options.successStates) !== null && _c !== void 0 ? _c : [
                            api_1.RPCSPEC07.ETransactionExecutionStatus.SUCCEEDED,
                            api_1.RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L2,
                            api_1.RPCSPEC07.ETransactionStatus.ACCEPTED_ON_L1,
                        ];
                        _d.label = 1;
                    case 1:
                        if (!!onchain) return [3 /*break*/, 7];
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, (0, provider_1.wait)(retryInterval)];
                    case 2:
                        // eslint-disable-next-line no-await-in-loop
                        _d.sent();
                        _d.label = 3;
                    case 3:
                        _d.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, this.getTransactionStatus(transactionHash)];
                    case 4:
                        // eslint-disable-next-line no-await-in-loop
                        txStatus = _d.sent();
                        executionStatus = txStatus.execution_status;
                        finalityStatus = txStatus.finality_status;
                        if (!finalityStatus) {
                            error = new Error('waiting for transaction status');
                            throw error;
                        }
                        if (errorStates.includes(executionStatus) || errorStates.includes(finalityStatus)) {
                            message = "".concat(executionStatus, ": ").concat(finalityStatus);
                            error = new Error(message);
                            error.response = txStatus;
                            isErrorState = true;
                            throw error;
                        }
                        else if (successStates.includes(executionStatus) ||
                            successStates.includes(finalityStatus)) {
                            onchain = true;
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        error_2 = _d.sent();
                        if (error_2 instanceof Error && isErrorState) {
                            throw error_2;
                        }
                        if (retries <= 0) {
                            throw new Error("waitForTransaction timed-out with retries ".concat(this.retries));
                        }
                        return [3 /*break*/, 6];
                    case 6:
                        retries -= 1;
                        return [3 /*break*/, 1];
                    case 7:
                        txReceipt = null;
                        _d.label = 8;
                    case 8:
                        if (!(txReceipt === null)) return [3 /*break*/, 14];
                        _d.label = 9;
                    case 9:
                        _d.trys.push([9, 11, , 12]);
                        return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];
                    case 10:
                        // eslint-disable-next-line no-await-in-loop
                        txReceipt = _d.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        error_3 = _d.sent();
                        if (retries <= 0) {
                            throw new Error("waitForTransaction timed-out with retries ".concat(this.retries));
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        retries -= 1;
                        // eslint-disable-next-line no-await-in-loop
                        return [4 /*yield*/, (0, provider_1.wait)(retryInterval)];
                    case 13:
                        // eslint-disable-next-line no-await-in-loop
                        _d.sent();
                        return [3 /*break*/, 8];
                    case 14: return [2 /*return*/, txReceipt];
                }
            });
        });
    };
    RpcChannel.prototype.getStorageAt = function (contractAddress, key, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var parsedKey = (0, num_1.toStorageKey)(key);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getStorageAt', {
            contract_address: contract_address,
            key: parsedKey,
            block_id: block_id,
        });
    };
    RpcChannel.prototype.getClassHashAt = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClassHashAt', {
            block_id: block_id,
            contract_address: contract_address,
        });
    };
    RpcChannel.prototype.getClass = function (classHash, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var class_hash = (0, num_1.toHex)(classHash);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClass', {
            class_hash: class_hash,
            block_id: block_id,
        });
    };
    RpcChannel.prototype.getClassAt = function (contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var contract_address = (0, num_1.toHex)(contractAddress);
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_getClassAt', {
            block_id: block_id,
            contract_address: contract_address,
        });
    };
    RpcChannel.prototype.getEstimateFee = function (invocations_1, _a) {
        return __awaiter(this, arguments, void 0, function (invocations, _b) {
            var block_id, flags, _c, _d;
            var _this = this;
            var _e = _b.blockIdentifier, blockIdentifier = _e === void 0 ? this.blockIdentifier : _e, _f = _b.skipValidate, skipValidate = _f === void 0 ? true : _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        block_id = new provider_1.Block(blockIdentifier).identifier;
                        flags = {};
                        _c = provider_1.isVersion;
                        _d = ['0.5'];
                        return [4 /*yield*/, this.getSpecVersion()];
                    case 1:
                        if (!_c.apply(void 0, _d.concat([_g.sent()]))) {
                            flags = {
                                simulation_flags: skipValidate ? [api_1.RPCSPEC07.ESimulationFlag.SKIP_VALIDATE] : [],
                            };
                        } // else v(0.5) no flags
                        return [2 /*return*/, this.fetchEndpoint('starknet_estimateFee', __assign({ request: invocations.map(function (it) { return _this.buildTransaction(it, 'fee'); }), block_id: block_id }, flags))];
                }
            });
        });
    };
    RpcChannel.prototype.invoke = function (functionInvocation, details) {
        return __awaiter(this, void 0, void 0, function () {
            var promise, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!(0, provider_1.isV3Tx)(details)) {
                            // V1
                            promise = this.fetchEndpoint('starknet_addInvokeTransaction', {
                                invoke_transaction: {
                                    sender_address: functionInvocation.contractAddress,
                                    calldata: calldata_1.CallData.toHex(functionInvocation.calldata),
                                    type: api_1.RPCSPEC07.ETransactionType.INVOKE,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    version: api_1.RPCSPEC07.ETransactionVersion.V1,
                                    signature: (0, stark_1.signatureToHexArray)(functionInvocation.signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else {
                            // V3
                            promise = this.fetchEndpoint('starknet_addInvokeTransaction', {
                                invoke_transaction: {
                                    type: api_1.RPCSPEC07.ETransactionType.INVOKE,
                                    sender_address: functionInvocation.contractAddress,
                                    calldata: calldata_1.CallData.toHex(functionInvocation.calldata),
                                    version: api_1.RPCSPEC07.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(functionInvocation.signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    account_deployment_data: details.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _b = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _a = _b.apply(this, [(_c.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _a = promise;
                        _c.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
    RpcChannel.prototype.declare = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var promise, _c, _d;
            var contract = _b.contract, signature = _b.signature, senderAddress = _b.senderAddress, compiledClassHash = _b.compiledClassHash;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!(0, contract_1.isSierra)(contract) && !(0, provider_1.isV3Tx)(details)) {
                            // V1 Cairo 0
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC07.ETransactionType.DECLARE,
                                    contract_class: {
                                        program: contract.program,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    version: api_1.RPCSPEC07.ETransactionVersion.V1,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    sender_address: senderAddress,
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else if ((0, contract_1.isSierra)(contract) && !(0, provider_1.isV3Tx)(details)) {
                            // V2 Cairo1
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC07.ETransactionType.DECLARE,
                                    contract_class: {
                                        sierra_program: (0, stark_1.decompressProgram)(contract.sierra_program),
                                        contract_class_version: contract.contract_class_version,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    compiled_class_hash: compiledClassHash || '',
                                    version: api_1.RPCSPEC07.ETransactionVersion.V2,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    sender_address: senderAddress,
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else if ((0, contract_1.isSierra)(contract) && (0, provider_1.isV3Tx)(details)) {
                            // V3 Cairo1
                            promise = this.fetchEndpoint('starknet_addDeclareTransaction', {
                                declare_transaction: {
                                    type: api_1.RPCSPEC07.ETransactionType.DECLARE,
                                    sender_address: senderAddress,
                                    compiled_class_hash: compiledClassHash || '',
                                    version: api_1.RPCSPEC07.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    contract_class: {
                                        sierra_program: (0, stark_1.decompressProgram)(contract.sierra_program),
                                        contract_class_version: contract.contract_class_version,
                                        entry_points_by_type: contract.entry_points_by_type,
                                        abi: contract.abi,
                                    },
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    account_deployment_data: details.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        else {
                            throw Error('declare unspotted parameters');
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _d = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _c = _d.apply(this, [(_e.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _c = promise;
                        _e.label = 3;
                    case 3: return [2 /*return*/, _c];
                }
            });
        });
    };
    RpcChannel.prototype.deployAccount = function (_a, details_1) {
        return __awaiter(this, arguments, void 0, function (_b, details) {
            var promise, _c, _d;
            var classHash = _b.classHash, constructorCalldata = _b.constructorCalldata, addressSalt = _b.addressSalt, signature = _b.signature;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!(0, provider_1.isV3Tx)(details)) {
                            // v1
                            promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {
                                deploy_account_transaction: {
                                    constructor_calldata: calldata_1.CallData.toHex(constructorCalldata || []),
                                    class_hash: (0, num_1.toHex)(classHash),
                                    contract_address_salt: (0, num_1.toHex)(addressSalt || 0),
                                    type: api_1.RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
                                    max_fee: (0, num_1.toHex)(details.maxFee || 0),
                                    version: api_1.RPCSPEC07.ETransactionVersion.V1,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                },
                            });
                        }
                        else {
                            // v3
                            promise = this.fetchEndpoint('starknet_addDeployAccountTransaction', {
                                deploy_account_transaction: {
                                    type: api_1.RPCSPEC07.ETransactionType.DEPLOY_ACCOUNT,
                                    version: api_1.RPCSPEC07.ETransactionVersion.V3,
                                    signature: (0, stark_1.signatureToHexArray)(signature),
                                    nonce: (0, num_1.toHex)(details.nonce),
                                    contract_address_salt: (0, num_1.toHex)(addressSalt || 0),
                                    constructor_calldata: calldata_1.CallData.toHex(constructorCalldata || []),
                                    class_hash: (0, num_1.toHex)(classHash),
                                    resource_bounds: details.resourceBounds,
                                    tip: (0, num_1.toHex)(details.tip),
                                    paymaster_data: details.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                                    nonce_data_availability_mode: details.nonceDataAvailabilityMode,
                                    fee_data_availability_mode: details.feeDataAvailabilityMode,
                                },
                            });
                        }
                        if (!this.waitMode) return [3 /*break*/, 2];
                        _d = this.waitForTransaction;
                        return [4 /*yield*/, promise];
                    case 1:
                        _c = _d.apply(this, [(_e.sent()).transaction_hash]);
                        return [3 /*break*/, 3];
                    case 2:
                        _c = promise;
                        _e.label = 3;
                    case 3: return [2 /*return*/, _c];
                }
            });
        });
    };
    RpcChannel.prototype.callContract = function (call, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_call', {
            request: {
                contract_address: call.contractAddress,
                entry_point_selector: (0, hash_1.getSelectorFromName)(call.entrypoint),
                calldata: calldata_1.CallData.toHex(call.calldata),
            },
            block_id: block_id,
        });
    };
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    RpcChannel.prototype.estimateMessageFee = function (message, blockIdentifier) {
        if (blockIdentifier === void 0) { blockIdentifier = this.blockIdentifier; }
        var from_address = message.from_address, to_address = message.to_address, entry_point_selector = message.entry_point_selector, payload = message.payload;
        var formattedMessage = {
            from_address: (0, eth_1.validateAndParseEthAddress)(from_address),
            to_address: (0, num_1.toHex)(to_address),
            entry_point_selector: (0, hash_1.getSelector)(entry_point_selector),
            payload: (0, num_1.getHexStringArray)(payload),
        };
        var block_id = new provider_1.Block(blockIdentifier).identifier;
        return this.fetchEndpoint('starknet_estimateMessageFee', {
            message: formattedMessage,
            block_id: block_id,
        });
    };
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    RpcChannel.prototype.getSyncingStats = function () {
        return this.fetchEndpoint('starknet_syncing');
    };
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    RpcChannel.prototype.getEvents = function (eventFilter) {
        return this.fetchEndpoint('starknet_getEvents', { filter: eventFilter });
    };
    RpcChannel.prototype.buildTransaction = function (invocation, versionType) {
        var defaultVersions = (0, transaction_1.getVersionsByType)(versionType);
        var details;
        if (!(0, provider_1.isV3Tx)(invocation)) {
            // V0,V1,V2
            details = {
                signature: (0, stark_1.signatureToHexArray)(invocation.signature),
                nonce: (0, num_1.toHex)(invocation.nonce),
                max_fee: (0, num_1.toHex)(invocation.maxFee || 0),
            };
        }
        else {
            // V3
            details = {
                signature: (0, stark_1.signatureToHexArray)(invocation.signature),
                nonce: (0, num_1.toHex)(invocation.nonce),
                resource_bounds: invocation.resourceBounds,
                tip: (0, num_1.toHex)(invocation.tip),
                paymaster_data: invocation.paymasterData.map(function (it) { return (0, num_1.toHex)(it); }),
                nonce_data_availability_mode: invocation.nonceDataAvailabilityMode,
                fee_data_availability_mode: invocation.feeDataAvailabilityMode,
                account_deployment_data: invocation.accountDeploymentData.map(function (it) { return (0, num_1.toHex)(it); }),
            };
        }
        if (invocation.type === types_1.TransactionType.INVOKE) {
            return __assign({ 
                // v0 v1 v3
                type: api_1.RPCSPEC07.ETransactionType.INVOKE, sender_address: invocation.contractAddress, calldata: calldata_1.CallData.toHex(invocation.calldata), version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, details);
        }
        if (invocation.type === types_1.TransactionType.DECLARE) {
            if (!(0, contract_1.isSierra)(invocation.contract)) {
                // Cairo 0 - v1
                return __assign({ type: invocation.type, contract_class: invocation.contract, sender_address: invocation.senderAddress, version: (0, num_1.toHex)(invocation.version || defaultVersions.v1) }, details);
            }
            return __assign({ 
                // Cairo 1 - v2 v3
                type: invocation.type, contract_class: __assign(__assign({}, invocation.contract), { sierra_program: (0, stark_1.decompressProgram)(invocation.contract.sierra_program) }), compiled_class_hash: invocation.compiledClassHash || '', sender_address: invocation.senderAddress, version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, details);
        }
        if (invocation.type === types_1.TransactionType.DEPLOY_ACCOUNT) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var account_deployment_data = details.account_deployment_data, restDetails = __rest(details, ["account_deployment_data"]);
            // v1 v3
            return __assign({ type: invocation.type, constructor_calldata: calldata_1.CallData.toHex(invocation.constructorCalldata || []), class_hash: (0, num_1.toHex)(invocation.classHash), contract_address_salt: (0, num_1.toHex)(invocation.addressSalt || 0), version: (0, num_1.toHex)(invocation.version || defaultVersions.v3) }, restDetails);
        }
        throw Error('RPC buildTransaction received unknown TransactionType');
    };
    return RpcChannel;
}());
exports.RpcChannel = RpcChannel;

},{"../constants":102,"../provider/errors":108,"../types":128,"../types/api":119,"../utils/calldata":152,"../utils/contract":161,"../utils/eth":164,"../utils/fetchPonyfill":166,"../utils/hash":168,"../utils/json":173,"../utils/num":175,"../utils/provider":176,"../utils/stark":181,"../utils/transaction":183}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPC_NODES = exports.RPC_DEFAULT_VERSION = exports.UDC = exports.TransactionHashPrefix = exports.StarknetChainId = exports.NetworkName = exports.BaseUrl = exports.RANGE_U128 = exports.RANGE_I128 = exports.RANGE_FELT = exports.ADDR_BOUND = exports.MAX_STORAGE_ITEM_SIZE = exports.PRIME = exports.API_VERSION = exports.MASK_250 = exports.ZERO = exports.TRANSACTION_VERSION = exports.TEXT_TO_FELT_MAX_LEN = exports.IS_BROWSER = void 0;
var api_1 = require("./types/api");
Object.defineProperty(exports, "TRANSACTION_VERSION", { enumerable: true, get: function () { return api_1.ETransactionVersion; } });
var encode_1 = require("./utils/encode");
Object.defineProperty(exports, "IS_BROWSER", { enumerable: true, get: function () { return encode_1.IS_BROWSER; } });
/**
 * Cairo Felt support storing max 31 character
 */
exports.TEXT_TO_FELT_MAX_LEN = 31;
exports.ZERO = 0n;
exports.MASK_250 = 2n ** 250n - 1n; // 2 ** 250 - 1
exports.API_VERSION = exports.ZERO;
exports.PRIME = 2n ** 251n + 17n * 2n ** 192n + 1n;
// based on: https://github.com/starkware-libs/cairo-lang/blob/v0.12.3/src/starkware/starknet/common/storage.cairo#L3
exports.MAX_STORAGE_ITEM_SIZE = 256n;
exports.ADDR_BOUND = 2n ** 251n - exports.MAX_STORAGE_ITEM_SIZE;
var range = function (min, max) { return ({ min: min, max: max }); };
exports.RANGE_FELT = range(exports.ZERO, exports.PRIME - 1n);
exports.RANGE_I128 = range(-(2n ** 127n), 2n ** 127n - 1n);
exports.RANGE_U128 = range(exports.ZERO, 2n ** 128n - 1n);
var BaseUrl;
(function (BaseUrl) {
    BaseUrl["SN_MAIN"] = "https://alpha-mainnet.starknet.io";
    BaseUrl["SN_SEPOLIA"] = "https://alpha-sepolia.starknet.io";
})(BaseUrl || (exports.BaseUrl = BaseUrl = {}));
var NetworkName;
(function (NetworkName) {
    NetworkName["SN_MAIN"] = "SN_MAIN";
    NetworkName["SN_SEPOLIA"] = "SN_SEPOLIA";
})(NetworkName || (exports.NetworkName = NetworkName = {}));
var StarknetChainId;
(function (StarknetChainId) {
    StarknetChainId["SN_MAIN"] = "0x534e5f4d41494e";
    StarknetChainId["SN_SEPOLIA"] = "0x534e5f5345504f4c4941";
})(StarknetChainId || (exports.StarknetChainId = StarknetChainId = {}));
var TransactionHashPrefix;
(function (TransactionHashPrefix) {
    TransactionHashPrefix["DECLARE"] = "0x6465636c617265";
    TransactionHashPrefix["DEPLOY"] = "0x6465706c6f79";
    TransactionHashPrefix["DEPLOY_ACCOUNT"] = "0x6465706c6f795f6163636f756e74";
    TransactionHashPrefix["INVOKE"] = "0x696e766f6b65";
    TransactionHashPrefix["L1_HANDLER"] = "0x6c315f68616e646c6572";
})(TransactionHashPrefix || (exports.TransactionHashPrefix = TransactionHashPrefix = {}));
exports.UDC = {
    ADDRESS: '0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf',
    ENTRYPOINT: 'deployContract',
};
exports.RPC_DEFAULT_VERSION = 'v0_7';
exports.RPC_NODES = {
    SN_MAIN: [
        "https://starknet-mainnet.public.blastapi.io/rpc/".concat(exports.RPC_DEFAULT_VERSION),
        "https://free-rpc.nethermind.io/mainnet-juno/".concat(exports.RPC_DEFAULT_VERSION),
    ],
    SN_SEPOLIA: [
        "https://starknet-sepolia.public.blastapi.io/rpc/".concat(exports.RPC_DEFAULT_VERSION),
        "https://free-rpc.nethermind.io/sepolia-juno/".concat(exports.RPC_DEFAULT_VERSION),
    ],
};

},{"./types/api":119,"./utils/encode":163}],103:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractFactory = void 0;
var types_1 = require("../types");
var assert_1 = require("../utils/assert");
var calldata_1 = require("../utils/calldata");
var default_1 = require("./default");
var ContractFactory = /** @class */ (function () {
    /**
     * @param params CFParams
     *  - compiledContract: CompiledContract;
     *  - account: AccountInterface;
     *  - casm?: CairoAssembly;
     *  - classHash?: string;
     *  - compiledClassHash?: string;
     *  - abi?: Abi;
     */
    function ContractFactory(params) {
        var _a;
        this.compiledContract = params.compiledContract;
        this.account = params.account;
        this.casm = params.casm;
        this.abi = (_a = params.abi) !== null && _a !== void 0 ? _a : params.compiledContract.abi;
        this.classHash = params.classHash;
        this.compiledClassHash = params.compiledClassHash;
        this.CallData = new calldata_1.CallData(this.abi);
    }
    /**
     * Deploys contract and returns new instance of the Contract
     *
     * If contract is not declared it will first declare it, and then deploy
     */
    ContractFactory.prototype.deploy = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var _a, param, _b, options, constructorCalldata, _c, contract_address, transaction_hash, contractInstance;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = (0, default_1.splitArgsAndOptions)(args), param = _a.args, _b = _a.options, options = _b === void 0 ? { parseRequest: true } : _b;
                        constructorCalldata = (0, default_1.getCalldata)(param, function () {
                            if (options.parseRequest) {
                                _this.CallData.validate(types_1.ValidateType.DEPLOY, 'constructor', param);
                                return _this.CallData.compile('constructor', param);
                            }
                            // eslint-disable-next-line no-console
                            console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');
                            return param;
                        });
                        return [4 /*yield*/, this.account.declareAndDeploy({
                                contract: this.compiledContract,
                                casm: this.casm,
                                classHash: this.classHash,
                                compiledClassHash: this.compiledClassHash,
                                constructorCalldata: constructorCalldata,
                                salt: options.addressSalt,
                            })];
                    case 1:
                        _c = (_d.sent()).deploy, contract_address = _c.contract_address, transaction_hash = _c.transaction_hash;
                        (0, assert_1.default)(Boolean(contract_address), 'Deployment of the contract failed');
                        contractInstance = new default_1.Contract(this.compiledContract.abi, contract_address, this.account);
                        contractInstance.deployTransactionHash = transaction_hash;
                        return [2 /*return*/, contractInstance];
                }
            });
        });
    };
    /**
     * Attaches to new Account
     *
     * @param account - new Account to attach to
     */
    ContractFactory.prototype.connect = function (account) {
        this.account = account;
        return this;
    };
    /**
     * Attaches current abi and account to the new address
     */
    ContractFactory.prototype.attach = function (address) {
        return new default_1.Contract(this.abi, address, this.account);
    };
    return ContractFactory;
}());
exports.ContractFactory = ContractFactory;

},{"../types":128,"../utils/assert":141,"../utils/calldata":152,"./default":104}],104:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = exports.splitArgsAndOptions = void 0;
exports.getCalldata = getCalldata;
var provider_1 = require("../provider");
var types_1 = require("../types");
var assert_1 = require("../utils/assert");
var calldata_1 = require("../utils/calldata");
var parser_1 = require("../utils/calldata/parser");
var index_1 = require("../utils/events/index");
var num_1 = require("../utils/num");
var splitArgsAndOptions = function (args) {
    var options = [
        'blockIdentifier',
        'parseRequest',
        'parseResponse',
        'formatResponse',
        'maxFee',
        'nonce',
        'signature',
        'addressSalt',
    ];
    var lastArg = args[args.length - 1];
    if (typeof lastArg === 'object' && options.some(function (x) { return x in lastArg; })) {
        return { args: args, options: args.pop() };
    }
    return { args: args };
};
exports.splitArgsAndOptions = splitArgsAndOptions;
/**
 * Adds call methods to the contract
 */
function buildCall(contract, functionAbi) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var params;
            return __generator(this, function (_a) {
                params = (0, exports.splitArgsAndOptions)(args);
                return [2 /*return*/, contract.call(functionAbi.name, params.args, __assign({ parseRequest: true, parseResponse: true }, params.options))];
            });
        });
    };
}
/**
 * Adds invoke methods to the contract
 */
function buildInvoke(contract, functionAbi) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var params;
            return __generator(this, function (_a) {
                params = (0, exports.splitArgsAndOptions)(args);
                return [2 /*return*/, contract.invoke(functionAbi.name, params.args, __assign({ parseRequest: true }, params.options))];
            });
        });
    };
}
/**
 * Adds call/invoke methods to the contract
 */
function buildDefault(contract, functionAbi) {
    if (functionAbi.stateMutability === 'view' || functionAbi.state_mutability === 'view') {
        return buildCall(contract, functionAbi);
    }
    return buildInvoke(contract, functionAbi);
}
/**
 * Adds populate for methods to the contract
 */
function buildPopulate(contract, functionAbi) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return contract.populate(functionAbi.name, args);
    };
}
/**
 * Adds estimateFee for methods to the contract
 */
function buildEstimate(contract, functionAbi) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return contract.estimate(functionAbi.name, args);
    };
}
function getCalldata(args, callback) {
    // Check if Calldata in args or args[0] else compile
    if (Array.isArray(args) && '__compiled__' in args)
        return args;
    if (Array.isArray(args) && Array.isArray(args[0]) && '__compiled__' in args[0])
        return args[0];
    return callback();
}
var Contract = /** @class */ (function () {
    /**
     * Contract class to handle contract methods
     *
     * @param abi - Abi of the contract object
     * @param address (optional) - address to connect to
     * @param providerOrAccount (optional) - Provider or Account to attach to
     */
    function Contract(abi, address, providerOrAccount) {
        if (providerOrAccount === void 0) { providerOrAccount = provider_1.defaultProvider; }
        var _this = this;
        this.address = address && address.toLowerCase();
        this.providerOrAccount = providerOrAccount;
        this.callData = new calldata_1.CallData(abi);
        this.structs = calldata_1.CallData.getAbiStruct(abi);
        this.events = (0, index_1.getAbiEvents)(abi);
        var parser = (0, parser_1.createAbiParser)(abi);
        this.abi = parser.getLegacyFormat();
        var options = { enumerable: true, value: {}, writable: false };
        Object.defineProperties(this, {
            functions: { enumerable: true, value: {}, writable: false },
            callStatic: { enumerable: true, value: {}, writable: false },
            populateTransaction: { enumerable: true, value: {}, writable: false },
            estimateFee: { enumerable: true, value: {}, writable: false },
        });
        this.abi.forEach(function (abiElement) {
            if (abiElement.type !== 'function')
                return;
            var signature = abiElement.name;
            if (!_this[signature]) {
                Object.defineProperty(_this, signature, __assign(__assign({}, options), { value: buildDefault(_this, abiElement) }));
            }
            if (!_this.functions[signature]) {
                Object.defineProperty(_this.functions, signature, __assign(__assign({}, options), { value: buildDefault(_this, abiElement) }));
            }
            if (!_this.callStatic[signature]) {
                Object.defineProperty(_this.callStatic, signature, __assign(__assign({}, options), { value: buildCall(_this, abiElement) }));
            }
            if (!_this.populateTransaction[signature]) {
                Object.defineProperty(_this.populateTransaction, signature, __assign(__assign({}, options), { value: buildPopulate(_this, abiElement) }));
            }
            if (!_this.estimateFee[signature]) {
                Object.defineProperty(_this.estimateFee, signature, __assign(__assign({}, options), { value: buildEstimate(_this, abiElement) }));
            }
        });
    }
    Contract.prototype.attach = function (address) {
        this.address = address;
    };
    Contract.prototype.connect = function (providerOrAccount) {
        this.providerOrAccount = providerOrAccount;
    };
    Contract.prototype.deployed = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.deployTransactionHash) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.providerOrAccount.waitForTransaction(this.deployTransactionHash)];
                    case 1:
                        _a.sent();
                        this.deployTransactionHash = undefined;
                        _a.label = 2;
                    case 2: return [2 /*return*/, this];
                }
            });
        });
    };
    Contract.prototype.call = function (method_1) {
        return __awaiter(this, arguments, void 0, function (method, args, _a) {
            var calldata;
            var _this = this;
            if (args === void 0) { args = []; }
            var _b = _a === void 0 ? {} : _a, _c = _b.parseRequest, parseRequest = _c === void 0 ? true : _c, _d = _b.parseResponse, parseResponse = _d === void 0 ? true : _d, _e = _b.formatResponse, formatResponse = _e === void 0 ? undefined : _e, _f = _b.blockIdentifier, blockIdentifier = _f === void 0 ? undefined : _f;
            return __generator(this, function (_g) {
                (0, assert_1.default)(this.address !== null, 'contract is not connected to an address');
                calldata = getCalldata(args, function () {
                    if (parseRequest) {
                        _this.callData.validate(types_1.ValidateType.CALL, method, args);
                        return _this.callData.compile(method, args);
                    }
                    // eslint-disable-next-line no-console
                    console.warn('Call skipped parsing but provided rawArgs, possible malfunction request');
                    return args;
                });
                return [2 /*return*/, this.providerOrAccount
                        .callContract({
                        contractAddress: this.address,
                        calldata: calldata,
                        entrypoint: method,
                    }, blockIdentifier)
                        .then(function (it) {
                        if (!parseResponse) {
                            return it;
                        }
                        if (formatResponse) {
                            return _this.callData.format(method, it, formatResponse);
                        }
                        return _this.callData.parse(method, it);
                    })];
            });
        });
    };
    Contract.prototype.invoke = function (method, args, _a) {
        var _this = this;
        if (args === void 0) { args = []; }
        var _b = _a === void 0 ? {} : _a, _c = _b.parseRequest, parseRequest = _c === void 0 ? true : _c, maxFee = _b.maxFee, nonce = _b.nonce, signature = _b.signature;
        (0, assert_1.default)(this.address !== null, 'contract is not connected to an address');
        var calldata = getCalldata(args, function () {
            if (parseRequest) {
                _this.callData.validate(types_1.ValidateType.INVOKE, method, args);
                return _this.callData.compile(method, args);
            }
            // eslint-disable-next-line no-console
            console.warn('Invoke skipped parsing but provided rawArgs, possible malfunction request');
            return args;
        });
        var invocation = {
            contractAddress: this.address,
            calldata: calldata,
            entrypoint: method,
        };
        if ('execute' in this.providerOrAccount) {
            return this.providerOrAccount.execute(invocation, undefined, {
                maxFee: maxFee,
                nonce: nonce,
            });
        }
        if (!nonce)
            throw new Error("Nonce is required when invoking a function without an account");
        // eslint-disable-next-line no-console
        console.warn("Invoking ".concat(method, " without an account. This will not work on a public node."));
        return this.providerOrAccount.invokeFunction(__assign(__assign({}, invocation), { signature: signature }), {
            nonce: nonce,
        });
    };
    Contract.prototype.estimate = function (method_1) {
        return __awaiter(this, arguments, void 0, function (method, args) {
            var invocation;
            if (args === void 0) { args = []; }
            return __generator(this, function (_a) {
                (0, assert_1.default)(this.address !== null, 'contract is not connected to an address');
                if (!getCalldata(args, function () { return false; })) {
                    this.callData.validate(types_1.ValidateType.INVOKE, method, args);
                }
                invocation = this.populate(method, args);
                if ('estimateInvokeFee' in this.providerOrAccount) {
                    return [2 /*return*/, this.providerOrAccount.estimateInvokeFee(invocation)];
                }
                throw Error('Contract must be connected to the account contract to estimate');
            });
        });
    };
    Contract.prototype.populate = function (method, args) {
        var _this = this;
        if (args === void 0) { args = []; }
        var calldata = getCalldata(args, function () { return _this.callData.compile(method, args); });
        return {
            contractAddress: this.address,
            entrypoint: method,
            calldata: calldata,
        };
    };
    Contract.prototype.parseEvents = function (receipt) {
        var _this = this;
        var _a;
        return (0, index_1.parseEvents)(((_a = receipt.events) === null || _a === void 0 ? void 0 : _a.filter(function (event) { return (0, num_1.cleanHex)(event.from_address) === (0, num_1.cleanHex)(_this.address); }, [])) || [], this.events, this.structs, calldata_1.CallData.getAbiEnum(this.abi));
    };
    Contract.prototype.isCairo1 = function () {
        return calldata_1.cairo.isCairo1Abi(this.abi);
    };
    Contract.prototype.getVersion = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.providerOrAccount.getContractVersion(this.address)];
            });
        });
    };
    Contract.prototype.typedv2 = function (tAbi) {
        return this;
    };
    return Contract;
}());
exports.Contract = Contract;

},{"../provider":111,"../types":128,"../utils/assert":141,"../utils/calldata":152,"../utils/calldata/parser":153,"../utils/events/index":165,"../utils/num":175}],105:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./default"), exports);
__exportStar(require("./interface"), exports);
__exportStar(require("./contractFactory"), exports);

},{"./contractFactory":103,"./default":104,"./interface":106}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractInterface = void 0;
var ContractInterface = /** @class */ (function () {
    function ContractInterface() {
    }
    return ContractInterface;
}());
exports.ContractInterface = ContractInterface;

},{}],107:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.number = exports.wallet = exports.events = exports.selector = exports.provider = exports.starknetId = exports.ec = exports.typedData = exports.shortString = exports.uint256 = exports.merkle = exports.eth = exports.stark = exports.transaction = exports.num = exports.json = exports.v2hash = exports.v3hash = exports.hash = exports.encode = exports.constants = exports.types = void 0;
/**
 * Main
 */
__exportStar(require("./wallet"), exports);
__exportStar(require("./account"), exports);
__exportStar(require("./contract"), exports);
__exportStar(require("./provider"), exports);
__exportStar(require("./signer"), exports);
__exportStar(require("./channel"), exports);
// TODO: decide on final export style
__exportStar(require("./types"), exports);
exports.types = require("./types");
/**
 * Utils
 */
exports.constants = require("./constants");
exports.encode = require("./utils/encode");
exports.hash = require("./utils/hash");
exports.v3hash = require("./utils/hash/transactionHash/v3");
exports.v2hash = require("./utils/hash/transactionHash/v2");
exports.json = require("./utils/json");
exports.num = require("./utils/num");
exports.transaction = require("./utils/transaction");
exports.stark = require("./utils/stark");
exports.eth = require("./utils/eth");
exports.merkle = require("./utils/merkle");
exports.uint256 = require("./utils/uint256");
exports.shortString = require("./utils/shortString");
exports.typedData = require("./utils/typedData");
exports.ec = require("./utils/ec");
exports.starknetId = require("./utils/starknetId");
exports.provider = require("./utils/provider");
exports.selector = require("./utils/hash/selector");
exports.events = require("./utils/events");
__exportStar(require("./utils/responseParser"), exports);
__exportStar(require("./utils/cairoDataTypes/uint256"), exports);
__exportStar(require("./utils/cairoDataTypes/uint512"), exports);
__exportStar(require("./utils/address"), exports);
__exportStar(require("./utils/url"), exports);
__exportStar(require("./utils/calldata"), exports);
__exportStar(require("./utils/calldata/enum"), exports);
__exportStar(require("./utils/contract"), exports);
__exportStar(require("./utils/transactionReceipt"), exports);
exports.wallet = require("./wallet/connect");
/**
 * Deprecated
 */
/* eslint-disable import/first */
var num = require("./utils/num");
/** @deprecated prefer the 'num' naming */
exports.number = num;

},{"./account":97,"./channel":99,"./constants":102,"./contract":105,"./provider":111,"./signer":116,"./types":128,"./utils/address":140,"./utils/cairoDataTypes/uint256":143,"./utils/cairoDataTypes/uint512":144,"./utils/calldata":152,"./utils/calldata/enum":150,"./utils/contract":161,"./utils/ec":162,"./utils/encode":163,"./utils/eth":164,"./utils/events":165,"./utils/hash":168,"./utils/hash/selector":169,"./utils/hash/transactionHash/v2":171,"./utils/hash/transactionHash/v3":172,"./utils/json":173,"./utils/merkle":174,"./utils/num":175,"./utils/provider":176,"./utils/responseParser":177,"./utils/shortString":180,"./utils/stark":181,"./utils/starknetId":182,"./utils/transaction":183,"./utils/transactionReceipt":184,"./utils/typedData":185,"./utils/uint256":186,"./utils/url":187,"./wallet":190,"./wallet/connect":189}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpError = exports.GatewayError = exports.LibraryError = exports.CustomError = void 0;
exports.fixStack = fixStack;
exports.fixProto = fixProto;
// eslint-disable-next-line max-classes-per-file
function fixStack(target, fn) {
    if (fn === void 0) { fn = target.constructor; }
    var captureStackTrace = Error.captureStackTrace;
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions
    captureStackTrace && captureStackTrace(target, fn);
}
function fixProto(target, prototype) {
    var setPrototypeOf = Object.setPrototypeOf;
    // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-proto, no-param-reassign
    setPrototypeOf ? setPrototypeOf(target, prototype) : (target.__proto__ = prototype);
}
/* eslint-disable max-classes-per-file */
var CustomError = /** @class */ (function (_super) {
    __extends(CustomError, _super);
    function CustomError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        // see https://github.com/adriengibrat/ts-custom-error/issues/30
        Object.defineProperty(_this, 'name', {
            value: _newTarget.name,
            enumerable: false,
            configurable: true,
        });
        // fix the extended error prototype chain
        // because typescript __extends implementation can't
        // see https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        fixProto(_this, _newTarget.prototype);
        // try to remove constructor from stack trace
        fixStack(_this);
        return _this;
    }
    return CustomError;
}(Error));
exports.CustomError = CustomError;
var LibraryError = /** @class */ (function (_super) {
    __extends(LibraryError, _super);
    function LibraryError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LibraryError;
}(CustomError));
exports.LibraryError = LibraryError;
var GatewayError = /** @class */ (function (_super) {
    __extends(GatewayError, _super);
    function GatewayError(message, errorCode) {
        var _this = _super.call(this, message) || this;
        _this.errorCode = errorCode;
        return _this;
    }
    return GatewayError;
}(LibraryError));
exports.GatewayError = GatewayError;
var HttpError = /** @class */ (function (_super) {
    __extends(HttpError, _super);
    function HttpError(message, errorCode) {
        var _this = _super.call(this, message) || this;
        _this.errorCode = errorCode;
        return _this;
    }
    return HttpError;
}(LibraryError));
exports.HttpError = HttpError;

},{}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcProvider = void 0;
/* eslint-disable max-classes-per-file */
var ts_mixer_1 = require("ts-mixer");
var rpc_1 = require("../rpc");
var starknetId_1 = require("./starknetId");
var RpcProvider = /** @class */ (function (_super) {
    __extends(RpcProvider, _super);
    function RpcProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RpcProvider;
}((0, ts_mixer_1.Mixin)(rpc_1.RpcProvider, starknetId_1.StarknetId)));
exports.RpcProvider = RpcProvider;

},{"../rpc":113,"./starknetId":110,"ts-mixer":92}],110:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetId = void 0;
var calldata_1 = require("../../utils/calldata");
var hash_1 = require("../../utils/hash");
var shortString_1 = require("../../utils/shortString");
var starknetId_1 = require("../../utils/starknetId");
var StarknetId = /** @class */ (function () {
    function StarknetId() {
    }
    StarknetId.prototype.getStarkName = function (address, StarknetIdContract) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, StarknetId.getStarkName(
                    // After Mixin, this is ProviderInterface
                    this, address, StarknetIdContract)];
            });
        });
    };
    StarknetId.prototype.getAddressFromStarkName = function (name, StarknetIdContract) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, StarknetId.getAddressFromStarkName(
                    // After Mixin, this is ProviderInterface
                    this, name, StarknetIdContract)];
            });
        });
    };
    StarknetId.prototype.getStarkProfile = function (address, StarknetIdContract, StarknetIdIdentityContract, StarknetIdVerifierContract, StarknetIdPfpContract, StarknetIdPopContract, StarknetIdMulticallContract) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, StarknetId.getStarkProfile(
                    // After Mixin, this is ProviderInterface
                    this, address, StarknetIdContract, StarknetIdIdentityContract, StarknetIdVerifierContract, StarknetIdPfpContract, StarknetIdPopContract, StarknetIdMulticallContract)];
            });
        });
    };
    StarknetId.getStarkName = function (provider, address, StarknetIdContract) {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, contract, hexDomain, decimalDomain, stringDomain, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, provider.getChainId()];
                    case 1:
                        chainId = _a.sent();
                        contract = StarknetIdContract !== null && StarknetIdContract !== void 0 ? StarknetIdContract : (0, starknetId_1.getStarknetIdContract)(chainId);
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, provider.callContract({
                                contractAddress: contract,
                                entrypoint: 'address_to_domain',
                                calldata: calldata_1.CallData.compile({
                                    address: address,
                                    hint: [],
                                }),
                            })];
                    case 3:
                        hexDomain = _a.sent();
                        decimalDomain = hexDomain.map(function (element) { return BigInt(element); }).slice(1);
                        stringDomain = (0, starknetId_1.useDecoded)(decimalDomain);
                        if (!stringDomain) {
                            throw Error('Starkname not found');
                        }
                        return [2 /*return*/, stringDomain];
                    case 4:
                        e_1 = _a.sent();
                        if (e_1 instanceof Error && e_1.message === 'Starkname not found') {
                            throw e_1;
                        }
                        throw Error('Could not get stark name');
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    StarknetId.getAddressFromStarkName = function (provider, name, StarknetIdContract) {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, contract, encodedDomain, addressData, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, provider.getChainId()];
                    case 1:
                        chainId = _b.sent();
                        contract = StarknetIdContract !== null && StarknetIdContract !== void 0 ? StarknetIdContract : (0, starknetId_1.getStarknetIdContract)(chainId);
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        encodedDomain = name
                            .replace('.stark', '')
                            .split('.')
                            .map(function (part) { return (0, starknetId_1.useEncoded)(part).toString(10); });
                        return [4 /*yield*/, provider.callContract({
                                contractAddress: contract,
                                entrypoint: 'domain_to_address',
                                calldata: calldata_1.CallData.compile({ domain: encodedDomain, hint: [] }),
                            })];
                    case 3:
                        addressData = _b.sent();
                        return [2 /*return*/, addressData[0]];
                    case 4:
                        _a = _b.sent();
                        throw Error('Could not get address from stark name');
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    StarknetId.getStarkProfile = function (provider, address, StarknetIdContract, StarknetIdIdentityContract, StarknetIdVerifierContract, StarknetIdPfpContract, StarknetIdPopContract, StarknetIdMulticallContract) {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, contract, identityContract, verifierContract, pfpContract, popContract, multicallAddress, calls, data, size, finalArray, index, i, subArraySize, subArray, name_1, twitter, github, discord, proofOfPersonhood, profilePictureMetadata, profilePicture, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, provider.getChainId()];
                    case 1:
                        chainId = _a.sent();
                        contract = StarknetIdContract !== null && StarknetIdContract !== void 0 ? StarknetIdContract : (0, starknetId_1.getStarknetIdContract)(chainId);
                        identityContract = StarknetIdIdentityContract !== null && StarknetIdIdentityContract !== void 0 ? StarknetIdIdentityContract : (0, starknetId_1.getStarknetIdIdentityContract)(chainId);
                        verifierContract = StarknetIdVerifierContract !== null && StarknetIdVerifierContract !== void 0 ? StarknetIdVerifierContract : (0, starknetId_1.getStarknetIdVerifierContract)(chainId);
                        pfpContract = StarknetIdPfpContract !== null && StarknetIdPfpContract !== void 0 ? StarknetIdPfpContract : (0, starknetId_1.getStarknetIdPfpContract)(chainId);
                        popContract = StarknetIdPopContract !== null && StarknetIdPopContract !== void 0 ? StarknetIdPopContract : (0, starknetId_1.getStarknetIdPopContract)(chainId);
                        multicallAddress = StarknetIdMulticallContract !== null && StarknetIdMulticallContract !== void 0 ? StarknetIdMulticallContract : (0, starknetId_1.getStarknetIdMulticallContract)(chainId);
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        calls = [
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicCallData)(contract),
                                selector: (0, starknetId_1.dynamicCallData)((0, hash_1.getSelectorFromName)('address_to_domain')),
                                calldata: [(0, starknetId_1.dynamicCallData)(address), (0, starknetId_1.dynamicCallData)('0')],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(contract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('domain_to_id')),
                                calldata: [(0, starknetId_1.dynamicCallData)(undefined, undefined, [0, 0])],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('twitter')),
                                    (0, starknetId_1.dynamicCallData)(verifierContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('github')),
                                    (0, starknetId_1.dynamicCallData)(verifierContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('discord')),
                                    (0, starknetId_1.dynamicCallData)(verifierContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('proof_of_personhood')),
                                    (0, starknetId_1.dynamicCallData)(popContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            // PFP
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('nft_pp_contract')),
                                    (0, starknetId_1.dynamicCallData)(pfpContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            {
                                execution: (0, starknetId_1.execution)({}),
                                to: (0, starknetId_1.dynamicFelt)(identityContract),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('get_extended_verifier_data')),
                                calldata: [
                                    (0, starknetId_1.dynamicCallData)(undefined, [1, 0]),
                                    (0, starknetId_1.dynamicCallData)((0, shortString_1.encodeShortString)('nft_pp_id')),
                                    (0, starknetId_1.dynamicCallData)('2'),
                                    (0, starknetId_1.dynamicCallData)(pfpContract),
                                    (0, starknetId_1.dynamicCallData)('0'),
                                ],
                            },
                            {
                                execution: (0, starknetId_1.execution)(undefined, undefined, [6, 0, 0]),
                                to: (0, starknetId_1.dynamicFelt)(undefined, [6, 0]),
                                selector: (0, starknetId_1.dynamicFelt)((0, hash_1.getSelectorFromName)('tokenURI')),
                                calldata: [(0, starknetId_1.dynamicCallData)(undefined, [7, 1]), (0, starknetId_1.dynamicCallData)(undefined, [7, 2])],
                            },
                        ];
                        return [4 /*yield*/, provider.callContract({
                                contractAddress: multicallAddress,
                                entrypoint: 'aggregate',
                                calldata: calldata_1.CallData.compile({
                                    calls: calls,
                                }),
                            })];
                    case 3:
                        data = _a.sent();
                        if (Array.isArray(data)) {
                            size = parseInt(data[0], 16);
                            finalArray = [];
                            index = 1;
                            for (i = 0; i < size; i += 1) {
                                if (index < data.length) {
                                    subArraySize = parseInt(data[index], 16);
                                    index += 1;
                                    subArray = data.slice(index, index + subArraySize);
                                    finalArray.push(subArray);
                                    index += subArraySize;
                                }
                                else {
                                    break;
                                }
                            }
                            name_1 = (0, starknetId_1.useDecoded)(finalArray[0].slice(1).map(function (hexString) { return BigInt(hexString); }));
                            twitter = finalArray[2][0] !== '0x0' ? BigInt(finalArray[2][0]).toString() : undefined;
                            github = finalArray[3][0] !== '0x0' ? BigInt(finalArray[3][0]).toString() : undefined;
                            discord = finalArray[4][0] !== '0x0' ? BigInt(finalArray[4][0]).toString() : undefined;
                            proofOfPersonhood = finalArray[5][0] === '0x1';
                            profilePictureMetadata = data[0] === '0x9'
                                ? finalArray[8]
                                    .slice(1)
                                    .map(function (val) { return (0, shortString_1.decodeShortString)(val); })
                                    .join('')
                                : undefined;
                            profilePicture = profilePictureMetadata ||
                                "https://starknet.id/api/identicons/".concat(BigInt(finalArray[1][0]).toString());
                            return [2 /*return*/, {
                                    name: name_1,
                                    twitter: twitter,
                                    github: github,
                                    discord: discord,
                                    proofOfPersonhood: proofOfPersonhood,
                                    profilePicture: profilePicture,
                                }];
                        }
                        throw Error('Error while calling aggregate function');
                    case 4:
                        e_2 = _a.sent();
                        if (e_2 instanceof Error) {
                            throw e_2;
                        }
                        throw Error('Could not get user stark profile data from address');
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return StarknetId;
}());
exports.StarknetId = StarknetId;

},{"../../utils/calldata":152,"../../utils/hash":168,"../../utils/shortString":180,"../../utils/starknetId":182}],111:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultProvider = exports.Provider = void 0;
var rpc_1 = require("./rpc");
var default_1 = require("./extensions/default"); // backward-compatibility
Object.defineProperty(exports, "Provider", { enumerable: true, get: function () { return default_1.RpcProvider; } });
__exportStar(require("./errors"), exports);
__exportStar(require("./interface"), exports);
__exportStar(require("./extensions/default"), exports);
exports.defaultProvider = new rpc_1.RpcProvider({ default: true });

},{"./errors":108,"./extensions/default":109,"./interface":112,"./rpc":113}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderInterface = void 0;
var ProviderInterface = /** @class */ (function () {
    function ProviderInterface() {
    }
    return ProviderInterface;
}());
exports.ProviderInterface = ProviderInterface;

},{}],113:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcProvider = void 0;
var utils_1 = require("@noble/curves/abstract/utils");
var sha3_1 = require("@noble/hashes/sha3");
var channel_1 = require("../channel");
var types_1 = require("../types");
var assert_1 = require("../utils/assert");
var cairo_1 = require("../utils/calldata/cairo");
var contract_1 = require("../utils/contract");
var encode_1 = require("../utils/encode");
var num_1 = require("../utils/num");
var provider_1 = require("../utils/provider");
var rpc_1 = require("../utils/responseParser/rpc");
var transactionReceipt_1 = require("../utils/transactionReceipt");
var errors_1 = require("./errors");
var RpcProvider = /** @class */ (function () {
    function RpcProvider(optionsOrProvider) {
        this.getStateUpdate = this.getBlockStateUpdate;
        if (optionsOrProvider && 'channel' in optionsOrProvider) {
            this.channel = optionsOrProvider.channel;
            this.responseParser =
                'responseParser' in optionsOrProvider
                    ? optionsOrProvider.responseParser
                    : new rpc_1.RPCResponseParser();
        }
        else {
            this.channel = new channel_1.RpcChannel(__assign(__assign({}, optionsOrProvider), { waitMode: false }));
            this.responseParser = new rpc_1.RPCResponseParser(optionsOrProvider === null || optionsOrProvider === void 0 ? void 0 : optionsOrProvider.feeMarginPercentage);
        }
    }
    RpcProvider.prototype.fetch = function (method, params, id) {
        if (id === void 0) { id = 0; }
        return this.channel.fetch(method, params, id);
    };
    RpcProvider.prototype.getChainId = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getChainId()];
            });
        });
    };
    RpcProvider.prototype.getSpecVersion = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getSpecVersion()];
            });
        });
    };
    RpcProvider.prototype.getNonceForAddress = function (contractAddress, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getNonceForAddress(contractAddress, blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getBlock = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getBlockWithTxHashes(blockIdentifier)
                        .then(this.responseParser.parseGetBlockResponse)];
            });
        });
    };
    /**
     * Get the most recent accepted block hash and number
     */
    RpcProvider.prototype.getBlockLatestAccepted = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockLatestAccepted()];
            });
        });
    };
    /**
     * Get the most recent accepted block number
     * redundant use getBlockLatestAccepted();
     * @returns Number of the latest block
     */
    RpcProvider.prototype.getBlockNumber = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockNumber()];
            });
        });
    };
    RpcProvider.prototype.getBlockWithTxHashes = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockWithTxHashes(blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getBlockWithTxs = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockWithTxs(blockIdentifier)];
            });
        });
    };
    /**
     * Pause the execution of the script until a specified block is created.
     * @param {BlockIdentifier} blockIdentifier bloc number (BigNumberisk) or 'pending' or 'latest'.
     * Use of 'latest" or of a block already created will generate no pause.
     * @param {number} [retryInterval] number of milliseconds between 2 requests to the node
     * @example
     * ```typescript
     * await myProvider.waitForBlock();
     * // wait the creation of the pending block
     * ```
     */
    RpcProvider.prototype.waitForBlock = function () {
        return __awaiter(this, arguments, void 0, function (blockIdentifier, retryInterval) {
            var currentBlock, targetBlock, retries, retriesCount, isTargetBlock, currBlock;
            if (blockIdentifier === void 0) { blockIdentifier = 'pending'; }
            if (retryInterval === void 0) { retryInterval = 5000; }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (blockIdentifier === types_1.BlockTag.LATEST)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.getBlockNumber()];
                    case 1:
                        currentBlock = _a.sent();
                        targetBlock = blockIdentifier === types_1.BlockTag.PENDING
                            ? currentBlock + 1
                            : Number((0, num_1.toHex)(blockIdentifier));
                        if (targetBlock <= currentBlock)
                            return [2 /*return*/];
                        retries = this.channel.retries;
                        retriesCount = retries;
                        isTargetBlock = false;
                        _a.label = 2;
                    case 2:
                        if (!!isTargetBlock) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.getBlockNumber()];
                    case 3:
                        currBlock = _a.sent();
                        if (!(currBlock === targetBlock)) return [3 /*break*/, 4];
                        isTargetBlock = true;
                        return [3 /*break*/, 6];
                    case 4: 
                    // eslint-disable-next-line no-await-in-loop
                    return [4 /*yield*/, (0, provider_1.wait)(retryInterval)];
                    case 5:
                        // eslint-disable-next-line no-await-in-loop
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        retriesCount -= 1;
                        if (retriesCount <= 0) {
                            throw new Error("waitForBlock() timed-out after ".concat(retries, " tries."));
                        }
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    RpcProvider.prototype.getL1GasPrice = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getBlockWithTxHashes(blockIdentifier)
                        .then(this.responseParser.parseL1GasPriceResponse)];
            });
        });
    };
    RpcProvider.prototype.getL1MessageHash = function (l2TxHash) {
        return __awaiter(this, void 0, void 0, function () {
            var transaction, _a, calldata, contract_address, entry_point_selector, nonce, params, myEncode;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.channel.getTransactionByHash(l2TxHash)];
                    case 1:
                        transaction = (_b.sent());
                        (0, assert_1.default)(transaction.type === 'L1_HANDLER', 'This L2 transaction is not a L1 message.');
                        _a = transaction, calldata = _a.calldata, contract_address = _a.contract_address, entry_point_selector = _a.entry_point_selector, nonce = _a.nonce;
                        params = __spreadArray([
                            calldata[0],
                            contract_address,
                            nonce,
                            entry_point_selector,
                            calldata.length - 1
                        ], calldata.slice(1), true);
                        myEncode = (0, encode_1.addHexPrefix)(params.reduce(function (res, par) { return res + (0, encode_1.removeHexPrefix)((0, num_1.toHex)(par)).padStart(64, '0'); }, ''));
                        return [2 /*return*/, (0, encode_1.addHexPrefix)((0, utils_1.bytesToHex)((0, sha3_1.keccak_256)((0, num_1.hexToBytes)(myEncode))))];
                }
            });
        });
    };
    RpcProvider.prototype.getBlockWithReceipts = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.channel instanceof channel_1.RPC06.RpcChannel)
                    throw new errors_1.LibraryError('Unsupported method for RPC version');
                return [2 /*return*/, this.channel.getBlockWithReceipts(blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getBlockStateUpdate = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockStateUpdate(blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getBlockTransactionsTraces = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockTransactionsTraces(blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getBlockTransactionCount = function (blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getBlockTransactionCount(blockIdentifier)];
            });
        });
    };
    /**
     * Return transactions from pending block
     * @deprecated Instead use getBlock(BlockTag.PENDING); (will be removed in next minor version)
     * Utility method, same result can be achieved using getBlockWithTxHashes(BlockTag.pending);
     */
    RpcProvider.prototype.getPendingTransactions = function () {
        return __awaiter(this, void 0, void 0, function () {
            var transactions;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getBlockWithTxHashes(types_1.BlockTag.PENDING).then(this.responseParser.parseGetBlockResponse)];
                    case 1:
                        transactions = (_a.sent()).transactions;
                        return [2 /*return*/, Promise.all(transactions.map(function (it) { return _this.getTransactionByHash(it); }))];
                }
            });
        });
    };
    RpcProvider.prototype.getTransaction = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getTransactionByHash(txHash)];
            });
        });
    };
    RpcProvider.prototype.getTransactionByHash = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getTransactionByHash(txHash)];
            });
        });
    };
    RpcProvider.prototype.getTransactionByBlockIdAndIndex = function (blockIdentifier, index) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getTransactionByBlockIdAndIndex(blockIdentifier, index)];
            });
        });
    };
    RpcProvider.prototype.getTransactionReceipt = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            var txReceiptWoHelper, txReceiptWoHelperModified;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.channel.getTransactionReceipt(txHash)];
                    case 1:
                        txReceiptWoHelper = _a.sent();
                        txReceiptWoHelperModified = this.responseParser.parseTransactionReceipt(txReceiptWoHelper);
                        return [2 /*return*/, new transactionReceipt_1.ReceiptTx(txReceiptWoHelperModified)];
                }
            });
        });
    };
    RpcProvider.prototype.getTransactionTrace = function (txHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getTransactionTrace(txHash)];
            });
        });
    };
    /**
     * Get the status of a transaction
     */
    RpcProvider.prototype.getTransactionStatus = function (transactionHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getTransactionStatus(transactionHash)];
            });
        });
    };
    /**
     * @param invocations AccountInvocations
     * @param options blockIdentifier and flags to skip validation and fee charge<br/>
     * - blockIdentifier<br/>
     * - skipValidate (default false)<br/>
     * - skipFeeCharge (default true)<br/>
     */
    RpcProvider.prototype.getSimulateTransaction = function (invocations, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // can't be named simulateTransaction because of argument conflict with account
                return [2 /*return*/, this.channel
                        .simulateTransaction(invocations, options)
                        .then(function (r) { return _this.responseParser.parseSimulateTransactionResponse(r); })];
            });
        });
    };
    RpcProvider.prototype.waitForTransaction = function (txHash, options) {
        return __awaiter(this, void 0, void 0, function () {
            var receiptWoHelper;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.channel.waitForTransaction(txHash, options)];
                    case 1:
                        receiptWoHelper = (_a.sent());
                        return [2 /*return*/, new transactionReceipt_1.ReceiptTx(receiptWoHelper)];
                }
            });
        });
    };
    RpcProvider.prototype.getStorageAt = function (contractAddress, key, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getStorageAt(contractAddress, key, blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getClassHashAt = function (contractAddress, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getClassHashAt(contractAddress, blockIdentifier)];
            });
        });
    };
    RpcProvider.prototype.getClassByHash = function (classHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getClass(classHash)];
            });
        });
    };
    RpcProvider.prototype.getClass = function (classHash, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getClass(classHash, blockIdentifier)
                        .then(this.responseParser.parseContractClassResponse)];
            });
        });
    };
    RpcProvider.prototype.getClassAt = function (contractAddress, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getClassAt(contractAddress, blockIdentifier)
                        .then(this.responseParser.parseContractClassResponse)];
            });
        });
    };
    RpcProvider.prototype.getContractVersion = function (contractAddress_1, classHash_1) {
        return __awaiter(this, arguments, void 0, function (contractAddress, classHash, _a) {
            var contractClass, abiTest;
            var _b = _a === void 0 ? {} : _a, _c = _b.blockIdentifier, blockIdentifier = _c === void 0 ? this.channel.blockIdentifier : _c, _d = _b.compiler, compiler = _d === void 0 ? true : _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!contractAddress) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getClassAt(contractAddress, blockIdentifier)];
                    case 1:
                        contractClass = _e.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        if (!classHash) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getClass(classHash, blockIdentifier)];
                    case 3:
                        contractClass = _e.sent();
                        return [3 /*break*/, 5];
                    case 4: throw Error('getContractVersion require contractAddress or classHash');
                    case 5:
                        if ((0, contract_1.isSierra)(contractClass)) {
                            if (compiler) {
                                abiTest = (0, cairo_1.getAbiContractVersion)(contractClass.abi);
                                return [2 /*return*/, { cairo: '1', compiler: abiTest.compiler }];
                            }
                            return [2 /*return*/, { cairo: '1', compiler: undefined }];
                        }
                        return [2 /*return*/, { cairo: '0', compiler: '0' }];
                }
            });
        });
    };
    /**
     * @deprecated use get*type*EstimateFee (will be refactored based on type after sequencer deprecation)
     */
    RpcProvider.prototype.getEstimateFee = function (invocation, invocationDetails, blockIdentifier, skipValidate) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getInvokeEstimateFee(invocation, invocationDetails, blockIdentifier, skipValidate)];
            });
        });
    };
    RpcProvider.prototype.getInvokeEstimateFee = function (invocation, invocationDetails, blockIdentifier, skipValidate) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getEstimateFee([
                        __assign(__assign({ type: types_1.TransactionType.INVOKE }, invocation), invocationDetails),
                    ], { blockIdentifier: blockIdentifier, skipValidate: skipValidate })
                        .then(function (r) { return _this.responseParser.parseFeeEstimateResponse(r); })];
            });
        });
    };
    RpcProvider.prototype.getDeclareEstimateFee = function (invocation, details, blockIdentifier, skipValidate) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getEstimateFee([
                        __assign(__assign({ type: types_1.TransactionType.DECLARE }, invocation), details),
                    ], { blockIdentifier: blockIdentifier, skipValidate: skipValidate })
                        .then(function (r) { return _this.responseParser.parseFeeEstimateResponse(r); })];
            });
        });
    };
    RpcProvider.prototype.getDeployAccountEstimateFee = function (invocation, details, blockIdentifier, skipValidate) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getEstimateFee([
                        __assign(__assign({ type: types_1.TransactionType.DEPLOY_ACCOUNT }, invocation), details),
                    ], { blockIdentifier: blockIdentifier, skipValidate: skipValidate })
                        .then(function (r) { return _this.responseParser.parseFeeEstimateResponse(r); })];
            });
        });
    };
    RpcProvider.prototype.getEstimateFeeBulk = function (invocations, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel
                        .getEstimateFee(invocations, options)
                        .then(function (r) { return _this.responseParser.parseFeeEstimateBulkResponse(r); })];
            });
        });
    };
    RpcProvider.prototype.invokeFunction = function (functionInvocation, details) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.invoke(functionInvocation, details)];
            });
        });
    };
    RpcProvider.prototype.declareContract = function (transaction, details) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.declare(transaction, details)];
            });
        });
    };
    RpcProvider.prototype.deployAccountContract = function (transaction, details) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.deployAccount(transaction, details)];
            });
        });
    };
    RpcProvider.prototype.callContract = function (call, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.callContract(call, blockIdentifier)];
            });
        });
    };
    /**
     * NEW: Estimate the fee for a message from L1
     * @param message Message From L1
     */
    RpcProvider.prototype.estimateMessageFee = function (message, blockIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.estimateMessageFee(message, blockIdentifier)];
            });
        });
    };
    /**
     * Returns an object about the sync status, or false if the node is not synching
     * @returns Object with the stats data
     */
    RpcProvider.prototype.getSyncingStats = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getSyncingStats()];
            });
        });
    };
    /**
     * Returns all events matching the given filter
     * @returns events and the pagination of the events
     */
    RpcProvider.prototype.getEvents = function (eventFilter) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.channel.getEvents(eventFilter)];
            });
        });
    };
    return RpcProvider;
}());
exports.RpcProvider = RpcProvider;

},{"../channel":99,"../types":128,"../utils/assert":141,"../utils/calldata/cairo":146,"../utils/contract":161,"../utils/encode":163,"../utils/num":175,"../utils/provider":176,"../utils/responseParser/rpc":179,"../utils/transactionReceipt":184,"./errors":108,"@noble/curves/abstract/utils":31,"@noble/hashes/sha3":40}],114:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = void 0;
var api_1 = require("../types/api");
var calldata_1 = require("../utils/calldata");
var ec_1 = require("../utils/ec");
var encode_1 = require("../utils/encode");
var hash_1 = require("../utils/hash");
var num_1 = require("../utils/num");
var stark_1 = require("../utils/stark");
var transaction_1 = require("../utils/transaction");
var typedData_1 = require("../utils/typedData");
var Signer = /** @class */ (function () {
    function Signer(pk) {
        if (pk === void 0) { pk = ec_1.starkCurve.utils.randomPrivateKey(); }
        this.pk = pk instanceof Uint8Array ? (0, encode_1.buf2hex)(pk) : (0, num_1.toHex)(pk);
    }
    Signer.prototype.getPubKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, ec_1.starkCurve.getStarkKey(this.pk)];
            });
        });
    };
    Signer.prototype.signMessage = function (typedData, accountAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var msgHash;
            return __generator(this, function (_a) {
                msgHash = (0, typedData_1.getMessageHash)(typedData, accountAddress);
                return [2 /*return*/, this.signRaw(msgHash)];
            });
        });
    };
    Signer.prototype.signTransaction = function (transactions, details) {
        return __awaiter(this, void 0, void 0, function () {
            var compiledCalldata, msgHash, det, det;
            return __generator(this, function (_a) {
                compiledCalldata = (0, transaction_1.getExecuteCalldata)(transactions, details.cairoVersion);
                // TODO: How to do generic union discriminator for all like this
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateInvokeTransactionHash)(__assign(__assign({}, det), { senderAddress: det.walletAddress, compiledCalldata: compiledCalldata, version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateInvokeTransactionHash)(__assign(__assign({}, det), { senderAddress: det.walletAddress, compiledCalldata: compiledCalldata, version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signTransaction version');
                }
                return [2 /*return*/, this.signRaw(msgHash)];
            });
        });
    };
    Signer.prototype.signDeployAccountTransaction = function (details) {
        return __awaiter(this, void 0, void 0, function () {
            var compiledConstructorCalldata, msgHash, det, det;
            return __generator(this, function (_a) {
                compiledConstructorCalldata = calldata_1.CallData.compile(details.constructorCalldata);
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeployAccountTransactionHash)(__assign(__assign({}, det), { salt: det.addressSalt, constructorCalldata: compiledConstructorCalldata, version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeployAccountTransactionHash)(__assign(__assign({}, det), { salt: det.addressSalt, compiledConstructorCalldata: compiledConstructorCalldata, version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signDeployAccountTransaction version');
                }
                return [2 /*return*/, this.signRaw(msgHash)];
            });
        });
    };
    Signer.prototype.signDeclareTransaction = function (
    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass
    details) {
        return __awaiter(this, void 0, void 0, function () {
            var msgHash, det, det;
            return __generator(this, function (_a) {
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeclareTransactionHash)(__assign(__assign({}, det), { version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeclareTransactionHash)(__assign(__assign({}, det), { version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signDeclareTransaction version');
                }
                return [2 /*return*/, this.signRaw(msgHash)];
            });
        });
    };
    Signer.prototype.signRaw = function (msgHash) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, ec_1.starkCurve.sign(msgHash, this.pk)];
            });
        });
    };
    return Signer;
}());
exports.Signer = Signer;

},{"../types/api":119,"../utils/calldata":152,"../utils/ec":162,"../utils/encode":163,"../utils/hash":168,"../utils/num":175,"../utils/stark":181,"../utils/transaction":183,"../utils/typedData":185}],115:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthSigner = void 0;
var secp256k1_1 = require("@noble/curves/secp256k1");
var api_1 = require("../types/api");
var calldata_1 = require("../utils/calldata");
var encode_1 = require("../utils/encode");
var eth_1 = require("../utils/eth");
var hash_1 = require("../utils/hash");
var num_1 = require("../utils/num");
var stark_1 = require("../utils/stark");
var transaction_1 = require("../utils/transaction");
var typedData_1 = require("../utils/typedData");
var uint256_1 = require("../utils/uint256");
/**
 * Signer for accounts using Ethereum signature
 */
var EthSigner = /** @class */ (function () {
    function EthSigner(pk) {
        if (pk === void 0) { pk = (0, eth_1.ethRandomPrivateKey)(); }
        this.pk =
            pk instanceof Uint8Array
                ? (0, encode_1.buf2hex)(pk).padStart(64, '0')
                : (0, encode_1.removeHexPrefix)((0, num_1.toHex)(pk)).padStart(64, '0');
    }
    /**
     * provides the Ethereum full public key (without parity prefix)
     * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.
     */
    EthSigner.prototype.getPubKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, (0, encode_1.addHexPrefix)((0, encode_1.buf2hex)(secp256k1_1.secp256k1.getPublicKey(this.pk, false)).padStart(130, '0').slice(2))];
            });
        });
    };
    EthSigner.prototype.signMessage = function (typedData, accountAddress) {
        return __awaiter(this, void 0, void 0, function () {
            var msgHash, signature;
            return __generator(this, function (_a) {
                msgHash = (0, typedData_1.getMessageHash)(typedData, accountAddress);
                signature = secp256k1_1.secp256k1.sign((0, encode_1.removeHexPrefix)((0, encode_1.sanitizeHex)(msgHash)), this.pk);
                return [2 /*return*/, this.formatEthSignature(signature)];
            });
        });
    };
    EthSigner.prototype.signTransaction = function (transactions, details) {
        return __awaiter(this, void 0, void 0, function () {
            var compiledCalldata, msgHash, det, det, signature;
            return __generator(this, function (_a) {
                compiledCalldata = (0, transaction_1.getExecuteCalldata)(transactions, details.cairoVersion);
                // TODO: How to do generic union discriminator for all like this
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateInvokeTransactionHash)(__assign(__assign({}, det), { senderAddress: det.walletAddress, compiledCalldata: compiledCalldata, version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateInvokeTransactionHash)(__assign(__assign({}, det), { senderAddress: det.walletAddress, compiledCalldata: compiledCalldata, version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signTransaction version');
                }
                signature = secp256k1_1.secp256k1.sign((0, encode_1.removeHexPrefix)((0, encode_1.sanitizeHex)(msgHash)), this.pk);
                return [2 /*return*/, this.formatEthSignature(signature)];
            });
        });
    };
    EthSigner.prototype.signDeployAccountTransaction = function (details) {
        return __awaiter(this, void 0, void 0, function () {
            var compiledConstructorCalldata, msgHash, det, det, signature;
            return __generator(this, function (_a) {
                compiledConstructorCalldata = calldata_1.CallData.compile(details.constructorCalldata);
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeployAccountTransactionHash)(__assign(__assign({}, det), { salt: det.addressSalt, constructorCalldata: compiledConstructorCalldata, version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeployAccountTransactionHash)(__assign(__assign({}, det), { salt: det.addressSalt, compiledConstructorCalldata: compiledConstructorCalldata, version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signDeployAccountTransaction version');
                }
                signature = secp256k1_1.secp256k1.sign((0, encode_1.removeHexPrefix)((0, encode_1.sanitizeHex)(msgHash)), this.pk);
                return [2 /*return*/, this.formatEthSignature(signature)];
            });
        });
    };
    EthSigner.prototype.signDeclareTransaction = function (
    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass
    details) {
        return __awaiter(this, void 0, void 0, function () {
            var msgHash, det, det, signature;
            return __generator(this, function (_a) {
                if (Object.values(api_1.ETransactionVersion2).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeclareTransactionHash)(__assign(__assign({}, det), { version: det.version }));
                }
                else if (Object.values(api_1.ETransactionVersion3).includes(details.version)) {
                    det = details;
                    msgHash = (0, hash_1.calculateDeclareTransactionHash)(__assign(__assign({}, det), { version: det.version, nonceDataAvailabilityMode: (0, stark_1.intDAM)(det.nonceDataAvailabilityMode), feeDataAvailabilityMode: (0, stark_1.intDAM)(det.feeDataAvailabilityMode) }));
                }
                else {
                    throw Error('unsupported signDeclareTransaction version');
                }
                signature = secp256k1_1.secp256k1.sign((0, encode_1.removeHexPrefix)((0, encode_1.sanitizeHex)(msgHash)), this.pk);
                return [2 /*return*/, this.formatEthSignature(signature)];
            });
        });
    };
    /**
     * Serialize the signature in conformity with starknet::eth_signature::Signature
     * @param ethSignature secp256k1 signature from Noble curves library
     * @return an array of felts, representing a Cairo Eth Signature.
     */
    EthSigner.prototype.formatEthSignature = function (ethSignature) {
        var r = (0, uint256_1.bnToUint256)(ethSignature.r);
        var s = (0, uint256_1.bnToUint256)(ethSignature.s);
        return [
            (0, num_1.toHex)(r.low),
            (0, num_1.toHex)(r.high),
            (0, num_1.toHex)(s.low),
            (0, num_1.toHex)(s.high),
            (0, num_1.toHex)(ethSignature.recovery),
        ];
    };
    return EthSigner;
}());
exports.EthSigner = EthSigner;

},{"../types/api":119,"../utils/calldata":152,"../utils/encode":163,"../utils/eth":164,"../utils/hash":168,"../utils/num":175,"../utils/stark":181,"../utils/transaction":183,"../utils/typedData":185,"../utils/uint256":186,"@noble/curves/secp256k1":33}],116:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./interface"), exports);
__exportStar(require("./default"), exports);
__exportStar(require("./ethSigner"), exports);

},{"./default":114,"./ethSigner":115,"./interface":117}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignerInterface = void 0;
var SignerInterface = /** @class */ (function () {
    function SignerInterface() {
    }
    return SignerInterface;
}());
exports.SignerInterface = SignerInterface;

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],119:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCSPEC07 = exports.RPCSPEC06 = exports.JRPC = void 0;
exports.JRPC = require("./jsonrpc");
exports.RPCSPEC06 = require("./rpcspec_0_6");
exports.RPCSPEC07 = require("starknet-types-07");
__exportStar(require("starknet-types-07"), exports);

},{"./jsonrpc":120,"./rpcspec_0_6":123,"starknet-types-07":73}],120:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],121:[function(require,module,exports){
"use strict";
/**
 * PRIMITIVES
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],122:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],123:[function(require,module,exports){
"use strict";
/**
 * version 0.6.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPEC = exports.Errors = void 0;
exports.Errors = require("./errors");
exports.SPEC = require("./components");
__exportStar(require("./nonspec"), exports);

},{"./components":121,"./errors":122,"./nonspec":124}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ETransactionVersion3 = exports.ETransactionVersion2 = exports.ETransactionVersion = exports.EDAMode = exports.EDataAvailabilityMode = exports.EBlockTag = exports.ETransactionExecutionStatus = exports.ETransactionFinalityStatus = exports.ETransactionStatus = exports.ESimulationFlag = exports.ETransactionType = void 0;
// Enums Derived From Spec Types (require manual check for changes)
var ETransactionType;
(function (ETransactionType) {
    ETransactionType["DECLARE"] = "DECLARE";
    ETransactionType["DEPLOY"] = "DEPLOY";
    ETransactionType["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
    ETransactionType["INVOKE"] = "INVOKE";
    ETransactionType["L1_HANDLER"] = "L1_HANDLER";
})(ETransactionType || (exports.ETransactionType = ETransactionType = {}));
var ESimulationFlag;
(function (ESimulationFlag) {
    ESimulationFlag["SKIP_VALIDATE"] = "SKIP_VALIDATE";
    ESimulationFlag["SKIP_FEE_CHARGE"] = "SKIP_FEE_CHARGE";
})(ESimulationFlag || (exports.ESimulationFlag = ESimulationFlag = {}));
var ETransactionStatus;
(function (ETransactionStatus) {
    ETransactionStatus["RECEIVED"] = "RECEIVED";
    ETransactionStatus["REJECTED"] = "REJECTED";
    ETransactionStatus["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
    ETransactionStatus["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
})(ETransactionStatus || (exports.ETransactionStatus = ETransactionStatus = {}));
var ETransactionFinalityStatus;
(function (ETransactionFinalityStatus) {
    ETransactionFinalityStatus["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
    ETransactionFinalityStatus["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
})(ETransactionFinalityStatus || (exports.ETransactionFinalityStatus = ETransactionFinalityStatus = {}));
var ETransactionExecutionStatus;
(function (ETransactionExecutionStatus) {
    ETransactionExecutionStatus["SUCCEEDED"] = "SUCCEEDED";
    ETransactionExecutionStatus["REVERTED"] = "REVERTED";
})(ETransactionExecutionStatus || (exports.ETransactionExecutionStatus = ETransactionExecutionStatus = {}));
var EBlockTag;
(function (EBlockTag) {
    EBlockTag["PENDING"] = "pending";
    EBlockTag["LATEST"] = "latest";
})(EBlockTag || (exports.EBlockTag = EBlockTag = {}));
// 'L1' | 'L2'
var EDataAvailabilityMode;
(function (EDataAvailabilityMode) {
    EDataAvailabilityMode["L1"] = "L1";
    EDataAvailabilityMode["L2"] = "L2";
})(EDataAvailabilityMode || (exports.EDataAvailabilityMode = EDataAvailabilityMode = {}));
// 0 | 1
var EDAMode;
(function (EDAMode) {
    EDAMode[EDAMode["L1"] = 0] = "L1";
    EDAMode[EDAMode["L2"] = 1] = "L2";
})(EDAMode || (exports.EDAMode = EDAMode = {}));
/**
 * V_ Transaction versions HexString
 * F_ Fee Transaction Versions HexString (2 ** 128 + TRANSACTION_VERSION)
 */
var ETransactionVersion;
(function (ETransactionVersion) {
    ETransactionVersion["V0"] = "0x0";
    ETransactionVersion["V1"] = "0x1";
    ETransactionVersion["V2"] = "0x2";
    ETransactionVersion["V3"] = "0x3";
    ETransactionVersion["F0"] = "0x100000000000000000000000000000000";
    ETransactionVersion["F1"] = "0x100000000000000000000000000000001";
    ETransactionVersion["F2"] = "0x100000000000000000000000000000002";
    ETransactionVersion["F3"] = "0x100000000000000000000000000000003";
})(ETransactionVersion || (exports.ETransactionVersion = ETransactionVersion = {}));
/**
 * Old Transaction Versions
 */
var ETransactionVersion2;
(function (ETransactionVersion2) {
    ETransactionVersion2["V0"] = "0x0";
    ETransactionVersion2["V1"] = "0x1";
    ETransactionVersion2["V2"] = "0x2";
    ETransactionVersion2["F0"] = "0x100000000000000000000000000000000";
    ETransactionVersion2["F1"] = "0x100000000000000000000000000000001";
    ETransactionVersion2["F2"] = "0x100000000000000000000000000000002";
})(ETransactionVersion2 || (exports.ETransactionVersion2 = ETransactionVersion2 = {}));
/**
 * V3 Transaction Versions
 */
var ETransactionVersion3;
(function (ETransactionVersion3) {
    ETransactionVersion3["V3"] = "0x3";
    ETransactionVersion3["F3"] = "0x100000000000000000000000000000003";
})(ETransactionVersion3 || (exports.ETransactionVersion3 = ETransactionVersion3 = {}));

},{}],125:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Literal = exports.Uint = exports.ValidateType = void 0;
var ValidateType;
(function (ValidateType) {
    ValidateType["DEPLOY"] = "DEPLOY";
    ValidateType["CALL"] = "CALL";
    ValidateType["INVOKE"] = "INVOKE";
})(ValidateType || (exports.ValidateType = ValidateType = {}));
var Uint;
(function (Uint) {
    Uint["u8"] = "core::integer::u8";
    Uint["u16"] = "core::integer::u16";
    Uint["u32"] = "core::integer::u32";
    Uint["u64"] = "core::integer::u64";
    Uint["u128"] = "core::integer::u128";
    Uint["u256"] = "core::integer::u256";
    Uint["u512"] = "core::integer::u512";
})(Uint || (exports.Uint = Uint = {}));
var Literal;
(function (Literal) {
    Literal["ClassHash"] = "core::starknet::class_hash::ClassHash";
    Literal["ContractAddress"] = "core::starknet::contract_address::ContractAddress";
    Literal["Secp256k1Point"] = "core::starknet::secp256k1::Secp256k1Point";
})(Literal || (exports.Literal = Literal = {}));

},{}],127:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],128:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPC = void 0;
__exportStar(require("./account"), exports);
__exportStar(require("./calldata"), exports);
__exportStar(require("./contract"), exports);
__exportStar(require("./lib"), exports);
__exportStar(require("./provider"), exports);
__exportStar(require("./signer"), exports);
__exportStar(require("./typedData"), exports);
__exportStar(require("./cairoEnum"), exports);
__exportStar(require("./transactionReceipt"), exports);
exports.RPC = require("./api");

},{"./account":118,"./api":119,"./cairoEnum":125,"./calldata":126,"./contract":127,"./lib":133,"./provider":135,"./signer":137,"./transactionReceipt":138,"./typedData":139}],129:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],130:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntryPointType = void 0;
// Basic elements
var EntryPointType;
(function (EntryPointType) {
    EntryPointType["EXTERNAL"] = "EXTERNAL";
    EntryPointType["L1_HANDLER"] = "L1_HANDLER";
    EntryPointType["CONSTRUCTOR"] = "CONSTRUCTOR";
})(EntryPointType || (exports.EntryPointType = EntryPointType = {}));
__exportStar(require("./abi"), exports);
__exportStar(require("./legacy"), exports);
__exportStar(require("./sierra"), exports);

},{"./abi":129,"./legacy":131,"./sierra":132}],131:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],132:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],133:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockTag = exports.BlockStatus = exports.TransactionExecutionStatus = exports.TransactionFinalityStatus = exports.TransactionStatus = exports.TransactionType = void 0;
var TransactionType;
(function (TransactionType) {
    TransactionType["DECLARE"] = "DECLARE";
    TransactionType["DEPLOY"] = "DEPLOY";
    TransactionType["DEPLOY_ACCOUNT"] = "DEPLOY_ACCOUNT";
    TransactionType["INVOKE"] = "INVOKE_FUNCTION";
})(TransactionType || (exports.TransactionType = TransactionType = {}));
/**
 * new statuses are defined by props: finality_status and execution_status
 * to be #deprecated
 */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["NOT_RECEIVED"] = "NOT_RECEIVED";
    TransactionStatus["RECEIVED"] = "RECEIVED";
    TransactionStatus["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
    TransactionStatus["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
    TransactionStatus["REJECTED"] = "REJECTED";
    TransactionStatus["REVERTED"] = "REVERTED";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
var TransactionFinalityStatus;
(function (TransactionFinalityStatus) {
    TransactionFinalityStatus["NOT_RECEIVED"] = "NOT_RECEIVED";
    TransactionFinalityStatus["RECEIVED"] = "RECEIVED";
    TransactionFinalityStatus["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
    TransactionFinalityStatus["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
})(TransactionFinalityStatus || (exports.TransactionFinalityStatus = TransactionFinalityStatus = {}));
var TransactionExecutionStatus;
(function (TransactionExecutionStatus) {
    TransactionExecutionStatus["REJECTED"] = "REJECTED";
    TransactionExecutionStatus["REVERTED"] = "REVERTED";
    TransactionExecutionStatus["SUCCEEDED"] = "SUCCEEDED";
})(TransactionExecutionStatus || (exports.TransactionExecutionStatus = TransactionExecutionStatus = {}));
var BlockStatus;
(function (BlockStatus) {
    BlockStatus["PENDING"] = "PENDING";
    BlockStatus["ACCEPTED_ON_L1"] = "ACCEPTED_ON_L1";
    BlockStatus["ACCEPTED_ON_L2"] = "ACCEPTED_ON_L2";
    BlockStatus["REJECTED"] = "REJECTED";
})(BlockStatus || (exports.BlockStatus = BlockStatus = {}));
var BlockTag;
(function (BlockTag) {
    BlockTag["PENDING"] = "pending";
    BlockTag["LATEST"] = "latest";
})(BlockTag || (exports.BlockTag = BlockTag = {}));
__exportStar(require("./contract"), exports);

},{"./contract":130}],134:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],135:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./configuration"), exports);
__exportStar(require("./response"), exports);

},{"./configuration":134,"./response":136}],136:[function(require,module,exports){
"use strict";
/**
 * Common interface response
 * Intersection (sequencer response  ( rpc responses))
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],137:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],138:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedDataRevision = void 0;
// Reexport types from package
var starknet_types_07_1 = require("starknet-types-07");
Object.defineProperty(exports, "TypedDataRevision", { enumerable: true, get: function () { return starknet_types_07_1.TypedDataRevision; } });

},{"starknet-types-07":73}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addAddressPadding = addAddressPadding;
exports.validateAndParseAddress = validateAndParseAddress;
exports.getChecksumAddress = getChecksumAddress;
exports.validateChecksumAddress = validateChecksumAddress;
/* eslint-disable no-bitwise */
var utils_1 = require("@noble/curves/abstract/utils");
var constants_1 = require("../constants");
var encode_1 = require("./encode");
var hash_1 = require("./hash");
var num_1 = require("./num");
/**
 * Format a hex number to '0x' and 64 characters, adding leading zeros if necessary.
 *
 * @param {BigNumberish} address
 * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.
 * @example
 * ```typescript
 * const address = "0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf";
 * const result = addAddressPadding(address);
 * // result = "0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf"
 * ```
 */
function addAddressPadding(address) {
    var hex = (0, num_1.toHex)((0, encode_1.addHexPrefix)(address.toString()));
    var padded = (0, encode_1.removeHexPrefix)(hex).padStart(64, '0');
    return (0, encode_1.addHexPrefix)(padded);
}
/**
 * Check the validity of a Starknet address, and format it as a hex number : '0x' and 64 characters, adding leading zeros if necessary.
 *
 * @param {BigNumberish} address
 * @returns {string} Hex string : 0x followed by 64 characters. No upper case characters in the response.
 * @throws address argument must be a valid address inside the address range bound
 * @example
 * ```typescript
 * const address = "0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf";
 * const result = validateAndParseAddress(address);
 * // result = "0x0000090591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf"
 * ```
 */
function validateAndParseAddress(address) {
    var result = addAddressPadding(address);
    if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
        throw new Error('Invalid Address Format');
    }
    (0, num_1.assertInRange)(result, constants_1.ZERO, constants_1.ADDR_BOUND - 1n, 'Starknet Address');
    return result;
}
/**
 * Convert an address to her checksum representation which uses a specific pattern of uppercase and lowercase letters within
 * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.
 * @param {BigNumberish} address
 * @returns {string} Hex string : 0x followed by 64 characters. Mix of uppercase and lowercase
 * @example
 * ```typescript
 * const address = "0x90591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf";
 * const result = getChecksumAddress(address);
 * // result = "0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF"
 * ```
 */
// from https://github.com/ethers-io/ethers.js/blob/fc1e006575d59792fa97b4efb9ea2f8cca1944cf/packages/address/src.ts/index.ts#L12
function getChecksumAddress(address) {
    var chars = (0, encode_1.removeHexPrefix)(validateAndParseAddress(address)).toLowerCase().split('');
    var hex = (0, encode_1.removeHexPrefix)((0, hash_1.keccakBn)(address));
    var hashed = (0, utils_1.hexToBytes)(hex.padStart(64, '0'));
    for (var i = 0; i < chars.length; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return (0, encode_1.addHexPrefix)(chars.join(''));
}
/**
 * If the casing of an address is mixed, it is a Checksum Address, which uses a specific pattern of uppercase and lowercase letters within
 * a given address to reduce the risk of errors introduced from typing an address or cut and paste issues.
 *
 * @param address string
 * @returns true if the ChecksumAddress is valid
 * @example
 * ```typescript
 * const address = "0x0000090591D9fA3EfC87067d95a643f8455E0b8190eb8Cb7bFd39e4fb7571fDF";
 * const result = validateChecksumAddress(address);
 * // result = true
 * ```
 */
function validateChecksumAddress(address) {
    return getChecksumAddress(address) === address;
}

},{"../constants":102,"./encode":163,"./hash":168,"./num":175,"@noble/curves/abstract/utils":31}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = assert;
/**
 * Asserts that the given condition is true, otherwise throws an error with an optional message.
 * @param {any} condition - The condition to check.
 * @param {string} [message] - The optional message to include in the error.
 * @throws {Error} Throws an error if the condition is false.
 * @example
 * ```typescript
 * const address = '0xa7ee790591d9fa3efc87067d95a643f8455e0b8190eb8cb7bfd39e4fb7571fdf';
 * assert(/^(0x)?[0-9a-fA-F]{64}$/.test(address), 'Invalid address format');
 * ```
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || 'Assertion failure');
    }
}

},{}],142:[function(require,module,exports){
"use strict";
// TODO Convert to CairoFelt base on CairoUint256 and implement it in the codebase in the backward compatible manner
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoFelt = CairoFelt;
var num_1 = require("../num");
var shortString_1 = require("../shortString");
/**
 * Create felt Cairo type (cairo type helper)
 * @returns format: felt-string
 */
function CairoFelt(it) {
    // BN or number
    if ((0, num_1.isBigInt)(it) || Number.isInteger(it)) {
        return it.toString();
    }
    // Handling strings
    if ((0, shortString_1.isString)(it)) {
        // Hex strings
        if ((0, num_1.isHex)(it)) {
            return BigInt(it).toString();
        }
        // Text strings that must be short
        if ((0, shortString_1.isText)(it)) {
            if (!(0, shortString_1.isShortString)(it)) {
                throw new Error("".concat(it, " is a long string > 31 chars. Please split it into an array of short strings."));
            }
            // Assuming encodeShortString returns a hex representation of the string
            return BigInt((0, shortString_1.encodeShortString)(it)).toString();
        }
        // Whole numeric strings
        if ((0, num_1.isStringWholeNumber)(it)) {
            return it;
        }
    }
    // bool to felt
    if ((0, num_1.isBoolean)(it)) {
        return "".concat(+it);
    }
    throw new Error("".concat(it, " can't be computed by felt()"));
}

},{"../num":175,"../shortString":180}],143:[function(require,module,exports){
"use strict";
/* eslint-disable no-bitwise */
/**
 * Singular class handling cairo u256 data type
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoUint256 = exports.UINT_256_HIGH_MIN = exports.UINT_256_LOW_MIN = exports.UINT_256_HIGH_MAX = exports.UINT_256_LOW_MAX = exports.UINT_256_MIN = exports.UINT_256_MAX = exports.UINT_128_MAX = void 0;
var encode_1 = require("../encode");
var felt_1 = require("./felt");
exports.UINT_128_MAX = (1n << 128n) - 1n;
exports.UINT_256_MAX = (1n << 256n) - 1n;
exports.UINT_256_MIN = 0n;
exports.UINT_256_LOW_MAX = 340282366920938463463374607431768211455n;
exports.UINT_256_HIGH_MAX = 340282366920938463463374607431768211455n;
exports.UINT_256_LOW_MIN = 0n;
exports.UINT_256_HIGH_MIN = 0n;
var CairoUint256 = /** @class */ (function () {
    function CairoUint256() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        if (typeof arr[0] === 'object' && arr.length === 1 && 'low' in arr[0] && 'high' in arr[0]) {
            var props = CairoUint256.validateProps(arr[0].low, arr[0].high);
            this.low = props.low;
            this.high = props.high;
        }
        else if (arr.length === 1) {
            var bigInt = CairoUint256.validate(arr[0]);
            this.low = bigInt & exports.UINT_128_MAX;
            this.high = bigInt >> 128n;
        }
        else if (arr.length === 2) {
            var props = CairoUint256.validateProps(arr[0], arr[1]);
            this.low = props.low;
            this.high = props.high;
        }
        else {
            throw Error('Incorrect constructor parameters');
        }
    }
    /**
     * Validate if BigNumberish can be represented as Unit256
     */
    CairoUint256.validate = function (bigNumberish) {
        var bigInt = BigInt(bigNumberish);
        if (bigInt < exports.UINT_256_MIN)
            throw Error('bigNumberish is smaller than UINT_256_MIN');
        if (bigInt > exports.UINT_256_MAX)
            throw new Error('bigNumberish is bigger than UINT_256_MAX');
        return bigInt;
    };
    /**
     * Validate if low and high can be represented as Unit256
     */
    CairoUint256.validateProps = function (low, high) {
        var bigIntLow = BigInt(low);
        var bigIntHigh = BigInt(high);
        if (bigIntLow < exports.UINT_256_LOW_MIN || bigIntLow > exports.UINT_256_LOW_MAX) {
            throw new Error('low is out of range UINT_256_LOW_MIN - UINT_256_LOW_MAX');
        }
        if (bigIntHigh < exports.UINT_256_HIGH_MIN || bigIntHigh > exports.UINT_256_HIGH_MAX) {
            throw new Error('high is out of range UINT_256_HIGH_MIN - UINT_256_HIGH_MAX');
        }
        return { low: bigIntLow, high: bigIntHigh };
    };
    /**
     * Check if BigNumberish can be represented as Unit256
     */
    CairoUint256.is = function (bigNumberish) {
        try {
            CairoUint256.validate(bigNumberish);
        }
        catch (error) {
            return false;
        }
        return true;
    };
    /**
     * Check if provided abi type is this data type
     */
    CairoUint256.isAbiType = function (abiType) {
        return abiType === CairoUint256.abiSelector;
    };
    /**
     * Return bigint representation
     */
    CairoUint256.prototype.toBigInt = function () {
        return (this.high << 128n) + this.low;
    };
    /**
     * Return Uint256 structure with HexString props
     * {low: HexString, high: HexString}
     */
    CairoUint256.prototype.toUint256HexString = function () {
        return {
            low: (0, encode_1.addHexPrefix)(this.low.toString(16)),
            high: (0, encode_1.addHexPrefix)(this.high.toString(16)),
        };
    };
    /**
     * Return Uint256 structure with DecimalString props
     * {low: DecString, high: DecString}
     */
    CairoUint256.prototype.toUint256DecimalString = function () {
        return {
            low: this.low.toString(10),
            high: this.high.toString(10),
        };
    };
    /**
     * Return api requests representation witch is felt array
     */
    CairoUint256.prototype.toApiRequest = function () {
        return [(0, felt_1.CairoFelt)(this.low), (0, felt_1.CairoFelt)(this.high)];
    };
    CairoUint256.abiSelector = 'core::integer::u256';
    return CairoUint256;
}());
exports.CairoUint256 = CairoUint256;

},{"../encode":163,"./felt":142}],144:[function(require,module,exports){
"use strict";
/* eslint-disable no-bitwise */
/**
 * Singular class handling cairo u512 data type
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoUint512 = exports.UINT_128_MIN = exports.UINT_512_MIN = exports.UINT_512_MAX = void 0;
var encode_1 = require("../encode");
var felt_1 = require("./felt");
var uint256_1 = require("./uint256");
exports.UINT_512_MAX = (1n << 512n) - 1n;
exports.UINT_512_MIN = 0n;
exports.UINT_128_MIN = 0n;
var CairoUint512 = /** @class */ (function () {
    function CairoUint512() {
        var arr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
        }
        if (typeof arr[0] === 'object' &&
            arr.length === 1 &&
            'limb0' in arr[0] &&
            'limb1' in arr[0] &&
            'limb2' in arr[0] &&
            'limb3' in arr[0]) {
            var props = CairoUint512.validateProps(arr[0].limb0, arr[0].limb1, arr[0].limb2, arr[0].limb3);
            this.limb0 = props.limb0;
            this.limb1 = props.limb1;
            this.limb2 = props.limb2;
            this.limb3 = props.limb3;
        }
        else if (arr.length === 1) {
            var bigInt = CairoUint512.validate(arr[0]);
            this.limb0 = bigInt & uint256_1.UINT_128_MAX;
            this.limb1 = (bigInt & (uint256_1.UINT_128_MAX << 128n)) >> 128n;
            this.limb2 = (bigInt & (uint256_1.UINT_128_MAX << 256n)) >> 256n;
            this.limb3 = bigInt >> 384n;
        }
        else if (arr.length === 4) {
            var props = CairoUint512.validateProps(arr[0], arr[1], arr[2], arr[3]);
            this.limb0 = props.limb0;
            this.limb1 = props.limb1;
            this.limb2 = props.limb2;
            this.limb3 = props.limb3;
        }
        else {
            throw Error('Incorrect Uint512 constructor parameters');
        }
    }
    /**
     * Validate if BigNumberish can be represented as Uint512
     */
    CairoUint512.validate = function (bigNumberish) {
        var bigInt = BigInt(bigNumberish);
        if (bigInt < exports.UINT_512_MIN)
            throw Error('bigNumberish is smaller than UINT_512_MIN.');
        if (bigInt > exports.UINT_512_MAX)
            throw Error('bigNumberish is bigger than UINT_512_MAX.');
        return bigInt;
    };
    /**
     * Validate if limbs can be represented as Uint512
     */
    CairoUint512.validateProps = function (limb0, limb1, limb2, limb3) {
        var l0 = BigInt(limb0);
        var l1 = BigInt(limb1);
        var l2 = BigInt(limb2);
        var l3 = BigInt(limb3);
        [l0, l1, l2, l3].forEach(function (value, index) {
            if (value < exports.UINT_128_MIN || value > uint256_1.UINT_128_MAX) {
                throw Error("limb".concat(index, " is not in the range of a u128 number"));
            }
        });
        return { limb0: l0, limb1: l1, limb2: l2, limb3: l3 };
    };
    /**
     * Check if BigNumberish can be represented as Uint512
     */
    CairoUint512.is = function (bigNumberish) {
        try {
            CairoUint512.validate(bigNumberish);
        }
        catch (error) {
            return false;
        }
        return true;
    };
    /**
     * Check if provided abi type is this data type
     */
    CairoUint512.isAbiType = function (abiType) {
        return abiType === CairoUint512.abiSelector;
    };
    /**
     * Return bigint representation
     */
    CairoUint512.prototype.toBigInt = function () {
        return (this.limb3 << 384n) + (this.limb2 << 256n) + (this.limb1 << 128n) + this.limb0;
    };
    /**
     * Return Uint512 structure with HexString props
     * limbx: HexString
     */
    CairoUint512.prototype.toUint512HexString = function () {
        return {
            limb0: (0, encode_1.addHexPrefix)(this.limb0.toString(16)),
            limb1: (0, encode_1.addHexPrefix)(this.limb1.toString(16)),
            limb2: (0, encode_1.addHexPrefix)(this.limb2.toString(16)),
            limb3: (0, encode_1.addHexPrefix)(this.limb3.toString(16)),
        };
    };
    /**
     * Return Uint512 structure with DecimalString props
     * limbx DecString
     */
    CairoUint512.prototype.toUint512DecimalString = function () {
        return {
            limb0: this.limb0.toString(10),
            limb1: this.limb1.toString(10),
            limb2: this.limb2.toString(10),
            limb3: this.limb3.toString(10),
        };
    };
    /**
     * Return api requests representation witch is felt array
     */
    CairoUint512.prototype.toApiRequest = function () {
        // lower limb first : https://github.com/starkware-libs/cairo/blob/07484c52791b76abcc18fd86265756904557d0d2/corelib/src/test/integer_test.cairo#L767
        return [
            (0, felt_1.CairoFelt)(this.limb0),
            (0, felt_1.CairoFelt)(this.limb1),
            (0, felt_1.CairoFelt)(this.limb2),
            (0, felt_1.CairoFelt)(this.limb3),
        ];
    };
    CairoUint512.abiSelector = 'core::integer::u512';
    return CairoUint512;
}());
exports.CairoUint512 = CairoUint512;

},{"../encode":163,"./felt":142,"./uint256":143}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringFromByteArray = stringFromByteArray;
exports.byteArrayFromString = byteArrayFromString;
var num_1 = require("../num");
var shortString_1 = require("../shortString");
/**
 * convert a Cairo ByteArray to a JS string
 * @param myByteArray Cairo representation of a LongString
 * @returns a JS string
 * @example
 * ```typescript
 * const myByteArray = {
 *    data: [],
 *    pending_word: '0x414243444546474849',
 *    pending_word_len: 9
 * }
 * const result: String = stringFromByteArray(myByteArray); // ABCDEFGHI
 * ```
 */
function stringFromByteArray(myByteArray) {
    var pending_word = BigInt(myByteArray.pending_word) === 0n
        ? ''
        : (0, shortString_1.decodeShortString)((0, num_1.toHex)(myByteArray.pending_word));
    return (myByteArray.data.reduce(function (cumuledString, encodedString) {
        var add = BigInt(encodedString) === 0n ? '' : (0, shortString_1.decodeShortString)((0, num_1.toHex)(encodedString));
        return cumuledString + add;
    }, '') + pending_word);
}
/**
 * convert a JS string to a Cairo ByteArray
 * @param targetString a JS string
 * @returns Cairo representation of a LongString
 * @example
 * ```typescript
 * const myByteArray: ByteArray = byteArrayFromString("ABCDEFGHI");
 * ```
 * Result is :
 * {
 *    data: [],
 *    pending_word: '0x414243444546474849',
 *    pending_word_len: 9
 * }
 */
function byteArrayFromString(targetString) {
    var shortStrings = (0, shortString_1.splitLongString)(targetString);
    var remainder = shortStrings[shortStrings.length - 1];
    var shortStringsEncoded = shortStrings.map(shortString_1.encodeShortString);
    var _a = remainder === undefined || remainder.length === 31
        ? ['0x00', 0]
        : [shortStringsEncoded.pop(), remainder.length], pendingWord = _a[0], pendingWordLength = _a[1];
    return {
        data: shortStringsEncoded.length === 0 ? [] : shortStringsEncoded,
        pending_word: pendingWord,
        pending_word_len: pendingWordLength,
    };
}

},{"../num":175,"../shortString":180}],146:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tuple = exports.uint512 = exports.uint256 = exports.getArrayType = exports.isCairo1Type = exports.isTypeSecp256k1Point = exports.isTypeByteArray = exports.isTypeBytes31 = exports.isTypeEthAddress = exports.isTypeContractAddress = exports.isTypeBool = exports.isTypeLiteral = exports.isTypeUint256 = exports.isTypeUint = exports.isTypeResult = exports.isTypeOption = exports.isTypeEnum = exports.isTypeStruct = exports.isTypeNamedTuple = exports.isTypeTuple = exports.isTypeArray = exports.isTypeFelt = exports.isLen = void 0;
exports.isCairo1Abi = isCairo1Abi;
exports.isTypeNonZero = isTypeNonZero;
exports.getAbiContractVersion = getAbiContractVersion;
exports.felt = felt;
var types_1 = require("../../types");
var felt_1 = require("../cairoDataTypes/felt");
var uint256_1 = require("../cairoDataTypes/uint256");
var uint512_1 = require("../cairoDataTypes/uint512");
// Intended for internal usage, maybe should be exported somewhere else and not exported to utils
/**
 * Checks if the given name ends with "_len".
 *
 * @param {string} name - The name to be checked.
 * @returns - True if the name ends with "_len", false otherwise.
 */
var isLen = function (name) { return /_len$/.test(name); };
exports.isLen = isLen;
/**
 * Checks if a given type is felt.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is felt, false otherwise.
 */
var isTypeFelt = function (type) { return type === 'felt' || type === 'core::felt252'; };
exports.isTypeFelt = isTypeFelt;
/**
 * Checks if the given type is an array type.
 *
 * @param {string} type - The type to check.
 * @returns - `true` if the type is an array type, `false` otherwise.
 */
var isTypeArray = function (type) {
    return /\*/.test(type) ||
        type.startsWith('core::array::Array::') ||
        type.startsWith('core::array::Span::');
};
exports.isTypeArray = isTypeArray;
/**
 * Checks if the given type is a tuple type.
 *
 * @param {string} type - The type to be checked.
 * @returns - `true` if the type is a tuple type, otherwise `false`.
 */
var isTypeTuple = function (type) { return /^\(.*\)$/i.test(type); };
exports.isTypeTuple = isTypeTuple;
/**
 * Checks whether a given type is a named tuple.
 *
 * @param {string} type - The type to be checked.
 * @returns - True if the type is a named tuple, false otherwise.
 */
var isTypeNamedTuple = function (type) { return /\(.*\)/i.test(type) && type.includes(':'); };
exports.isTypeNamedTuple = isTypeNamedTuple;
/**
 * Checks if a given type is a struct.
 *
 * @param {string} type - The type to check for existence.
 * @param {AbiStructs} structs - The collection of structs to search in.
 * @returns - True if the type exists in the structs, false otherwise.
 */
var isTypeStruct = function (type, structs) { return type in structs; };
exports.isTypeStruct = isTypeStruct;
/**
 * Checks if a given type is an enum.
 *
 * @param {string} type - The type to check.
 * @param {AbiEnums} enums - The enumeration to search in.
 * @returns - True if the type exists in the enumeration, otherwise false.
 */
var isTypeEnum = function (type, enums) { return type in enums; };
exports.isTypeEnum = isTypeEnum;
/**
 * Determines if the given type is an Option type.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is an Option type, false otherwise.
 */
var isTypeOption = function (type) { return type.startsWith('core::option::Option::'); };
exports.isTypeOption = isTypeOption;
/**
 * Checks whether a given type starts with 'core::result::Result::'.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type starts with 'core::result::Result::', false otherwise.
 */
var isTypeResult = function (type) { return type.startsWith('core::result::Result::'); };
exports.isTypeResult = isTypeResult;
/**
 * Checks if the given value is a valid Uint type.
 *
 * @param {string} type - The value to check.
 * @returns - Returns true if the value is a valid Uint type, otherwise false.
 */
var isTypeUint = function (type) { return Object.values(types_1.Uint).includes(type); };
exports.isTypeUint = isTypeUint;
// Legacy Export
/**
 * Checks if the given type is `uint256`.
 *
 * @param {string} type - The type to be checked.
 * @returns - Returns true if the type is `uint256`, otherwise false.
 */
var isTypeUint256 = function (type) { return uint256_1.CairoUint256.isAbiType(type); };
exports.isTypeUint256 = isTypeUint256;
/**
 * Checks if the given type is a literal type.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is a literal type, false otherwise.
 */
var isTypeLiteral = function (type) { return Object.values(types_1.Literal).includes(type); };
exports.isTypeLiteral = isTypeLiteral;
/**
 * Checks if the given type is a boolean type.
 *
 * @param {string} type - The type to be checked.
 * @returns - Returns true if the type is a boolean type, otherwise false.
 */
var isTypeBool = function (type) { return type === 'core::bool'; };
exports.isTypeBool = isTypeBool;
/**
 * Checks if the provided type is equal to 'core::starknet::contract_address::ContractAddress'.
 * @param {string} type - The type to be checked.
 * @returns - true if the type matches 'core::starknet::contract_address::ContractAddress', false otherwise.
 */
var isTypeContractAddress = function (type) {
    return type === 'core::starknet::contract_address::ContractAddress';
};
exports.isTypeContractAddress = isTypeContractAddress;
/**
 * Determines if the given type is an Ethereum address type.
 *
 * @param {string} type - The type to check.
 * @returns - Returns true if the given type is 'core::starknet::eth_address::EthAddress', otherwise false.
 */
var isTypeEthAddress = function (type) {
    return type === 'core::starknet::eth_address::EthAddress';
};
exports.isTypeEthAddress = isTypeEthAddress;
/**
 * Checks if the given type is 'core::bytes_31::bytes31'.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is 'core::bytes_31::bytes31', false otherwise.
 */
var isTypeBytes31 = function (type) { return type === 'core::bytes_31::bytes31'; };
exports.isTypeBytes31 = isTypeBytes31;
/**
 * Checks if the given type is equal to the 'core::byte_array::ByteArray'.
 *
 * @param {string} type - The type to check.
 * @returns - True if the given type is equal to 'core::byte_array::ByteArray', false otherwise.
 */
var isTypeByteArray = function (type) { return type === 'core::byte_array::ByteArray'; };
exports.isTypeByteArray = isTypeByteArray;
var isTypeSecp256k1Point = function (type) {
    return type === 'core::starknet::secp256k1::Secp256k1Point';
};
exports.isTypeSecp256k1Point = isTypeSecp256k1Point;
var isCairo1Type = function (type) { return type.includes('::'); };
exports.isCairo1Type = isCairo1Type;
/**
 * Retrieves the array type from the given type string.
 *
 * Works also for core::zeroable::NonZero type.
 * @param {string} type - The type string.
 * @returns - The array type.
 */
var getArrayType = function (type) {
    if ((0, exports.isCairo1Type)(type)) {
        return type.substring(type.indexOf('<') + 1, type.lastIndexOf('>'));
    }
    return type.replace('*', '');
};
exports.getArrayType = getArrayType;
/**
 * Test if an ABI comes from a Cairo 1 contract
 * @param abi representing the interface of a Cairo contract
 * @returns TRUE if it is an ABI from a Cairo1 contract
 * @example
 * ```typescript
 * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);
 * ```
 */
function isCairo1Abi(abi) {
    var cairo = getAbiContractVersion(abi).cairo;
    if (cairo === undefined) {
        throw Error('Unable to determine Cairo version');
    }
    return cairo === '1';
}
/**
 * Checks if the given type is a NonZero type.
 *
 * @param {string} type The type to check.
 * @returns `true` if the type is NonZero type, `false` otherwise.
 * @example
 * ```typescript
 * const result = cairo.isTypeNonZero("core::zeroable::NonZero::<u8>");
 * //result = true
 * ```
 */
function isTypeNonZero(type) {
    return type.startsWith('core::zeroable::NonZero::');
}
/**
 * Return ContractVersion (Abi version) based on Abi
 * or undefined for unknown version
 * @param abi
 * @returns string
 */
function getAbiContractVersion(abi) {
    // determine by interface for "Cairo 1.2"
    if (abi.find(function (it) { return it.type === 'interface'; })) {
        return { cairo: '1', compiler: '2' };
    }
    // determine by function io types "Cairo 1.1" or "Cairo 0.0"
    // find first function with inputs or outputs
    var testFunction = abi.find(function (it) { return it.type === 'function' && (it.inputs.length || it.outputs.length); });
    if (!testFunction) {
        return { cairo: undefined, compiler: undefined };
    }
    var io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;
    if ((0, exports.isCairo1Type)(io[0].type)) {
        return { cairo: '1', compiler: '1' };
    }
    return { cairo: '0', compiler: '0' };
}
/**
 * named tuple cairo type is described as js object {}
 * struct cairo type are described as js object {}
 * array cairo type are described as js array []
 */
/**
 * Create Uint256 Cairo type (helper for common struct type)
 * @example
 * ```typescript
 * uint256('892349863487563453485768723498');
 * ```
 */
var uint256 = function (it) {
    return new uint256_1.CairoUint256(it).toUint256DecimalString();
};
exports.uint256 = uint256;
/**
 * Create Uint512 Cairo type (helper for common struct type)
 * @param it BigNumberish representation of a 512 bits unsigned number
 * @returns Uint512 struct
 * @example
 * ```typescript
 * uint512('345745685892349863487563453485768723498');
 * ```
 */
var uint512 = function (it) {
    return new uint512_1.CairoUint512(it).toUint512DecimalString();
};
exports.uint512 = uint512;
/**
 * Create unnamed tuple Cairo type (helper same as common struct type)
 * @example
 * ```typescript
 * tuple(1, '0x101', 16);
 * ```
 */
var tuple = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return (__assign({}, args));
};
exports.tuple = tuple;
/**
 * Create felt Cairo type (cairo type helper)
 * @returns format: felt-string
 */
function felt(it) {
    return (0, felt_1.CairoFelt)(it);
}

},{"../../types":128,"../cairoDataTypes/felt":142,"../cairoDataTypes/uint256":143,"../cairoDataTypes/uint512":144}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoCustomEnum = void 0;
/**
 * Class to handle Cairo custom Enum
 * @param enumContent object containing the variants and its content. Example :
 *  {Success: 234, Warning: undefined, Error: undefined}.
 *  Only one variant with a value, object, array.
 * @returns an instance representing a Cairo custom Enum.
 * @example
 * ```typescript
 * const myCairoEnum = new CairoCustomEnum( {Success: undefined, Warning: "0x7f32ea", Error: undefined})
 * ```
 */
var CairoCustomEnum = /** @class */ (function () {
    /**
     * @param enumContent an object with the variants as keys and the content as value. Only one content shall be defined.
     */
    function CairoCustomEnum(enumContent) {
        var variantsList = Object.values(enumContent);
        if (variantsList.length === 0) {
            throw new Error('This Enum must have at least 1 variant');
        }
        var nbActiveVariants = variantsList.filter(function (content) { return typeof content !== 'undefined'; }).length;
        if (nbActiveVariants !== 1) {
            throw new Error('This Enum must have exactly one active variant');
        }
        this.variant = enumContent;
    }
    /**
     *
     * @returns the content of the valid variant of a Cairo custom Enum.
     */
    CairoCustomEnum.prototype.unwrap = function () {
        var variants = Object.entries(this.variant);
        var activeVariant = variants.find(function (item) { return typeof item[1] !== 'undefined'; });
        if (typeof activeVariant === 'undefined') {
            return undefined;
        }
        return activeVariant[1];
    };
    /**
     *
     * @returns the name of the valid variant of a Cairo custom Enum.
     */
    CairoCustomEnum.prototype.activeVariant = function () {
        var variants = Object.entries(this.variant);
        var activeVariant = variants.find(function (item) { return typeof item[1] !== 'undefined'; });
        if (typeof activeVariant === 'undefined') {
            return '';
        }
        return activeVariant[0];
    };
    return CairoCustomEnum;
}());
exports.CairoCustomEnum = CairoCustomEnum;

},{}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoOption = exports.CairoOptionVariant = void 0;
var CairoOptionVariant;
(function (CairoOptionVariant) {
    CairoOptionVariant[CairoOptionVariant["Some"] = 0] = "Some";
    CairoOptionVariant[CairoOptionVariant["None"] = 1] = "None";
})(CairoOptionVariant || (exports.CairoOptionVariant = CairoOptionVariant = {}));
/**
 * Class to handle Cairo Option
 * @param variant CairoOptionVariant.Some or CairoOptionVariant.None
 * @param someContent value of type T.
 * @returns an instance representing a Cairo Option.
 * @example
 * ```typescript
 * const myOption = new CairoOption<BigNumberish>(CairoOptionVariant.Some, "0x54dda8");
 * ```
 */
var CairoOption = /** @class */ (function () {
    function CairoOption(variant, someContent) {
        if (!(variant in CairoOptionVariant)) {
            throw new Error('Wrong variant : should be CairoOptionVariant.Some or .None.');
        }
        if (variant === CairoOptionVariant.Some) {
            if (typeof someContent === 'undefined') {
                throw new Error('The creation of a Cairo Option with "Some" variant needs a content as input.');
            }
            this.Some = someContent;
            this.None = undefined;
        }
        else {
            this.Some = undefined;
            this.None = true;
        }
    }
    /**
     *
     * @returns the content of the valid variant of a Cairo custom Enum.
     *  If None, returns 'undefined'.
     */
    CairoOption.prototype.unwrap = function () {
        if (this.None) {
            return undefined;
        }
        return this.Some;
    };
    /**
     *
     * @returns true if the valid variant is 'isSome'.
     */
    CairoOption.prototype.isSome = function () {
        return !(typeof this.Some === 'undefined');
    };
    /**
     *
     * @returns true if the valid variant is 'isNone'.
     */
    CairoOption.prototype.isNone = function () {
        return this.None === true;
    };
    return CairoOption;
}());
exports.CairoOption = CairoOption;

},{}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CairoResult = exports.CairoResultVariant = void 0;
var CairoResultVariant;
(function (CairoResultVariant) {
    CairoResultVariant[CairoResultVariant["Ok"] = 0] = "Ok";
    CairoResultVariant[CairoResultVariant["Err"] = 1] = "Err";
})(CairoResultVariant || (exports.CairoResultVariant = CairoResultVariant = {}));
/**
 * Class to handle Cairo Result
 * @param variant CairoResultVariant.Ok or CairoResultVariant.Err
 * @param resultContent value of type T or U.
 * @returns an instance representing a Cairo Result.
 * @example
 * ```typescript
 * const myOption = new CairoResult<BigNumberish, CustomError>(CairoResultVariant.Ok, "0x54dda8");
 * ```
 */
var CairoResult = /** @class */ (function () {
    function CairoResult(variant, resultContent) {
        if (!(variant in CairoResultVariant)) {
            throw new Error('Wrong variant : should be CairoResultVariant.Ok or .Err.');
        }
        if (variant === CairoResultVariant.Ok) {
            this.Ok = resultContent;
            this.Err = undefined;
        }
        else {
            this.Ok = undefined;
            this.Err = resultContent;
        }
    }
    /**
     *
     * @returns the content of the valid variant of a Cairo Result.
     */
    CairoResult.prototype.unwrap = function () {
        if (typeof this.Ok !== 'undefined') {
            return this.Ok;
        }
        if (typeof this.Err !== 'undefined') {
            return this.Err;
        }
        throw new Error('Both Result.Ok and .Err are undefined. Not authorized.');
    };
    /**
     *
     * @returns true if the valid variant is 'Ok'.
     */
    CairoResult.prototype.isOk = function () {
        return !(typeof this.Ok === 'undefined');
    };
    /**
     *
     * @returns true if the valid variant is 'isErr'.
     */
    CairoResult.prototype.isErr = function () {
        return !(typeof this.Err === 'undefined');
    };
    return CairoResult;
}());
exports.CairoResult = CairoResult;

},{}],150:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./CairoCustomEnum"), exports);
__exportStar(require("./CairoOption"), exports);
__exportStar(require("./CairoResult"), exports);

},{"./CairoCustomEnum":147,"./CairoOption":148,"./CairoResult":149}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = formatter;
var num_1 = require("../num");
var shortString_1 = require("../shortString");
var guard = {
    isBN: function (data, type, key) {
        if (!(0, num_1.isBigInt)(data[key]))
            throw new Error("Data and formatter mismatch on ".concat(key, ":").concat(type[key], ", expected response data ").concat(key, ":").concat(data[key], " to be BN instead it is ").concat(typeof data[key]));
    },
    unknown: function (data, type, key) {
        throw new Error("Unhandled formatter type on ".concat(key, ":").concat(type[key], " for data ").concat(key, ":").concat(data[key]));
    },
};
/**
 * Formats the given data based on the provided type definition.
 *
 * @param {any} data - The data to be formatted.
 * @param {any} type - The type definition for the data.
 * @param {any} [sameType] - The same type definition to be used (optional).
 * @returns - The formatted data.
 */
function formatter(data, type, sameType) {
    // match data element with type element
    return Object.entries(data).reduce(function (acc, _a) {
        var key = _a[0], value = _a[1];
        var elType = sameType !== null && sameType !== void 0 ? sameType : type[key];
        if (!(key in type) && !sameType) {
            // no type definition for element return original element
            acc[key] = value;
            return acc;
        }
        if (elType === 'string') {
            if (Array.isArray(data[key])) {
                // long string (felt*)
                var arrayStr = formatter(data[key], data[key].map(function (_) { return elType; }));
                acc[key] = Object.values(arrayStr).join('');
                return acc;
            }
            guard.isBN(data, type, key);
            acc[key] = (0, shortString_1.decodeShortString)(value);
            return acc;
        }
        if (elType === 'number') {
            guard.isBN(data, type, key);
            acc[key] = Number(value);
            return acc;
        }
        if (typeof elType === 'function') {
            acc[key] = elType(value);
            return acc;
        }
        if (Array.isArray(elType)) {
            var arrayObj = formatter(data[key], elType, elType[0]);
            acc[key] = Object.values(arrayObj);
            return acc;
        }
        if (typeof elType === 'object') {
            acc[key] = formatter(data[key], elType);
            return acc;
        }
        guard.unknown(data, type, key);
        return acc;
    }, {});
}

},{"../num":175,"../shortString":180}],152:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallData = exports.parseCalldataField = exports.byteArray = exports.cairo = void 0;
/* eslint-disable no-plusplus */
var types_1 = require("../../types");
var assert_1 = require("../assert");
var num_1 = require("../num");
var selector_1 = require("../hash/selector");
var shortString_1 = require("../shortString");
var byteArray_1 = require("./byteArray");
var cairo_1 = require("./cairo");
var enum_1 = require("./enum");
var formatter_1 = require("./formatter");
var parser_1 = require("./parser");
var propertyOrder_1 = require("./propertyOrder");
var requestParser_1 = require("./requestParser");
var responseParser_1 = require("./responseParser");
var validate_1 = require("./validate");
exports.cairo = require("./cairo");
exports.byteArray = require("./byteArray");
var requestParser_2 = require("./requestParser");
Object.defineProperty(exports, "parseCalldataField", { enumerable: true, get: function () { return requestParser_2.parseCalldataField; } });
var CallData = /** @class */ (function () {
    function CallData(abi) {
        this.structs = CallData.getAbiStruct(abi);
        this.enums = CallData.getAbiEnum(abi);
        this.parser = (0, parser_1.createAbiParser)(abi);
        this.abi = this.parser.getLegacyFormat();
    }
    /**
     * Validate arguments passed to the method as corresponding to the ones in the abi
     * @param type ValidateType - type of the method
     * @param method string - name of the method
     * @param args ArgsOrCalldata - arguments that are passed to the method
     */
    CallData.prototype.validate = function (type, method, args) {
        if (args === void 0) { args = []; }
        // ensure provided method of type exists
        if (type !== types_1.ValidateType.DEPLOY) {
            var invocableFunctionNames = this.abi
                .filter(function (abi) {
                if (abi.type !== 'function')
                    return false;
                var isView = abi.stateMutability === 'view' || abi.state_mutability === 'view';
                return type === types_1.ValidateType.INVOKE ? !isView : isView;
            })
                .map(function (abi) { return abi.name; });
            (0, assert_1.default)(invocableFunctionNames.includes(method), "".concat(type === types_1.ValidateType.INVOKE ? 'invocable' : 'viewable', " method not found in abi"));
        }
        // get requested method from abi
        var abiMethod = this.abi.find(function (abi) {
            return type === types_1.ValidateType.DEPLOY
                ? abi.name === method && abi.type === 'constructor'
                : abi.name === method && abi.type === 'function';
        });
        if ((0, parser_1.isNoConstructorValid)(method, args, abiMethod)) {
            return;
        }
        // validate arguments length
        var inputsLength = this.parser.methodInputsLength(abiMethod);
        if (args.length !== inputsLength) {
            throw Error("Invalid number of arguments, expected ".concat(inputsLength, " arguments, but got ").concat(args.length));
        }
        // validate parameters
        (0, validate_1.default)(abiMethod, args, this.structs, this.enums);
    };
    /**
     * Compile contract callData with abi
     * Parse the calldata by using input fields from the abi for that method
     * @param method string - method name
     * @param argsCalldata RawArgs - arguments passed to the method. Can be an array of arguments (in the order of abi definition), or an object constructed in conformity with abi (in this case, the parameter can be in a wrong order).
     * @return Calldata - parsed arguments in format that contract is expecting
     * @example
     * ```typescript
     * const calldata = myCallData.compile("constructor", ["0x34a", [1, 3n]]);
     * ```
     * ```typescript
     * const calldata2 = myCallData.compile("constructor", {list:[1, 3n], balance:"0x34"}); // wrong order is valid
     * ```
     */
    CallData.prototype.compile = function (method, argsCalldata) {
        var _this = this;
        var abiMethod = this.abi.find(function (abiFunction) { return abiFunction.name === method; });
        if ((0, parser_1.isNoConstructorValid)(method, argsCalldata, abiMethod)) {
            return [];
        }
        var args;
        if (Array.isArray(argsCalldata)) {
            args = argsCalldata;
        }
        else {
            // order the object
            var orderedObject = (0, propertyOrder_1.default)(argsCalldata, abiMethod.inputs, this.structs, this.enums);
            args = Object.values(orderedObject);
            //   // validate array elements to abi
            (0, validate_1.default)(abiMethod, args, this.structs, this.enums);
        }
        var argsIterator = args[Symbol.iterator]();
        var callArray = abiMethod.inputs.reduce(function (acc, input) {
            return (0, cairo_1.isLen)(input.name) && !(0, cairo_1.isCairo1Type)(input.type)
                ? acc
                : acc.concat((0, requestParser_1.parseCalldataField)(argsIterator, input, _this.structs, _this.enums));
        }, []);
        // add compiled property to array object
        Object.defineProperty(callArray, '__compiled__', {
            enumerable: false,
            writable: false,
            value: true,
        });
        return callArray;
    };
    /**
     * Compile contract callData without abi
     * @param rawArgs RawArgs representing cairo method arguments or string array of compiled data
     * @returns Calldata
     */
    CallData.compile = function (rawArgs) {
        var createTree = function (obj) {
            var getEntries = function (o, prefix) {
                if (prefix === void 0) { prefix = '.'; }
                var oe = Array.isArray(o) ? __spreadArray([o.length.toString()], o, true) : o;
                return Object.entries(oe).flatMap(function (_a) {
                    var k = _a[0], v = _a[1];
                    var value = v;
                    if (k === 'entrypoint')
                        value = (0, selector_1.getSelectorFromName)(value);
                    else if ((0, shortString_1.isLongText)(value))
                        value = (0, byteArray_1.byteArrayFromString)(value);
                    var kk = Array.isArray(oe) && k === '0' ? '$$len' : k;
                    if ((0, num_1.isBigInt)(value))
                        return [["".concat(prefix).concat(kk), (0, cairo_1.felt)(value)]];
                    if (Object(value) === value) {
                        var methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(value));
                        var keys = __spreadArray(__spreadArray([], Object.getOwnPropertyNames(value), true), methodsKeys, true);
                        if (keys.includes('isSome') && keys.includes('isNone')) {
                            // Option
                            var myOption = value;
                            var variantNb = myOption.isSome()
                                ? enum_1.CairoOptionVariant.Some
                                : enum_1.CairoOptionVariant.None;
                            if (myOption.isSome())
                                return getEntries({ 0: variantNb, 1: myOption.unwrap() }, "".concat(prefix).concat(kk, "."));
                            return [["".concat(prefix).concat(kk), (0, cairo_1.felt)(variantNb)]];
                        }
                        if (keys.includes('isOk') && keys.includes('isErr')) {
                            // Result
                            var myResult = value;
                            var variantNb = myResult.isOk() ? enum_1.CairoResultVariant.Ok : enum_1.CairoResultVariant.Err;
                            return getEntries({ 0: variantNb, 1: myResult.unwrap() }, "".concat(prefix).concat(kk, "."));
                        }
                        if (keys.includes('variant') && keys.includes('activeVariant')) {
                            // CustomEnum
                            var myEnum = value;
                            var activeVariant_1 = myEnum.activeVariant();
                            var listVariants = Object.keys(myEnum.variant);
                            var activeVariantNb = listVariants.findIndex(function (variant) { return variant === activeVariant_1; });
                            if (typeof myEnum.unwrap() === 'object' &&
                                Object.keys(myEnum.unwrap()).length === 0 // empty object : {}
                            ) {
                                return [["".concat(prefix).concat(kk), (0, cairo_1.felt)(activeVariantNb)]];
                            }
                            return getEntries({ 0: activeVariantNb, 1: myEnum.unwrap() }, "".concat(prefix).concat(kk, "."));
                        }
                        // normal object
                        return getEntries(value, "".concat(prefix).concat(kk, "."));
                    }
                    return [["".concat(prefix).concat(kk), (0, cairo_1.felt)(value)]];
                });
            };
            var result = Object.fromEntries(getEntries(obj));
            return result;
        };
        var callTreeArray;
        if (!Array.isArray(rawArgs)) {
            // flatten structs, tuples, add array length. Process leafs as Felt
            var callTree = createTree(rawArgs);
            // convert to array
            callTreeArray = Object.values(callTree);
        }
        else {
            // already compiled data but modified or raw args provided as array, recompile it
            // recreate tree
            var callObj = __assign({}, rawArgs);
            var callTree = createTree(callObj);
            callTreeArray = Object.values(callTree);
        }
        // add compiled property to array object
        Object.defineProperty(callTreeArray, '__compiled__', {
            enumerable: false,
            writable: false,
            value: true,
        });
        return callTreeArray;
    };
    /**
     * Parse elements of the response array and structuring them into response object
     * @param method string - method name
     * @param response string[] - response from the method
     * @return Result - parsed response corresponding to the abi
     */
    CallData.prototype.parse = function (method, response) {
        var _this = this;
        var outputs = this.abi.find(function (abi) { return abi.name === method; }).outputs;
        var responseIterator = response.flat()[Symbol.iterator]();
        var parsed = outputs.flat().reduce(function (acc, output, idx) {
            var _a;
            var propName = (_a = output.name) !== null && _a !== void 0 ? _a : idx;
            acc[propName] = (0, responseParser_1.default)(responseIterator, output, _this.structs, _this.enums, acc);
            if (acc[propName] && acc["".concat(propName, "_len")]) {
                delete acc["".concat(propName, "_len")];
            }
            return acc;
        }, {});
        // Cairo1 avoid object.0 structure
        return Object.keys(parsed).length === 1 && 0 in parsed ? parsed[0] : parsed;
    };
    /**
     * Format cairo method response data to native js values based on provided format schema
     * @param method string - cairo method name
     * @param response string[] - cairo method response
     * @param format object - formatter object schema
     * @returns Result - parsed and formatted response object
     */
    CallData.prototype.format = function (method, response, format) {
        var parsed = this.parse(method, response);
        return (0, formatter_1.default)(parsed, format);
    };
    /**
     * Helper to extract structs from abi
     * @param abi Abi
     * @returns AbiStructs - structs from abi
     */
    CallData.getAbiStruct = function (abi) {
        return abi
            .filter(function (abiEntry) { return abiEntry.type === 'struct'; })
            .reduce(function (acc, abiEntry) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[abiEntry.name] = abiEntry, _a)));
        }, {});
    };
    /**
     * Helper to extract enums from abi
     * @param abi Abi
     * @returns AbiEnums - enums from abi
     */
    CallData.getAbiEnum = function (abi) {
        var fullEnumList = abi
            .filter(function (abiEntry) { return abiEntry.type === 'enum'; })
            .reduce(function (acc, abiEntry) {
            var _a;
            return (__assign(__assign({}, acc), (_a = {}, _a[abiEntry.name] = abiEntry, _a)));
        }, {});
        delete fullEnumList['core::bool'];
        return fullEnumList;
    };
    /**
     * Helper: Compile HexCalldata | RawCalldata | RawArgs
     * @param rawCalldata HexCalldata | RawCalldata | RawArgs
     * @returns Calldata
     */
    CallData.toCalldata = function (rawCalldata) {
        if (rawCalldata === void 0) { rawCalldata = []; }
        return CallData.compile(rawCalldata);
    };
    /**
     * Helper: Convert raw to HexCalldata
     * @param raw HexCalldata | RawCalldata | RawArgs
     * @returns HexCalldata
     */
    CallData.toHex = function (raw) {
        if (raw === void 0) { raw = []; }
        var calldata = CallData.compile(raw);
        return calldata.map(function (it) { return (0, num_1.toHex)(it); });
    };
    /**
     * Parse the elements of a contract response and structure them into one or several Result.
     * In Cairo 0, arrays are not supported.
     * @param typeCairo string or string[] - Cairo type name, ex : "hello::hello::UserData"
     * @param response string[] - serialized data corresponding to typeCairo.
     * @return Result or Result[] - parsed response corresponding to typeData.
     * @example
     * const res2=helloCallData.decodeParameters("hello::hello::UserData",["0x123456","0x1"]);
     * result = { address: 1193046n, is_claimed: true }
     */
    CallData.prototype.decodeParameters = function (typeCairo, response) {
        var _this = this;
        var typeCairoArray = Array.isArray(typeCairo) ? typeCairo : [typeCairo];
        var responseIterator = response.flat()[Symbol.iterator]();
        var decodedArray = typeCairoArray.map(function (typeParam) {
            return (0, responseParser_1.default)(responseIterator, { name: '', type: typeParam }, _this.structs, _this.enums);
        });
        return decodedArray.length === 1 ? decodedArray[0] : decodedArray;
    };
    return CallData;
}());
exports.CallData = CallData;

},{"../../types":128,"../assert":141,"../hash/selector":169,"../num":175,"../shortString":180,"./byteArray":145,"./cairo":146,"./enum":150,"./formatter":151,"./parser":153,"./propertyOrder":156,"./requestParser":157,"./responseParser":158,"./validate":160}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAbiParser = createAbiParser;
exports.getAbiVersion = getAbiVersion;
exports.isNoConstructorValid = isNoConstructorValid;
var cairo_1 = require("../cairo");
var parser_0_1_1_0_1 = require("./parser-0-1.1.0");
var parser_2_0_0_1 = require("./parser-2.0.0");
function createAbiParser(abi) {
    var version = getAbiVersion(abi);
    if (version === 0 || version === 1) {
        return new parser_0_1_1_0_1.AbiParser1(abi);
    }
    if (version === 2) {
        return new parser_2_0_0_1.AbiParser2(abi);
    }
    throw Error("Unsupported ABI version ".concat(version));
}
function getAbiVersion(abi) {
    if (abi.find(function (it) { return it.type === 'interface'; }))
        return 2;
    if ((0, cairo_1.isCairo1Abi)(abi))
        return 1;
    return 0;
}
function isNoConstructorValid(method, argsCalldata, abiMethod) {
    // No constructor in abi and validly empty args
    return method === 'constructor' && !abiMethod && !argsCalldata.length;
}

},{"../cairo":146,"./parser-0-1.1.0":154,"./parser-2.0.0":155}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiParser1 = void 0;
var cairo_1 = require("../cairo");
var AbiParser1 = /** @class */ (function () {
    function AbiParser1(abi) {
        this.abi = abi;
    }
    /**
     * abi method inputs length without '_len' inputs
     * cairo 0 reducer
     * @param abiMethod FunctionAbi
     * @returns number
     */
    AbiParser1.prototype.methodInputsLength = function (abiMethod) {
        return abiMethod.inputs.reduce(function (acc, input) { return (!(0, cairo_1.isLen)(input.name) ? acc + 1 : acc); }, 0);
    };
    /**
     * get method definition from abi
     * @param name string
     * @returns FunctionAbi | undefined
     */
    AbiParser1.prototype.getMethod = function (name) {
        return this.abi.find(function (it) { return it.name === name; });
    };
    /**
     * Get Abi in legacy format
     * @returns Abi
     */
    AbiParser1.prototype.getLegacyFormat = function () {
        return this.abi;
    };
    return AbiParser1;
}());
exports.AbiParser1 = AbiParser1;

},{"../cairo":146}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiParser2 = void 0;
var AbiParser2 = /** @class */ (function () {
    function AbiParser2(abi) {
        this.abi = abi;
    }
    /**
     * abi method inputs length
     * @param abiMethod FunctionAbi
     * @returns number
     */
    AbiParser2.prototype.methodInputsLength = function (abiMethod) {
        return abiMethod.inputs.length;
    };
    /**
     * get method definition from abi
     * @param name string
     * @returns FunctionAbi | undefined
     */
    AbiParser2.prototype.getMethod = function (name) {
        var intf = this.abi.find(function (it) { return it.type === 'interface'; });
        return intf.items.find(function (it) { return it.name === name; });
    };
    /**
     * Get Abi in legacy format
     * @returns Abi
     */
    AbiParser2.prototype.getLegacyFormat = function () {
        return this.abi.flatMap(function (e) {
            if (e.type === 'interface') {
                return e.items;
            }
            return e;
        });
    };
    return AbiParser2;
}());
exports.AbiParser2 = AbiParser2;

},{}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = orderPropsByAbi;
var uint256_1 = require("../cairoDataTypes/uint256");
var uint512_1 = require("../cairoDataTypes/uint512");
var cairo_1 = require("./cairo");
var enum_1 = require("./enum");
var tuple_1 = require("./tuple");
var shortString_1 = require("../shortString");
function errorU256(key) {
    return Error("Your object includes the property : ".concat(key, ", containing an Uint256 object without the 'low' and 'high' keys."));
}
function errorU512(key) {
    return Error("Your object includes the property : ".concat(key, ", containing an Uint512 object without the 'limb0' to 'limb3' keys."));
}
function orderPropsByAbi(unorderedObject, abiOfObject, structs, enums) {
    var orderInput = function (unorderedItem, abiType) {
        if ((0, cairo_1.isTypeArray)(abiType)) {
            return orderArray(unorderedItem, abiType);
        }
        if ((0, cairo_1.isTypeEnum)(abiType, enums)) {
            var abiObj = enums[abiType];
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return orderEnum(unorderedItem, abiObj);
        }
        if ((0, cairo_1.isTypeTuple)(abiType)) {
            return orderTuple(unorderedItem, abiType);
        }
        if ((0, cairo_1.isTypeEthAddress)(abiType)) {
            return unorderedItem;
        }
        if ((0, cairo_1.isTypeNonZero)(abiType)) {
            return unorderedItem;
        }
        if ((0, cairo_1.isTypeByteArray)(abiType)) {
            return unorderedItem;
        }
        if ((0, cairo_1.isTypeSecp256k1Point)(abiType)) {
            return unorderedItem;
        }
        if (uint256_1.CairoUint256.isAbiType(abiType)) {
            var u256 = unorderedItem;
            if (typeof u256 !== 'object') {
                // BigNumberish --> just copy
                return u256;
            }
            if (!('low' in u256 && 'high' in u256)) {
                throw errorU256(abiType);
            }
            return { low: u256.low, high: u256.high };
        }
        if (uint512_1.CairoUint512.isAbiType(abiType)) {
            var u512_1 = unorderedItem;
            if (typeof u512_1 !== 'object') {
                // BigNumberish --> just copy
                return u512_1;
            }
            if (!['limb0', 'limb1', 'limb2', 'limb3'].every(function (key) { return key in u512_1; })) {
                throw errorU512(abiType);
            }
            return { limb0: u512_1.limb0, limb1: u512_1.limb1, limb2: u512_1.limb2, limb3: u512_1.limb3 };
        }
        if ((0, cairo_1.isTypeStruct)(abiType, structs)) {
            var abiOfStruct = structs[abiType].members;
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return orderStruct(unorderedItem, abiOfStruct);
        }
        // literals
        return unorderedItem;
    };
    var orderStruct = function (unorderedObject2, abiObject) {
        var orderedObject2 = abiObject.reduce(function (orderedObject, abiParam) {
            var setProperty = function (value) {
                return Object.defineProperty(orderedObject, abiParam.name, {
                    enumerable: true,
                    value: value !== null && value !== void 0 ? value : unorderedObject2[abiParam.name],
                });
            };
            if (unorderedObject2[abiParam.name] === 'undefined') {
                if ((0, cairo_1.isCairo1Type)(abiParam.type) || !(0, cairo_1.isLen)(abiParam.name)) {
                    throw Error("Your object needs a property with key : ".concat(abiParam.name, " ."));
                }
            }
            setProperty(orderInput(unorderedObject2[abiParam.name], abiParam.type));
            return orderedObject;
        }, {});
        return orderedObject2;
    };
    function orderArray(myArray, abiParam) {
        var typeInArray = (0, cairo_1.getArrayType)(abiParam);
        if ((0, shortString_1.isString)(myArray)) {
            return myArray; // longstring
        }
        return myArray.map(function (myElem) { return orderInput(myElem, typeInArray); });
    }
    function orderTuple(unorderedObject2, abiParam) {
        var typeList = (0, tuple_1.default)(abiParam);
        var orderedObject2 = typeList.reduce(function (orderedObject, abiTypeCairoX, index) {
            var myObjKeys = Object.keys(unorderedObject2);
            var setProperty = function (value) {
                return Object.defineProperty(orderedObject, index.toString(), {
                    enumerable: true,
                    value: value !== null && value !== void 0 ? value : unorderedObject2[myObjKeys[index]],
                });
            };
            var abiType = (abiTypeCairoX === null || abiTypeCairoX === void 0 ? void 0 : abiTypeCairoX.type) ? abiTypeCairoX.type : abiTypeCairoX; // Named tuple, or tuple
            setProperty(orderInput(unorderedObject2[myObjKeys[index]], abiType));
            return orderedObject;
        }, {});
        return orderedObject2;
    }
    var orderEnum = function (unorderedObject2, abiObject) {
        if ((0, cairo_1.isTypeResult)(abiObject.name)) {
            var unorderedResult = unorderedObject2;
            var resultOkType = abiObject.name.substring(abiObject.name.indexOf('<') + 1, abiObject.name.lastIndexOf(','));
            var resultErrType = abiObject.name.substring(abiObject.name.indexOf(',') + 1, abiObject.name.lastIndexOf('>'));
            if (unorderedResult.isOk()) {
                return new enum_1.CairoResult(enum_1.CairoResultVariant.Ok, orderInput(unorderedObject2.unwrap(), resultOkType));
            }
            return new enum_1.CairoResult(enum_1.CairoResultVariant.Err, orderInput(unorderedObject2.unwrap(), resultErrType));
        }
        if ((0, cairo_1.isTypeOption)(abiObject.name)) {
            var unorderedOption = unorderedObject2;
            var resultSomeType = abiObject.name.substring(abiObject.name.indexOf('<') + 1, abiObject.name.lastIndexOf('>'));
            if (unorderedOption.isSome()) {
                return new enum_1.CairoOption(enum_1.CairoOptionVariant.Some, orderInput(unorderedOption.unwrap(), resultSomeType));
            }
            // none(())
            return new enum_1.CairoOption(enum_1.CairoOptionVariant.None, {});
        }
        // custom Enum
        var unorderedCustomEnum = unorderedObject2;
        var variants = Object.entries(unorderedCustomEnum.variant);
        var newEntries = variants.map(function (variant) {
            if (typeof variant[1] === 'undefined') {
                return variant;
            }
            var variantType = abiObject.type.substring(abiObject.type.lastIndexOf('<') + 1, abiObject.type.lastIndexOf('>'));
            if (variantType === '()') {
                return variant;
            }
            return [variant[0], orderInput(unorderedCustomEnum.unwrap(), variantType)];
        });
        return new enum_1.CairoCustomEnum(Object.fromEntries(newEntries));
    };
    // Order Call Parameters
    var finalOrderedObject = abiOfObject.reduce(function (orderedObject, abiParam) {
        var setProperty = function (value) {
            return Object.defineProperty(orderedObject, abiParam.name, {
                enumerable: true,
                value: value,
            });
        };
        if ((0, cairo_1.isLen)(abiParam.name) && !(0, cairo_1.isCairo1Type)(abiParam.type)) {
            return orderedObject;
        }
        setProperty(orderInput(unorderedObject[abiParam.name], abiParam.type));
        return orderedObject;
    }, {});
    return finalOrderedObject;
}

},{"../cairoDataTypes/uint256":143,"../cairoDataTypes/uint512":144,"../shortString":180,"./cairo":146,"./enum":150,"./tuple":159}],157:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCalldataField = parseCalldataField;
var uint256_1 = require("../cairoDataTypes/uint256");
var uint512_1 = require("../cairoDataTypes/uint512");
var encode_1 = require("../encode");
var num_1 = require("../num");
var shortString_1 = require("../shortString");
var byteArray_1 = require("./byteArray");
var cairo_1 = require("./cairo");
var enum_1 = require("./enum");
var tuple_1 = require("./tuple");
/**
 * parse base types
 * @param type type from abi
 * @param val value provided
 * @returns string | string[]
 */
function parseBaseTypes(type, val) {
    switch (true) {
        case uint256_1.CairoUint256.isAbiType(type):
            return new uint256_1.CairoUint256(val).toApiRequest();
        case uint512_1.CairoUint512.isAbiType(type):
            return new uint512_1.CairoUint512(val).toApiRequest();
        case (0, cairo_1.isTypeBytes31)(type):
            return (0, shortString_1.encodeShortString)(val.toString());
        case (0, cairo_1.isTypeSecp256k1Point)(type): {
            var pubKeyETH = (0, encode_1.removeHexPrefix)((0, num_1.toHex)(val)).padStart(128, '0');
            var pubKeyETHy = (0, cairo_1.uint256)((0, encode_1.addHexPrefix)(pubKeyETH.slice(-64)));
            var pubKeyETHx = (0, cairo_1.uint256)((0, encode_1.addHexPrefix)(pubKeyETH.slice(0, -64)));
            return [
                (0, cairo_1.felt)(pubKeyETHx.low),
                (0, cairo_1.felt)(pubKeyETHx.high),
                (0, cairo_1.felt)(pubKeyETHy.low),
                (0, cairo_1.felt)(pubKeyETHy.high),
            ];
        }
        default:
            return (0, cairo_1.felt)(val);
    }
}
/**
 * Parse tuple type string to array of known objects
 * @param element request element
 * @param typeStr tuple type string
 * @returns Tupled[]
 */
function parseTuple(element, typeStr) {
    var memberTypes = (0, tuple_1.default)(typeStr);
    var elements = Object.values(element);
    if (elements.length !== memberTypes.length) {
        throw Error("ParseTuple: provided and expected abi tuple size do not match.\n      provided: ".concat(elements, " \n      expected: ").concat(memberTypes));
    }
    return memberTypes.map(function (it, dx) {
        var _a;
        return {
            element: elements[dx],
            type: (_a = it.type) !== null && _a !== void 0 ? _a : it,
        };
    });
}
function parseByteArray(element) {
    var myByteArray = (0, byteArray_1.byteArrayFromString)(element);
    return __spreadArray(__spreadArray([
        myByteArray.data.length.toString()
    ], myByteArray.data.map(function (bn) { return bn.toString(); }), true), [
        myByteArray.pending_word.toString(),
        myByteArray.pending_word_len.toString(),
    ], false);
}
/**
 * Deep parse of the object that has been passed to the method
 *
 * @param element - element that needs to be parsed
 * @param type  - name of the method
 * @param structs - structs from abi
 * @param enums - enums from abi
 * @return {string | string[]} - parsed arguments in format that contract is expecting
 */
function parseCalldataValue(element, type, structs, enums) {
    if (element === undefined) {
        throw Error("Missing parameter for type ".concat(type));
    }
    // value is Array
    if (Array.isArray(element)) {
        var result = [];
        result.push((0, cairo_1.felt)(element.length)); // Add length to array
        var arrayType_1 = (0, cairo_1.getArrayType)(type);
        return element.reduce(function (acc, it) {
            return acc.concat(parseCalldataValue(it, arrayType_1, structs, enums));
        }, result);
    }
    // checking if the passed element is struct
    if (structs[type] && structs[type].members.length) {
        if (uint256_1.CairoUint256.isAbiType(type)) {
            return new uint256_1.CairoUint256(element).toApiRequest();
        }
        if (uint512_1.CairoUint512.isAbiType(type)) {
            return new uint512_1.CairoUint512(element).toApiRequest();
        }
        if (type === 'core::starknet::eth_address::EthAddress')
            return parseBaseTypes(type, element);
        if (type === 'core::byte_array::ByteArray')
            return parseByteArray(element);
        var members = structs[type].members;
        var subElement_1 = element;
        return members.reduce(function (acc, it) {
            return acc.concat(parseCalldataValue(subElement_1[it.name], it.type, structs, enums));
        }, []);
    }
    // check if abi element is tuple
    if ((0, cairo_1.isTypeTuple)(type)) {
        var tupled = parseTuple(element, type);
        return tupled.reduce(function (acc, it) {
            var parsedData = parseCalldataValue(it.element, it.type, structs, enums);
            return acc.concat(parsedData);
        }, []);
    }
    // check if u256 C1v0
    if (uint256_1.CairoUint256.isAbiType(type)) {
        return new uint256_1.CairoUint256(element).toApiRequest();
    }
    // check if u512
    if (uint512_1.CairoUint512.isAbiType(type)) {
        return new uint512_1.CairoUint512(element).toApiRequest();
    }
    // check if Enum
    if ((0, cairo_1.isTypeEnum)(type, enums)) {
        var variants = enums[type].variants;
        // Option Enum
        if ((0, cairo_1.isTypeOption)(type)) {
            var myOption = element;
            if (myOption.isSome()) {
                var listTypeVariant_1 = variants.find(function (variant) { return variant.name === 'Some'; });
                if (typeof listTypeVariant_1 === 'undefined') {
                    throw Error("Error in abi : Option has no 'Some' variant.");
                }
                var typeVariantSome = listTypeVariant_1.type;
                if (typeVariantSome === '()') {
                    return enum_1.CairoOptionVariant.Some.toString();
                }
                var parsedParameter_1 = parseCalldataValue(myOption.unwrap(), typeVariantSome, structs, enums);
                if (Array.isArray(parsedParameter_1)) {
                    return __spreadArray([enum_1.CairoOptionVariant.Some.toString()], parsedParameter_1, true);
                }
                return [enum_1.CairoOptionVariant.Some.toString(), parsedParameter_1];
            }
            return enum_1.CairoOptionVariant.None.toString();
        }
        // Result Enum
        if ((0, cairo_1.isTypeResult)(type)) {
            var myResult = element;
            if (myResult.isOk()) {
                var listTypeVariant_2 = variants.find(function (variant) { return variant.name === 'Ok'; });
                if (typeof listTypeVariant_2 === 'undefined') {
                    throw Error("Error in abi : Result has no 'Ok' variant.");
                }
                var typeVariantOk = listTypeVariant_2.type;
                if (typeVariantOk === '()') {
                    return enum_1.CairoResultVariant.Ok.toString();
                }
                var parsedParameter_2 = parseCalldataValue(myResult.unwrap(), typeVariantOk, structs, enums);
                if (Array.isArray(parsedParameter_2)) {
                    return __spreadArray([enum_1.CairoResultVariant.Ok.toString()], parsedParameter_2, true);
                }
                return [enum_1.CairoResultVariant.Ok.toString(), parsedParameter_2];
            }
            // is Result::Err
            var listTypeVariant_3 = variants.find(function (variant) { return variant.name === 'Err'; });
            if (typeof listTypeVariant_3 === 'undefined') {
                throw Error("Error in abi : Result has no 'Err' variant.");
            }
            var typeVariantErr = listTypeVariant_3.type;
            if (typeVariantErr === '()') {
                return enum_1.CairoResultVariant.Err.toString();
            }
            var parsedParameter_3 = parseCalldataValue(myResult.unwrap(), typeVariantErr, structs, enums);
            if (Array.isArray(parsedParameter_3)) {
                return __spreadArray([enum_1.CairoResultVariant.Err.toString()], parsedParameter_3, true);
            }
            return [enum_1.CairoResultVariant.Err.toString(), parsedParameter_3];
        }
        // Custom Enum
        var myEnum = element;
        var activeVariant_1 = myEnum.activeVariant();
        var listTypeVariant = variants.find(function (variant) { return variant.name === activeVariant_1; });
        if (typeof listTypeVariant === 'undefined') {
            throw Error("Not find in abi : Enum has no '".concat(activeVariant_1, "' variant."));
        }
        var typeActiveVariant = listTypeVariant.type;
        var numActiveVariant = variants.findIndex(function (variant) { return variant.name === activeVariant_1; }); // can not fail due to check of listTypeVariant
        if (typeActiveVariant === '()') {
            return numActiveVariant.toString();
        }
        var parsedParameter = parseCalldataValue(myEnum.unwrap(), typeActiveVariant, structs, enums);
        if (Array.isArray(parsedParameter)) {
            return __spreadArray([numActiveVariant.toString()], parsedParameter, true);
        }
        return [numActiveVariant.toString(), parsedParameter];
    }
    if ((0, cairo_1.isTypeNonZero)(type)) {
        return parseBaseTypes((0, cairo_1.getArrayType)(type), element);
    }
    if (typeof element === 'object') {
        throw Error("Parameter ".concat(element, " do not align with abi parameter ").concat(type));
    }
    return parseBaseTypes(type, element);
}
/**
 * Parse one field of the calldata by using input field from the abi for that method
 *
 * @param argsIterator - Iterator for value of the field
 * @param input  - input(field) information from the abi that will be used to parse the data
 * @param structs - structs from abi
 * @param enums - enums from abi
 * @return {string | string[]} - parsed arguments in format that contract is expecting
 */
function parseCalldataField(argsIterator, input, structs, enums) {
    var name = input.name, type = input.type;
    var value = argsIterator.next().value;
    switch (true) {
        // Array
        case (0, cairo_1.isTypeArray)(type):
            if (!Array.isArray(value) && !(0, shortString_1.isText)(value)) {
                throw Error("ABI expected parameter ".concat(name, " to be array or long string, got ").concat(value));
            }
            if ((0, shortString_1.isString)(value)) {
                // long string match cairo felt*
                value = (0, shortString_1.splitLongString)(value);
            }
            return parseCalldataValue(value, input.type, structs, enums);
        case (0, cairo_1.isTypeNonZero)(type):
            return parseBaseTypes((0, cairo_1.getArrayType)(type), value);
        case type === 'core::starknet::eth_address::EthAddress':
            return parseBaseTypes(type, value);
        // Struct or Tuple
        case (0, cairo_1.isTypeStruct)(type, structs) ||
            (0, cairo_1.isTypeTuple)(type) ||
            uint256_1.CairoUint256.isAbiType(type) ||
            uint256_1.CairoUint256.isAbiType(type):
            return parseCalldataValue(value, type, structs, enums);
        // Enums
        case (0, cairo_1.isTypeEnum)(type, enums):
            return parseCalldataValue(value, type, structs, enums);
        // Felt or unhandled
        default:
            return parseBaseTypes(type, value);
    }
}

},{"../cairoDataTypes/uint256":143,"../cairoDataTypes/uint512":144,"../encode":163,"../num":175,"../shortString":180,"./byteArray":145,"./cairo":146,"./enum":150,"./tuple":159}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = responseParser;
var uint256_1 = require("../cairoDataTypes/uint256");
var uint512_1 = require("../cairoDataTypes/uint512");
var encode_1 = require("../encode");
var num_1 = require("../num");
var shortString_1 = require("../shortString");
var byteArray_1 = require("./byteArray");
var cairo_1 = require("./cairo");
var enum_1 = require("./enum");
var tuple_1 = require("./tuple");
/**
 * Parse base types
 * @param type type of element
 * @param it iterator
 * @returns bigint | boolean
 */
function parseBaseTypes(type, it) {
    var temp;
    switch (true) {
        case (0, cairo_1.isTypeBool)(type):
            temp = it.next().value;
            return Boolean(BigInt(temp));
        case uint256_1.CairoUint256.isAbiType(type):
            var low = it.next().value;
            var high = it.next().value;
            return new uint256_1.CairoUint256(low, high).toBigInt();
        case uint512_1.CairoUint512.isAbiType(type):
            var limb0 = it.next().value;
            var limb1 = it.next().value;
            var limb2 = it.next().value;
            var limb3 = it.next().value;
            return new uint512_1.CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
        case type === 'core::starknet::eth_address::EthAddress':
            temp = it.next().value;
            return BigInt(temp);
        case type === 'core::bytes_31::bytes31':
            temp = it.next().value;
            return (0, shortString_1.decodeShortString)(temp);
        case (0, cairo_1.isTypeSecp256k1Point)(type):
            var xLow = (0, encode_1.removeHexPrefix)(it.next().value).padStart(32, '0');
            var xHigh = (0, encode_1.removeHexPrefix)(it.next().value).padStart(32, '0');
            var yLow = (0, encode_1.removeHexPrefix)(it.next().value).padStart(32, '0');
            var yHigh = (0, encode_1.removeHexPrefix)(it.next().value).padStart(32, '0');
            var pubK = BigInt((0, encode_1.addHexPrefix)(xHigh + xLow + yHigh + yLow));
            return pubK;
        default:
            temp = it.next().value;
            return BigInt(temp);
    }
}
/**
 * Parse of the response elements that are converted to Object (Struct) by using the abi
 *
 * @param responseIterator - iterator of the response
 * @param element - element of the field {name: string, type: string}
 * @param structs - structs from abi
 * @param enums
 * @return {any} - parsed arguments in format that contract is expecting
 */
function parseResponseValue(responseIterator, element, structs, enums) {
    if (element.type === '()') {
        return {};
    }
    // type uint256 struct (c1v2)
    if (uint256_1.CairoUint256.isAbiType(element.type)) {
        var low = responseIterator.next().value;
        var high = responseIterator.next().value;
        return new uint256_1.CairoUint256(low, high).toBigInt();
    }
    // type uint512 struct
    if (uint512_1.CairoUint512.isAbiType(element.type)) {
        var limb0 = responseIterator.next().value;
        var limb1 = responseIterator.next().value;
        var limb2 = responseIterator.next().value;
        var limb3 = responseIterator.next().value;
        return new uint512_1.CairoUint512(limb0, limb1, limb2, limb3).toBigInt();
    }
    // type C1 ByteArray struct, representing a LongString
    if ((0, cairo_1.isTypeByteArray)(element.type)) {
        var parsedBytes31Arr = [];
        var bytes31ArrLen = BigInt(responseIterator.next().value);
        while (parsedBytes31Arr.length < bytes31ArrLen) {
            parsedBytes31Arr.push((0, num_1.toHex)(responseIterator.next().value));
        }
        var pending_word = (0, num_1.toHex)(responseIterator.next().value);
        var pending_word_len = BigInt(responseIterator.next().value);
        var myByteArray = {
            data: parsedBytes31Arr,
            pending_word: pending_word,
            pending_word_len: pending_word_len,
        };
        return (0, byteArray_1.stringFromByteArray)(myByteArray);
    }
    // type c1 array
    if ((0, cairo_1.isTypeArray)(element.type)) {
        // eslint-disable-next-line no-case-declarations
        var parsedDataArr = [];
        var el = { name: '', type: (0, cairo_1.getArrayType)(element.type) };
        var len = BigInt(responseIterator.next().value); // get length
        while (parsedDataArr.length < len) {
            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
        }
        return parsedDataArr;
    }
    // type NonZero
    if ((0, cairo_1.isTypeNonZero)(element.type)) {
        // eslint-disable-next-line no-case-declarations
        // const parsedDataArr: (BigNumberish | ParsedStruct | boolean | any[] | CairoEnum)[] = [];
        var el = { name: '', type: (0, cairo_1.getArrayType)(element.type) };
        // parsedDataArr.push();
        return parseResponseValue(responseIterator, el, structs, enums);
    }
    // type struct
    if (structs && element.type in structs && structs[element.type]) {
        if (element.type === 'core::starknet::eth_address::EthAddress') {
            return parseBaseTypes(element.type, responseIterator);
        }
        return structs[element.type].members.reduce(function (acc, el) {
            acc[el.name] = parseResponseValue(responseIterator, el, structs, enums);
            return acc;
        }, {});
    }
    // type Enum (only CustomEnum)
    if (enums && element.type in enums && enums[element.type]) {
        var variantNum_1 = Number(responseIterator.next().value); // get variant number
        var rawEnum = enums[element.type].variants.reduce(function (acc, variant, num) {
            if (num === variantNum_1) {
                acc[variant.name] = parseResponseValue(responseIterator, { name: '', type: variant.type }, structs, enums);
                return acc;
            }
            acc[variant.name] = undefined;
            return acc;
        }, {});
        // Option
        if (element.type.startsWith('core::option::Option')) {
            var content = variantNum_1 === enum_1.CairoOptionVariant.Some ? rawEnum.Some : undefined;
            return new enum_1.CairoOption(variantNum_1, content);
        }
        // Result
        if (element.type.startsWith('core::result::Result')) {
            var content = void 0;
            if (variantNum_1 === enum_1.CairoResultVariant.Ok) {
                content = rawEnum.Ok;
            }
            else {
                content = rawEnum.Err;
            }
            return new enum_1.CairoResult(variantNum_1, content);
        }
        // Cairo custom Enum
        var customEnum = new enum_1.CairoCustomEnum(rawEnum);
        return customEnum;
    }
    // type tuple
    if ((0, cairo_1.isTypeTuple)(element.type)) {
        var memberTypes = (0, tuple_1.default)(element.type);
        return memberTypes.reduce(function (acc, it, idx) {
            var name = (it === null || it === void 0 ? void 0 : it.name) ? it.name : idx;
            var type = (it === null || it === void 0 ? void 0 : it.type) ? it.type : it;
            var el = { name: name, type: type };
            acc[name] = parseResponseValue(responseIterator, el, structs, enums);
            return acc;
        }, {});
    }
    // type c1 array
    if ((0, cairo_1.isTypeArray)(element.type)) {
        // eslint-disable-next-line no-case-declarations
        var parsedDataArr = [];
        var el = { name: '', type: (0, cairo_1.getArrayType)(element.type) };
        var len = BigInt(responseIterator.next().value); // get length
        while (parsedDataArr.length < len) {
            parsedDataArr.push(parseResponseValue(responseIterator, el, structs, enums));
        }
        return parsedDataArr;
    }
    // base type
    return parseBaseTypes(element.type, responseIterator);
}
/**
 * Parse elements of the response and structuring them into one field by using output property from the abi for that method
 *
 * @param responseIterator - iterator of the response
 * @param output - output(field) information from the abi that will be used to parse the data
 * @param structs - structs from abi
 * @param parsedResult
 * @return - parsed response corresponding to the abi structure of the field
 */
function responseParser(responseIterator, output, structs, enums, parsedResult) {
    var name = output.name, type = output.type;
    var temp;
    switch (true) {
        case (0, cairo_1.isLen)(name):
            temp = responseIterator.next().value;
            return BigInt(temp);
        case (structs && type in structs) || (0, cairo_1.isTypeTuple)(type):
            return parseResponseValue(responseIterator, output, structs, enums);
        case enums && (0, cairo_1.isTypeEnum)(type, enums):
            return parseResponseValue(responseIterator, output, structs, enums);
        case (0, cairo_1.isTypeArray)(type):
            // C1 Array
            if ((0, cairo_1.isCairo1Type)(type)) {
                return parseResponseValue(responseIterator, output, structs, enums);
            }
            // C0 Array
            // eslint-disable-next-line no-case-declarations
            var parsedDataArr = [];
            if (parsedResult && parsedResult["".concat(name, "_len")]) {
                var arrLen = parsedResult["".concat(name, "_len")];
                while (parsedDataArr.length < arrLen) {
                    parsedDataArr.push(parseResponseValue(responseIterator, { name: name, type: output.type.replace('*', '') }, structs, enums));
                }
            }
            return parsedDataArr;
        case (0, cairo_1.isTypeNonZero)(type):
            return parseResponseValue(responseIterator, output, structs, enums);
        default:
            return parseBaseTypes(type, responseIterator);
    }
}

},{"../cairoDataTypes/uint256":143,"../cairoDataTypes/uint512":144,"../encode":163,"../num":175,"../shortString":180,"./byteArray":145,"./cairo":146,"./enum":150,"./tuple":159}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = extractTupleMemberTypes;
/* eslint-disable no-plusplus */
var cairo_1 = require("./cairo");
function parseNamedTuple(namedTuple) {
    var name = namedTuple.substring(0, namedTuple.indexOf(':'));
    var type = namedTuple.substring(name.length + ':'.length);
    return { name: name, type: type };
}
function parseSubTuple(s) {
    if (!s.includes('('))
        return { subTuple: [], result: s };
    var subTuple = [];
    var result = '';
    var i = 0;
    while (i < s.length) {
        if (s[i] === '(') {
            var counter = 1;
            var lBracket = i;
            i++;
            while (counter) {
                if (s[i] === ')')
                    counter--;
                if (s[i] === '(')
                    counter++;
                i++;
            }
            subTuple.push(s.substring(lBracket, i));
            result += ' ';
            i--;
        }
        else {
            result += s[i];
        }
        i++;
    }
    return {
        subTuple: subTuple,
        result: result,
    };
}
function extractCairo0Tuple(type) {
    var cleanType = type.replace(/\s/g, '').slice(1, -1); // remove first lvl () and spaces
    // Decompose subTuple
    var _a = parseSubTuple(cleanType), subTuple = _a.subTuple, result = _a.result;
    // Recompose subTuple
    var recomposed = result.split(',').map(function (it) {
        return subTuple.length ? it.replace(' ', subTuple.shift()) : it;
    });
    // Parse named tuple
    if ((0, cairo_1.isTypeNamedTuple)(type)) {
        recomposed = recomposed.reduce(function (acc, it) {
            return acc.concat(parseNamedTuple(it));
        }, []);
    }
    return recomposed;
}
function getClosureOffset(input, open, close) {
    for (var i = 0, counter = 0; i < input.length; i++) {
        if (input[i] === open) {
            counter++;
        }
        else if (input[i] === close && --counter === 0) {
            return i;
        }
    }
    return Number.POSITIVE_INFINITY;
}
function extractCairo1Tuple(type) {
    // un-named tuples support
    var input = type.slice(1, -1); // remove first lvl ()
    var result = [];
    var currentIndex = 0;
    var limitIndex;
    while (currentIndex < input.length) {
        switch (true) {
            // Tuple
            case input[currentIndex] === '(': {
                limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '(', ')') + 1;
                break;
            }
            case input.startsWith('core::result::Result::<', currentIndex) ||
                input.startsWith('core::array::Array::<', currentIndex) ||
                input.startsWith('core::option::Option::<', currentIndex):
                {
                    limitIndex = currentIndex + getClosureOffset(input.slice(currentIndex), '<', '>') + 1;
                    break;
                }
            default: {
                var commaIndex = input.indexOf(',', currentIndex);
                limitIndex = commaIndex !== -1 ? commaIndex : Number.POSITIVE_INFINITY;
            }
        }
        result.push(input.slice(currentIndex, limitIndex));
        currentIndex = limitIndex + 2; // +2 to skip ', '
    }
    return result;
}
/**
 * Convert tuple string definition into object like definition
 * @param type tuple string definition
 * @returns object like tuple
 */
function extractTupleMemberTypes(type) {
    if ((0, cairo_1.isCairo1Type)(type)) {
        return extractCairo1Tuple(type);
    }
    return extractCairo0Tuple(type);
}

},{"./cairo":146}],160:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = validateFields;
/**
 * Validate cairo contract method arguments
 * Flow: Determine type from abi and than validate against parameter
 */
var types_1 = require("../../types");
var assert_1 = require("../assert");
var uint256_1 = require("../cairoDataTypes/uint256");
var uint512_1 = require("../cairoDataTypes/uint512");
var num_1 = require("../num");
var shortString_1 = require("../shortString");
var cairo_1 = require("./cairo");
var validateFelt = function (parameter, input) {
    (0, assert_1.default)((0, shortString_1.isString)(parameter) || (0, num_1.isNumber)(parameter) || (0, num_1.isBigInt)(parameter), "Validate: arg ".concat(input.name, " should be a felt typed as (String, Number or BigInt)"));
    if ((0, shortString_1.isString)(parameter) && !(0, num_1.isHex)(parameter))
        return; // shortstring
    var param = BigInt(parameter.toString(10));
    (0, assert_1.default)(
    // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1266
    param >= 0n && param <= Math.pow(2n, 252n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^252-1]"));
};
var validateBytes31 = function (parameter, input) {
    (0, assert_1.default)((0, shortString_1.isString)(parameter), "Validate: arg ".concat(input.name, " should be a string."));
    (0, assert_1.default)(parameter.length < 32, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be a string of less than 32 characters."));
};
var validateByteArray = function (parameter, input) {
    (0, assert_1.default)((0, shortString_1.isString)(parameter), "Validate: arg ".concat(input.name, " should be a string."));
};
var validateUint = function (parameter, input) {
    if ((0, num_1.isNumber)(parameter)) {
        (0, assert_1.default)(parameter <= Number.MAX_SAFE_INTEGER, "Validation: Parameter is to large to be typed as Number use (BigInt or String)");
    }
    (0, assert_1.default)((0, shortString_1.isString)(parameter) ||
        (0, num_1.isNumber)(parameter) ||
        (0, num_1.isBigInt)(parameter) ||
        (typeof parameter === 'object' && 'low' in parameter && 'high' in parameter) ||
        (typeof parameter === 'object' &&
            ['limb0', 'limb1', 'limb2', 'limb3'].every(function (key) { return key in parameter; })), "Validate: arg ".concat(input.name, " of cairo type ").concat(input.type, " should be type (String, Number or BigInt), but is ").concat(typeof parameter, " ").concat(parameter, "."));
    var param;
    switch (input.type) {
        case types_1.Uint.u256:
            param = new uint256_1.CairoUint256(parameter).toBigInt();
            break;
        case types_1.Uint.u512:
            param = new uint512_1.CairoUint512(parameter).toBigInt();
            break;
        default:
            param = (0, num_1.toBigInt)(parameter);
    }
    switch (input.type) {
        case types_1.Uint.u8:
            (0, assert_1.default)(param >= 0n && param <= 255n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0 - 255]"));
            break;
        case types_1.Uint.u16:
            (0, assert_1.default)(param >= 0n && param <= 65535n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 65535]"));
            break;
        case types_1.Uint.u32:
            (0, assert_1.default)(param >= 0n && param <= 4294967295n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 4294967295]"));
            break;
        case types_1.Uint.u64:
            (0, assert_1.default)(param >= 0n && param <= Math.pow(2n, 64n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^64-1]"));
            break;
        case types_1.Uint.u128:
            (0, assert_1.default)(param >= 0n && param <= Math.pow(2n, 128n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^128-1]"));
            break;
        case types_1.Uint.u256:
            (0, assert_1.default)(param >= 0n && param <= Math.pow(2n, 256n) - 1n, "Validate: arg ".concat(input.name, " is ").concat(input.type, " 0 - 2^256-1"));
            break;
        case types_1.Uint.u512:
            (0, assert_1.default)(uint512_1.CairoUint512.is(param), "Validate: arg ".concat(input.name, " is ").concat(input.type, " 0 - 2^512-1"));
            break;
        case types_1.Literal.ClassHash:
            (0, assert_1.default)(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1670
            param >= 0n && param <= Math.pow(2n, 252n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^252-1]"));
            break;
        case types_1.Literal.ContractAddress:
            (0, assert_1.default)(
            // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1245
            param >= 0n && param <= Math.pow(2n, 252n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^252-1]"));
            break;
        case types_1.Literal.Secp256k1Point: {
            (0, assert_1.default)(param >= 0n && param <= Math.pow(2n, 512n) - 1n, "Validate: arg ".concat(input.name, " must be ").concat(input.type, " : a 512 bits number."));
            break;
        }
        default:
            break;
    }
};
var validateBool = function (parameter, input) {
    (0, assert_1.default)((0, num_1.isBoolean)(parameter), "Validate: arg ".concat(input.name, " of cairo type ").concat(input.type, " should be type (Boolean)"));
};
var validateStruct = function (parameter, input, structs) {
    // c1v2 uint256 or u512 in struct
    if (input.type === types_1.Uint.u256 || input.type === types_1.Uint.u512) {
        validateUint(parameter, input);
        return;
    }
    if (input.type === 'core::starknet::eth_address::EthAddress') {
        (0, assert_1.default)(typeof parameter !== 'object', "EthAddress type is waiting a BigNumberish. Got ".concat(parameter));
        var param = BigInt(parameter.toString(10));
        (0, assert_1.default)(
        // from : https://github.com/starkware-libs/starknet-specs/blob/29bab650be6b1847c92d4461d4c33008b5e50b1a/api/starknet_api_openrpc.json#L1259
        param >= 0n && param <= Math.pow(2n, 160n) - 1n, "Validate: arg ".concat(input.name, " cairo typed ").concat(input.type, " should be in range [0, 2^160-1]"));
        return;
    }
    (0, assert_1.default)(typeof parameter === 'object' && !Array.isArray(parameter), "Validate: arg ".concat(input.name, " is cairo type struct (").concat(input.type, "), and should be defined as js object (not array)"));
    // shallow struct validation, only first depth level
    structs[input.type].members.forEach(function (_a) {
        var name = _a.name;
        (0, assert_1.default)(Object.keys(parameter).includes(name), "Validate: arg ".concat(input.name, " should have a property ").concat(name));
    });
};
var validateEnum = function (parameter, input) {
    (0, assert_1.default)(typeof parameter === 'object' && !Array.isArray(parameter), "Validate: arg ".concat(input.name, " is cairo type Enum (").concat(input.type, "), and should be defined as js object (not array)"));
    var methodsKeys = Object.getOwnPropertyNames(Object.getPrototypeOf(parameter));
    var keys = __spreadArray(__spreadArray([], Object.getOwnPropertyNames(parameter), true), methodsKeys, true);
    if ((0, cairo_1.isTypeOption)(input.type) && keys.includes('isSome') && keys.includes('isNone')) {
        return; // Option Enum
    }
    if ((0, cairo_1.isTypeResult)(input.type) && keys.includes('isOk') && keys.includes('isErr')) {
        return; // Result Enum
    }
    if (keys.includes('variant') && keys.includes('activeVariant')) {
        return; // Custom Enum
    }
    throw new Error("Validate Enum: argument ".concat(input.name, ", type ").concat(input.type, ", value received ").concat(parameter, ", is not an Enum."));
};
var validateTuple = function (parameter, input) {
    (0, assert_1.default)(typeof parameter === 'object' && !Array.isArray(parameter), "Validate: arg ".concat(input.name, " should be a tuple (defined as object)"));
    // todo: skip tuple structural validation for now
};
var validateArray = function (parameter, input, structs, enums) {
    var baseType = (0, cairo_1.getArrayType)(input.type);
    // Long text (special case when parameter is not an array but long text)
    if ((0, cairo_1.isTypeFelt)(baseType) && (0, shortString_1.isLongText)(parameter)) {
        return;
    }
    (0, assert_1.default)(Array.isArray(parameter), "Validate: arg ".concat(input.name, " should be an Array"));
    switch (true) {
        case (0, cairo_1.isTypeFelt)(baseType):
            parameter.forEach(function (param) { return validateFelt(param, input); });
            break;
        case (0, cairo_1.isTypeTuple)(baseType):
            parameter.forEach(function (it) { return validateTuple(it, { name: input.name, type: baseType }); });
            break;
        case (0, cairo_1.isTypeArray)(baseType):
            parameter.forEach(function (param) {
                return validateArray(param, { name: '', type: baseType }, structs, enums);
            });
            break;
        case (0, cairo_1.isTypeStruct)(baseType, structs):
            parameter.forEach(function (it) {
                return validateStruct(it, { name: input.name, type: baseType }, structs);
            });
            break;
        case (0, cairo_1.isTypeEnum)(baseType, enums):
            parameter.forEach(function (it) { return validateEnum(it, { name: input.name, type: baseType }); });
            break;
        case (0, cairo_1.isTypeUint)(baseType) || (0, cairo_1.isTypeLiteral)(baseType):
            parameter.forEach(function (param) { return validateUint(param, { name: '', type: baseType }); });
            break;
        case (0, cairo_1.isTypeBool)(baseType):
            parameter.forEach(function (param) { return validateBool(param, input); });
            break;
        default:
            throw new Error("Validate Unhandled: argument ".concat(input.name, ", type ").concat(input.type, ", value ").concat(parameter));
    }
};
var validateNonZero = function (parameter, input) {
    // Telegram : https://t.me/sncorestars/11902/45433
    // Author : Ori Ziv (08/apr/2024)
    // "NonZero is only supported for purely numeric types (u*, i* and felt252) and EcPoint."
    //
    // As EcPoint do not includes trait Serde, it can't be seen in an ABI.
    // u512 is not compatible.
    // i* are not currently handled by Starknet.js (and core::zeroable::NonZero::<i*> seems not to work in Cairo 2.6.3).
    // so, are authorized here : u8, u16, u32, u64, u128, u256 and felt252.
    var baseType = (0, cairo_1.getArrayType)(input.type);
    (0, assert_1.default)(((0, cairo_1.isTypeUint)(baseType) && baseType !== uint512_1.CairoUint512.abiSelector) || (0, cairo_1.isTypeFelt)(baseType), "Validate: ".concat(input.name, " type is not authorized for NonZero type."));
    switch (true) {
        case (0, cairo_1.isTypeFelt)(baseType):
            validateFelt(parameter, input);
            (0, assert_1.default)(BigInt(parameter.toString(10)) > 0, 'Validate: value 0 is not authorized in NonZero felt252 type.');
            break;
        case (0, cairo_1.isTypeUint)(baseType):
            validateUint(parameter, { name: '', type: baseType });
            switch (input.type) {
                case types_1.Uint.u256:
                    (0, assert_1.default)(new uint256_1.CairoUint256(parameter).toBigInt() > 0, 'Validate: value 0 is not authorized in NonZero uint256 type.');
                    break;
                default:
                    (0, assert_1.default)((0, num_1.toBigInt)(parameter) > 0, 'Validate: value 0 is not authorized in NonZero uint type.');
            }
            break;
        default:
            throw new Error("Validate Unhandled: argument ".concat(input.name, ", type ").concat(input.type, ", value ").concat(parameter));
    }
};
function validateFields(abiMethod, args, structs, enums) {
    abiMethod.inputs.reduce(function (acc, input) {
        var parameter = args[acc];
        switch (true) {
            case (0, cairo_1.isLen)(input.name):
                return acc;
            case (0, cairo_1.isTypeFelt)(input.type):
                validateFelt(parameter, input);
                break;
            case (0, cairo_1.isTypeBytes31)(input.type):
                validateBytes31(parameter, input);
                break;
            case (0, cairo_1.isTypeUint)(input.type) || (0, cairo_1.isTypeLiteral)(input.type):
                validateUint(parameter, input);
                break;
            case (0, cairo_1.isTypeBool)(input.type):
                validateBool(parameter, input);
                break;
            case (0, cairo_1.isTypeByteArray)(input.type):
                validateByteArray(parameter, input);
                break;
            case (0, cairo_1.isTypeArray)(input.type):
                validateArray(parameter, input, structs, enums);
                break;
            case (0, cairo_1.isTypeStruct)(input.type, structs):
                validateStruct(parameter, input, structs);
                break;
            case (0, cairo_1.isTypeEnum)(input.type, enums):
                validateEnum(parameter, input);
                break;
            case (0, cairo_1.isTypeTuple)(input.type):
                validateTuple(parameter, input);
                break;
            case (0, cairo_1.isTypeNonZero)(input.type):
                validateNonZero(parameter, input);
                break;
            default:
                throw new Error("Validate Unhandled: argument ".concat(input.name, ", type ").concat(input.type, ", value ").concat(parameter));
        }
        return acc + 1;
    }, 0);
}

},{"../../types":128,"../assert":141,"../cairoDataTypes/uint256":143,"../cairoDataTypes/uint512":144,"../num":175,"../shortString":180,"./cairo":146}],161:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSierra = isSierra;
exports.extractContractHashes = extractContractHashes;
exports.contractClassResponseToLegacyCompiledContract = contractClassResponseToLegacyCompiledContract;
var hash_1 = require("./hash");
var json_1 = require("./json");
var stark_1 = require("./stark");
var shortString_1 = require("./shortString");
/**
 * Checks if a given contract is in Sierra (Safe Intermediate Representation) format.
 *
 * @param {CairoContract | string} contract - The contract to check. Can be either a CairoContract object or a string representation of the contract.
 * @return {boolean} - Returns true if the contract is a Sierra contract, otherwise false.
 * @example
 * ```typescript
 * const result = isSierra(contract);
 * // result = true | false
 * ```
 */
function isSierra(contract) {
    var compiledContract = (0, shortString_1.isString)(contract) ? (0, json_1.parse)(contract) : contract;
    return 'sierra_program' in compiledContract;
}
/**
 * Extracts contract hashes from `DeclareContractPayload`.
 *
 * @param {DeclareContractPayload} payload - The payload containing contract information.
 * @return {CompleteDeclareContractPayload} - The `CompleteDeclareContractPayload` with extracted contract hashes.
 * @throws {Error} - If extraction of compiledClassHash or classHash fails.
 * @example
 * ```typescript
 * const result = extractContractHashes(contract);
 * // result = {
 * //   contract: ...,
 * //   classHash: ...,
 * //   casm: ...,
 * //   compiledClassHash: ...,
 * // }
 * ```
 */
function extractContractHashes(payload) {
    var _a;
    var response = __assign({}, payload);
    if (isSierra(payload.contract)) {
        if (!payload.compiledClassHash && payload.casm) {
            response.compiledClassHash = (0, hash_1.computeCompiledClassHash)(payload.casm);
        }
        if (!response.compiledClassHash)
            throw new Error('Extract compiledClassHash failed, provide (CairoAssembly).casm file or compiledClassHash');
    }
    response.classHash = (_a = payload.classHash) !== null && _a !== void 0 ? _a : (0, hash_1.computeContractClassHash)(payload.contract);
    if (!response.classHash)
        throw new Error('Extract classHash failed, provide (CompiledContract).json file or classHash');
    return response;
}
/**
 * Helper to redeclare response Cairo0 contract
 */
function contractClassResponseToLegacyCompiledContract(ccr) {
    if (isSierra(ccr)) {
        throw Error('ContractClassResponse need to be LegacyContractClass (cairo0 response class)');
    }
    var contract = ccr;
    return __assign(__assign({}, contract), { program: (0, stark_1.decompressProgram)(contract.program) });
}

},{"./hash":168,"./json":173,"./shortString":180,"./stark":181}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.weierstrass = exports.starkCurve = void 0;
// TODO rename
exports.starkCurve = require("@scure/starknet");
exports.weierstrass = require("@noble/curves/abstract/weierstrass");

},{"@noble/curves/abstract/weierstrass":32,"@scure/starknet":43}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pascalToSnake = exports.IS_BROWSER = void 0;
exports.arrayBufferToString = arrayBufferToString;
exports.utf8ToArray = utf8ToArray;
exports.stringToArrayBuffer = stringToArrayBuffer;
exports.atobUniversal = atobUniversal;
exports.btoaUniversal = btoaUniversal;
exports.buf2hex = buf2hex;
exports.removeHexPrefix = removeHexPrefix;
exports.addHexPrefix = addHexPrefix;
exports.padLeft = padLeft;
exports.calcByteLength = calcByteLength;
exports.sanitizeBytes = sanitizeBytes;
exports.sanitizeHex = sanitizeHex;
var base_1 = require("@scure/base");
/* eslint-disable no-param-reassign */
exports.IS_BROWSER = typeof window !== 'undefined';
var STRING_ZERO = '0';
/**
 * Some functions recreated from https://github.com/pedrouid/enc-utils/blob/master/src/index.ts
 * enc-utils is not a dependency to avoid using `Buffer` which only works in node and not browsers
 */
/**
 * Convert array buffer to string
 *
 * *[internal usage]*
 *
 * @param {ArrayBuffer} array The ArrayBuffer to convert to string.
 * @returns {string} The converted string.
 *
 * @example
 * ```typescript
 * const buffer = new ArrayBuffer(5);
 * const view = new Uint8Array(buffer);
 * [72, 101, 108, 108, 111].forEach((x, idx) => view[idx] = x);
 * const result = encode.arrayBufferToString(buffer);
 * // result = "Hello"
 * ```
 */
function arrayBufferToString(array) {
    return new Uint8Array(array).reduce(function (data, byte) { return data + String.fromCharCode(byte); }, '');
}
/**
 * Convert utf8-string to Uint8Array
 *
 * *[internal usage]*
 *
 * @param {string} str The UTF-8 string to convert.
 * @returns {Uint8Array} The encoded Uint8Array.
 *
 * @example
 * ```typescript
 * const myString = 'Hi';
 * const result = encode.utf8ToArray(myString);
 * // result = Uint8Array(2) [ 72, 105 ]
 * ```
 */
function utf8ToArray(str) {
    return new TextEncoder().encode(str);
}
/**
 * Convert utf8-string to Uint8Array
 *
 * @deprecated equivalent to 'utf8ToArray', alias will be removed
 */
function stringToArrayBuffer(str) {
    return utf8ToArray(str);
}
/**
 * Convert string to array buffer (browser and node compatible)
 *
 * @param {string} a The Base64 encoded string to convert.
 * @returns {Uint8Array} The decoded Uint8Array.
 *
 * @example
 * ```typescript
 * const base64String = 'SGVsbG8='; // 'Hello' in Base64
 * const result = encode.atobUniversal(base64String);
 * // result = Uint8Array(5) [ 72, 101, 108, 108, 111 ]
 * ```
 */
function atobUniversal(a) {
    return base_1.base64.decode(a);
}
/**
 * Convert array buffer to string (browser and node compatible)
 *
 * @param {ArrayBuffer} b The Array buffer.
 * @returns {string} The Base64 encoded string.
 *
 * @example
 * ```typescript
 * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'
 * const result = encode.btoaUniversal(buffer);
 * // result = "SGVsbG8="
 * ```
 */
function btoaUniversal(b) {
    return base_1.base64.encode(new Uint8Array(b));
}
/**
 * Convert array buffer to hex-string
 *
 * @param {Uint8Array} buffer The encoded Uint8Array.
 * @returns {string} The hex-string
 *
 * @example
 * ```typescript
 * const buffer = new Uint8Array([72, 101, 108, 108, 111]); // Array with ASCII values for 'Hello'
 * const result = encode.buf2hex(buffer);
 * // result = "48656c6c6f"
 * ```
 */
function buf2hex(buffer) {
    return buffer.reduce(function (r, x) { return r + x.toString(16).padStart(2, '0'); }, '');
}
/**
 * Remove hex prefix '0x' from hex-string
 * @param hex hex-string
 * @returns {string} The hex-string
 *
 * @example
 * ```typescript
 * const hexStringWithPrefix = '0x48656c6c6f';
 * const result = encode.removeHexPrefix(hexStringWithPrefix);
 * // result: "48656c6c6f"
 * ```
 */
function removeHexPrefix(hex) {
    return hex.replace(/^0x/i, '');
}
/**
 * Add hex prefix '0x' to base16-string
 * @param hex base16-string
 * @returns {string} The hex-string
 *
 * @example
 * ```typescript
 * const plainHexString = '48656c6c6f';
 * const result = encode.addHexPrefix(plainHexString);
 * // result: "0x48656c6c6f"
 * ```
 */
function addHexPrefix(hex) {
    return "0x".concat(removeHexPrefix(hex));
}
/**
 * Prepend or append to string
 *
 * *[internal usage]*
 *
 * Pads a string to a certain length with a specific string.
 * The padding can be applied either to the left or the right of the input string.
 *
 * @param {string} str The string to pad.
 * @param {number} length The target length for the padded string.
 * @param {boolean} left Set to true to add padding to the left, false to add it to the right.
 * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.
 * @returns {string} The padded string.
 *
 * @example
 * ```typescript
 * const myString = 'hello';
 * const result = padString(myString, 10, true);
 * // result = '00000hello'
 * ```
 */
function padString(str, length, left, padding) {
    if (padding === void 0) { padding = STRING_ZERO; }
    var diff = length - str.length;
    var result = str;
    if (diff > 0) {
        var pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
    }
    return result;
}
/**
 * Prepend string (default with '0')
 *
 * Pads a string to a certain length with a specific string.
 * The padding can be applied only to the left of the input string.
 *
 * @param {string} str The string to pad.
 * @param {number} length The target length for the padded string.
 * @param {string} [padding='0'] The string to use for padding. Defaults to '0'.
 * @returns {string} The padded string.
 *
 * @example
 * ```typescript
 * const myString = '1A3F';
 * const result = encode.padLeft(myString, 10);
 * // result: '0000001A3F'
 * ```
 */
function padLeft(str, length, padding) {
    if (padding === void 0) { padding = STRING_ZERO; }
    return padString(str, length, true, padding);
}
/**
 * Calculate byte length of string
 *
 * *[no internal usage]*
 *
 * Calculates the byte length of a string based on a specified byte size.
 * The function rounds up the byte count to the nearest multiple of the specified byte size.
 *
 * @param {string} str The string whose byte length is to be calculated.
 * @param {number} [byteSize='8'] The size of the byte block to round up to. Defaults to 8.
 * @returns {number} The calculated byte length, rounded to the nearest multiple of byteSize.
 *
 * @example
 * ```typescript
 * const myString = 'Hello';
 * const result = encode.calcByteLength(myString, 4);
 * // result = 8 (rounded up to the nearest multiple of 4)
 *
 * ```
 */
function calcByteLength(str, byteSize) {
    if (byteSize === void 0) { byteSize = 8; }
    var length = str.length;
    var remainder = length % byteSize;
    return remainder ? ((length - remainder) / byteSize) * byteSize + byteSize : length;
}
/**
 * Prepend '0' to string bytes
 *
 * *[no internal usage]*
 *
 *
 * * Prepends padding to the left of a string to ensure it matches a specific byte length.
 * The function uses a specified padding character and rounds up the string length to the nearest multiple of `byteSize`.
 *
 * @param {string} str The string to be padded.
 * @param {number} [byteSize='8'] The byte block size to which the string length should be rounded up. Defaults to 8.
 * @param {string} [padding='0'] The character to use for padding. Defaults to '0'.
 * @returns {string} The padded string.
 *
 * @example
 * ```typescript
 * const myString = '123';
 * const result = encode.sanitizeBytes(myString);
 * // result: '00000123' (padded to 8 characters)
 * ```
 */
function sanitizeBytes(str, byteSize, padding) {
    if (byteSize === void 0) { byteSize = 8; }
    if (padding === void 0) { padding = STRING_ZERO; }
    return padLeft(str, calcByteLength(str, byteSize), padding);
}
/**
 * Sanitizes a hex-string by removing any existing '0x' prefix, padding the string with '0' to ensure it has even length,
 * and then re-adding the '0x' prefix.
 *
 * *[no internal usage]*
 * @param hex hex-string
 * @returns format: hex-string
 *
 * @example
 * ```typescript
 * const unevenHex = '0x23abc';
 * const result = encode.sanitizeHex(unevenHex);
 * // result = '0x023abc' (padded to ensure even length)
 * ```
 */
function sanitizeHex(hex) {
    hex = removeHexPrefix(hex);
    hex = sanitizeBytes(hex, 2);
    if (hex) {
        hex = addHexPrefix(hex);
    }
    return hex;
}
/**
 * String transformation util
 *
 * Pascal case to screaming snake case
 *
 * @param {string} text The PascalCase string to convert.
 * @returns {string} The converted snake_case string in uppercase.
 *
 * @example
 * ```typescript
 * const pascalString = 'PascalCaseExample';
 * const result = encode.pascalToSnake(pascalString);
 * // result: 'PASCAL_CASE_EXAMPLE'
 * ```
 */
var pascalToSnake = function (text) {
    return /[a-z]/.test(text)
        ? text
            .split(/(?=[A-Z])/)
            .join('_')
            .toUpperCase()
        : text;
};
exports.pascalToSnake = pascalToSnake;

},{"@scure/base":42}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethRandomPrivateKey = ethRandomPrivateKey;
exports.validateAndParseEthAddress = validateAndParseEthAddress;
var secp256k1_1 = require("@noble/curves/secp256k1");
var encode_1 = require("./encode");
var num_1 = require("./num");
var constants_1 = require("../constants");
var assert_1 = require("./assert");
/**
 * Get random Ethereum private Key.
 * @returns an Hex string
 * @example
 * ```typescript
 * const myPK: string = randomAddress()
 * // result = "0xf04e69ac152fba37c02929c2ae78c9a481461dda42dbc6c6e286be6eb2a8ab83"
 * ```
 */
function ethRandomPrivateKey() {
    return (0, encode_1.sanitizeHex)((0, encode_1.buf2hex)(secp256k1_1.secp256k1.utils.randomPrivateKey()));
}
/**
 * Get a string formatted for an Ethereum address, without uppercase characters.
 * @param {BigNumberish} address Address of an Ethereum account.
 * @returns an Hex string coded on 20 bytes
 * @example
 * ```typescript
 * const myEthAddress: string = validateAndParseEthAddress("0x8359E4B0152ed5A731162D3c7B0D8D56edB165")
 * // result = "0x008359e4b0152ed5a731162d3c7b0d8d56edb165"
 * ```
 */
function validateAndParseEthAddress(address) {
    (0, num_1.assertInRange)(address, constants_1.ZERO, Math.pow(2n, 160n) - 1n, 'Ethereum Address ');
    var result = (0, encode_1.addHexPrefix)((0, encode_1.removeHexPrefix)((0, num_1.toHex)(address)).padStart(40, '0'));
    (0, assert_1.default)(Boolean(result.match(/^(0x)?[0-9a-f]{40}$/)), 'Invalid Ethereum Address Format');
    return result;
}

},{"../constants":102,"./assert":141,"./encode":163,"./num":175,"@noble/curves/secp256k1":33}],165:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAbiEvent = isAbiEvent;
exports.getAbiEvents = getAbiEvents;
exports.isObject = isObject;
exports.parseEvents = parseEvents;
exports.parseUDCEvent = parseUDCEvent;
var constants_1 = require("../../constants");
var assert_1 = require("../assert");
var cairo_1 = require("../calldata/cairo");
var responseParser_1 = require("../calldata/responseParser");
var ec_1 = require("../ec");
var encode_1 = require("../encode");
var num_1 = require("../num");
/**
 * Check if an ABI entry is related to events.
 * @param {AbiEntry} object an Abi entry
 * @returns {boolean} true if this Abi Entry is related to an event
 * @example
 * ```typescript
 * // use of a transaction receipt
 * ```
 */
function isAbiEvent(object) {
    return object.type === 'event';
}
/**
 * Retrieves the events from the given Cairo 0 ABI.
 * @param {Abi} abi - The Cairo 0 ABI to extract events from.
 * @return {AbiEvents} - An object containing the hashes and the definition of the events.
 * @example
 * ```typescript
 * const result = events.getCairo0AbiEvents(abi0);
 * // result = {
  '0x35ea10b06d74221d24a134672e9f776a3088ba6b9829e53b9a10abd8817a211': {
    data: [{ name: 'admin_requester', type: 'felt' }, { name: 'new_requester', type: 'felt' }],
    keys: [],
    name: 'AddAdmin',
    type: 'event'
  }
 * ```
 */
function getCairo0AbiEvents(abi) {
    return abi
        .filter(function (abiEntry) { return abiEntry.type === 'event'; })
        .reduce(function (acc, abiEntry) {
        var _a;
        var entryName = abiEntry.name;
        var abiEntryMod = __assign({}, abiEntry);
        abiEntryMod.name = entryName;
        return __assign(__assign({}, acc), (_a = {}, _a[(0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(entryName)).toString(16))] = abiEntryMod, _a));
    }, {});
}
/**
 * Retrieves the events from the given Cairo 1 ABI.
 *
 * Is able to handle events nested in Cairo components.
 * @param {Abi} abi - The Cairo 1 ABI to extract events from.
 * @return {AbiEvents} - An object containing the hashes and the definition of the events.
 * @example
 * ```typescript
 * const result = events.getCairo1AbiEvents(abi1);
 * // result = {
 * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':
 * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {
 * //     kind: 'struct', type: 'event',
 * //     name: 'ka::ExComponent::ex_logic_component::Mint',
      
 * //     members: [{
 * //      name: 'spender',
 * //      type: 'core::starknet::contract_address::ContractAddress',
 * //      kind: 'key'},
 * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},
 * // ...
 * ```
 */
function getCairo1AbiEvents(abi) {
    var abiEventsStructs = abi.filter(function (obj) { return isAbiEvent(obj) && obj.kind === 'struct'; });
    var abiEventsEnums = abi.filter(function (obj) { return isAbiEvent(obj) && obj.kind === 'enum'; });
    var abiEventsData = abiEventsStructs.reduce(function (acc, event) {
        var _a, _b;
        var nameList = [];
        var name = event.name;
        var flat = false;
        var findName = function (variant) { return variant.type === name; };
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var eventEnum = abiEventsEnums.find(function (eventE) { return eventE.variants.some(findName); });
            if (typeof eventEnum === 'undefined')
                break;
            var variant = eventEnum.variants.find(findName);
            nameList.unshift(variant.name);
            if (variant.kind === 'flat')
                flat = true;
            name = eventEnum.name;
        }
        if (nameList.length === 0) {
            throw new Error('inconsistency in ABI events definition.');
        }
        if (flat)
            nameList = [nameList[nameList.length - 1]];
        var final = nameList.pop();
        var result = (_a = {},
            _a[(0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(final)).toString(16))] = event,
            _a);
        while (nameList.length > 0) {
            result = (_b = {},
                _b[(0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(nameList.pop())).toString(16))] = result,
                _b);
        }
        result = __assign({}, result);
        return mergeAbiEvents(acc, result);
    }, {});
    return abiEventsData;
}
/**
 * Retrieves the events from the given ABI (from Cairo 0 or Cairo 1 contract).
 *
 * Is able to handle Cairo 1 events nested in Cairo components.
 * @param {Abi} abi - The ABI to extract events from.
 * @return {AbiEvents} - An object containing the hashes and the definition of the events.
 * @example
 * ```typescript
 * const result = events.getAbiEvents(abi);
 * // result = {
 * //   '0x22ea134d4126804c60797e633195f8c9aa5fd6d1567e299f4961d0e96f373ee':
 * //    { '0x34e55c1cd55f1338241b50d352f0e91c7e4ffad0e4271d64eb347589ebdfd16': {
 * //     kind: 'struct', type: 'event',
 * //     name: 'ka::ExComponent::ex_logic_component::Mint',
      
 * //     members: [{
 * //      name: 'spender',
 * //      type: 'core::starknet::contract_address::ContractAddress',
 * //      kind: 'key'},
 * //      { name: 'value', type: 'core::integer::u256', kind: 'data' }]},
 * // ...
 * ```
 */
function getAbiEvents(abi) {
    return (0, cairo_1.isCairo1Abi)(abi) ? getCairo1AbiEvents(abi) : getCairo0AbiEvents(abi);
}
/**
 * Checks if a given value is an object (Object or Array)
 * @param {any} item the tested item
 * @returns {boolean}
 * @example
 * ```typescript
 * const result = events.isObject({event: "pending"});
 * // result = true
 * ```
 */
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
/**
 * internal function to deep merge 2 event description objects
 */
function mergeAbiEvents(target, source) {
    var output = __assign({}, target);
    if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach(function (key) {
            var _a, _b;
            if (isObject(source[key])) {
                if (!(key in target))
                    Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                else
                    output[key] = mergeAbiEvents(target[key], source[key]);
            }
            else {
                Object.assign(output, (_b = {}, _b[key] = source[key], _b));
            }
        });
    }
    return output;
}
/**
 * Parse raw events and structure them into response object based on a contract structs and defined events
 * @param {RPC.Event[]} providerReceivedEvents Array of raw events
 * @param {AbiEvents} abiEvents Events defined in the abi
 * @param {AbiStructs} abiStructs Structs defined in the abi
 * @param {AbiEnums} abiEnums Enums defined in the abi
 * @returns {ParsedEvents} parsed events corresponding to the abi
 * @example
 * ```typescript
 * const abiEvents = events.getAbiEvents(sierra.abi);
 * const abiStructs =  CallData.getAbiStruct(sierra.abi);
 * const abiEnums = CallData.getAbiEnum(sierra.abi);
 * const result = events.parseEvents(myEvents, abiEvents, abiStructs, abiEnums);
 * // result = [{test::ExCh::ex_ch::Trade: {
      maker: 7548613724711489396448209137n,
      taker: 6435850562375218974960297344n,
      router_maker: 0n,
    }}]
 * ```
 */
function parseEvents(providerReceivedEvents, abiEvents, abiStructs, abiEnums) {
    var ret = providerReceivedEvents.flat().reduce(function (acc, recEvent) {
        var _a, _b, _c;
        var abiEvent = abiEvents[(_a = recEvent.keys.shift()) !== null && _a !== void 0 ? _a : 0];
        if (!abiEvent) {
            return acc;
        }
        while (!abiEvent.name) {
            var hashName = recEvent.keys.shift();
            (0, assert_1.default)(!!hashName, 'Not enough data in "key" property of this event.');
            abiEvent = abiEvent[hashName];
        }
        // Create our final event object
        var parsedEvent = {};
        parsedEvent[abiEvent.name] = {};
        // Remove the event's name hashed from the keys array
        var keysIter = recEvent.keys[Symbol.iterator]();
        var dataIter = recEvent.data[Symbol.iterator]();
        var abiEventKeys = ((_b = abiEvent.members) === null || _b === void 0 ? void 0 : _b.filter(function (it) { return it.kind === 'key'; })) ||
            abiEvent.keys;
        var abiEventData = ((_c = abiEvent.members) === null || _c === void 0 ? void 0 : _c.filter(function (it) { return it.kind === 'data'; })) ||
            abiEvent.data;
        abiEventKeys.forEach(function (key) {
            parsedEvent[abiEvent.name][key.name] = (0, responseParser_1.default)(keysIter, key, abiStructs, abiEnums, parsedEvent[abiEvent.name]);
        });
        abiEventData.forEach(function (data) {
            parsedEvent[abiEvent.name][data.name] = (0, responseParser_1.default)(dataIter, data, abiStructs, abiEnums, parsedEvent[abiEvent.name]);
        });
        acc.push(parsedEvent);
        return acc;
    }, []);
    return ret;
}
/**
 * Parse Transaction Receipt Event from UDC invoke transaction and
 * create DeployContractResponse compatible response with addition of the UDC Event data
 *
 * @returns DeployContractResponse | UDC Event Response data
 */
function parseUDCEvent(txReceipt) {
    if (!txReceipt.events) {
        throw new Error('UDC emitted event is empty');
    }
    var event = txReceipt.events.find(function (it) { return (0, num_1.cleanHex)(it.from_address) === (0, num_1.cleanHex)(constants_1.UDC.ADDRESS); }) || {
        data: [],
    };
    return {
        transaction_hash: txReceipt.transaction_hash,
        contract_address: event.data[0],
        address: event.data[0],
        deployer: event.data[1],
        unique: event.data[2],
        classHash: event.data[3],
        calldata_len: event.data[4],
        calldata: event.data.slice(5, 5 + parseInt(event.data[4], 16)),
        salt: event.data[event.data.length - 1],
    };
}

},{"../../constants":102,"../assert":141,"../calldata/cairo":146,"../calldata/responseParser":158,"../ec":162,"../encode":163,"../num":175}],166:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// the ts-ignore suppresses an esm to cjs import error that is resolved with entry point resolution
// @ts-ignore
var fetch_cookie_1 = require("fetch-cookie");
var isomorphic_fetch_1 = require("isomorphic-fetch");
exports.default = typeof window !== 'undefined' && window.fetch ||
// use buildin fetch in browser if available
typeof global !== 'undefined' && (0, fetch_cookie_1.default)(global.fetch) ||
// use buildin fetch in node, react-native and service worker if available
isomorphic_fetch_1.default; // ponyfill fetch in node and browsers that don't have it

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"fetch-cookie":58,"isomorphic-fetch":59}],167:[function(require,module,exports){
"use strict";
/**
 * Class Hash
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computePedersenHashOnElements = void 0;
exports.computePedersenHash = computePedersenHash;
exports.computePoseidonHash = computePoseidonHash;
exports.computeHashOnElements = computeHashOnElements;
exports.computePoseidonHashOnElements = computePoseidonHashOnElements;
exports.calculateContractAddressFromHash = calculateContractAddressFromHash;
exports.formatSpaces = formatSpaces;
exports.computeHintedClassHash = computeHintedClassHash;
exports.computeLegacyContractClassHash = computeLegacyContractClassHash;
exports.hashByteCodeSegments = hashByteCodeSegments;
exports.computeCompiledClassHash = computeCompiledClassHash;
exports.computeSierraContractClassHash = computeSierraContractClassHash;
exports.computeContractClassHash = computeContractClassHash;
var starknet_1 = require("@scure/starknet");
var constants_1 = require("../../constants");
var calldata_1 = require("../calldata");
var cairo_1 = require("../calldata/cairo");
var ec_1 = require("../ec");
var encode_1 = require("../encode");
var json_1 = require("../json");
var num_1 = require("../num");
var shortString_1 = require("../shortString");
function computePedersenHash(a, b) {
    return ec_1.starkCurve.pedersen(BigInt(a), BigInt(b));
}
function computePoseidonHash(a, b) {
    return (0, num_1.toHex)(ec_1.starkCurve.poseidonHash(BigInt(a), BigInt(b)));
}
/**
 * Compute Pedersen hash from data
 *
 * @param {BigNumberish[]} data Array of data to compute Pedersen hash on
 * @returns {string} hex-string of Pedersen hash
 *
 * @example
 * ```typescript
 * const result = hash.computeHashOnElements(['0xabc', '0x123', '0xabc123'])
 * // result = 0x148141e8f7db29d005a0187669a56f0790d7e8c2c5b2d780e4d8b9e436a5521
 * ```
 */
function computeHashOnElements(data) {
    return __spreadArray(__spreadArray([], data, true), [data.length], false).reduce(function (x, y) { return ec_1.starkCurve.pedersen(BigInt(x), BigInt(y)); }, 0)
        .toString();
}
exports.computePedersenHashOnElements = computeHashOnElements;
function computePoseidonHashOnElements(data) {
    return (0, num_1.toHex)((0, starknet_1.poseidonHashMany)(data.map(function (x) { return BigInt(x); })));
}
/**
 * Calculate contract address from class hash
 *
 * @param {BigNumberish} salt Salt to be used for hashing
 * @param {BigNumberish} classHash Class hash of contract to generate address for
 * @param {RawArgs} constructorCalldata Call data for contract constructor
 * @param {BigNumberish} deployerAddress Address of contract deployer
 * @returns {string} hex-string
 * @example
 * ```typescript
 * const result = hash.calculateContractAddressFromHash(1234, 0x1cf4fe5d37868d25524cdacb89518d88bf217a9240a1e6fde71cc22c429e0e3, [1234, true, false], 0x052fb1a9ab0db3c4f81d70fea6a2f6e55f57c709a46089b25eeec0e959db3695);
 * // result = 0x5fb03d3a88d8e474976932f927ff6a9e332e06ed36642ea3e8c7e38bf010f76
 * ```
 */
function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
    var compiledCalldata = calldata_1.CallData.compile(constructorCalldata);
    var constructorCalldataHash = computeHashOnElements(compiledCalldata);
    var CONTRACT_ADDRESS_PREFIX = (0, cairo_1.felt)('0x535441524b4e45545f434f4e54524143545f41444452455353'); // Equivalent to 'STARKNET_CONTRACT_ADDRESS'
    var hash = computeHashOnElements([
        CONTRACT_ADDRESS_PREFIX,
        deployerAddress,
        salt,
        classHash,
        constructorCalldataHash,
    ]);
    return (0, num_1.toHex)(BigInt(hash) % constants_1.ADDR_BOUND);
}
function nullSkipReplacer(key, value) {
    if (key === 'attributes' || key === 'accessible_scopes') {
        return Array.isArray(value) && value.length === 0 ? undefined : value;
    }
    if (key === 'debug_info') {
        return null;
    }
    return value === null ? undefined : value;
}
/**
 * Format json-string without spaces to conform starknet json-string
 * @param {string} json json-string without spaces
 * @returns {string} json-string with additional spaces after `:` and `,`
 * @example
 * ```typescript
 * const result = hash.formatSpaces("{'onchain':true,'isStarknet':true}");
 * // result = "{'onchain': true, 'isStarknet': true}"
 * ```
 */
function formatSpaces(json) {
    var insideQuotes = false;
    var newString = [];
    // eslint-disable-next-line no-restricted-syntax
    for (var _i = 0, json_2 = json; _i < json_2.length; _i++) {
        var char = json_2[_i];
        if (char === '"' && (newString.length > 0 && newString.slice(-1)[0] === '\\') === false) {
            insideQuotes = !insideQuotes;
        }
        if (insideQuotes) {
            newString.push(char);
        }
        else {
            // eslint-disable-next-line no-nested-ternary
            newString.push(char === ':' ? ': ' : char === ',' ? ', ' : char);
        }
    }
    return newString.join('');
}
/**
 * Compute hinted class hash for legacy compiled contract (Cairo 0)
 * @param {LegacyCompiledContract} compiledContract
 * @returns {string} hex-string
 * @example
 * ```typescript
 * const compiledCairo0 = json.parse(fs.readFileSync("./cairo0contract.json").toString("ascii"));
 * const result=hash.computeHintedClassHash(compiledCairo0);
 * // result = "0x293eabb06955c0a1e55557014675aa4e7a1fd69896147382b29b2b6b166a2ac"
 * ``` */
function computeHintedClassHash(compiledContract) {
    var abi = compiledContract.abi, program = compiledContract.program;
    var contractClass = { abi: abi, program: program };
    var serializedJson = formatSpaces((0, json_1.stringify)(contractClass, nullSkipReplacer));
    return (0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(serializedJson)).toString(16));
}
/**
 * Computes the class hash for legacy compiled contract (Cairo 0)
 * @param {LegacyCompiledContract | string} contract legacy compiled contract content
 * @returns {string} hex-string of class hash
 * @example
 * ```typescript
 * const compiledCairo0 = json.parse(fs.readFileSync("./cairo0contract.json").toString("ascii"));
 * const result=hash.computeLegacyContractClassHash(compiledCairo0);
 * // result = "0x4a5cae61fa8312b0a3d0c44658b403d3e4197be80027fd5020ffcdf0c803331"
 * ```
 */
function computeLegacyContractClassHash(contract) {
    var compiledContract = (0, shortString_1.isString)(contract)
        ? (0, json_1.parse)(contract)
        : contract;
    var apiVersion = (0, num_1.toHex)(constants_1.API_VERSION);
    var externalEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.EXTERNAL.flatMap(function (e) { return [e.selector, e.offset]; }));
    var l1HandlerEntryPointsHash = computeHashOnElements(compiledContract.entry_points_by_type.L1_HANDLER.flatMap(function (e) { return [e.selector, e.offset]; }));
    var constructorEntryPointHash = computeHashOnElements(compiledContract.entry_points_by_type.CONSTRUCTOR.flatMap(function (e) { return [e.selector, e.offset]; }));
    var builtinsHash = computeHashOnElements(compiledContract.program.builtins.map(function (s) { return (0, shortString_1.encodeShortString)(s); }));
    var hintedClassHash = computeHintedClassHash(compiledContract);
    var dataHash = computeHashOnElements(compiledContract.program.data);
    return computeHashOnElements([
        apiVersion,
        externalEntryPointsHash,
        l1HandlerEntryPointsHash,
        constructorEntryPointHash,
        builtinsHash,
        hintedClassHash,
        dataHash,
    ]);
}
// Cairo 1 Contract Hashes
function hashBuiltins(builtins) {
    return (0, starknet_1.poseidonHashMany)(builtins.flatMap(function (it) {
        return BigInt((0, shortString_1.encodeShortString)(it));
    }));
}
function hashEntryPoint(data) {
    var base = data.flatMap(function (it) {
        return [BigInt(it.selector), BigInt(it.offset), hashBuiltins(it.builtins)];
    });
    return (0, starknet_1.poseidonHashMany)(base);
}
/**
 * Compute hash of the bytecode for Sierra v1.5.0 onwards (Cairo 2.6.0)
 * Each segment is Poseidon hashed.
 * The global hash is : 1 + PoseidonHash(len0, h0, len1, h1, ...)
 * @param {CompiledSierraCasm} casm compiled Sierra CASM file content.
 * @returns {bigint} the bytecode hash as bigint.
 * @example
 * ```typescript
 * const compiledCasm = json.parse(fs.readFileSync("./contractC260.casm.json").toString("ascii"));
 * const result = hash.hashByteCodeSegments(compiledCasm);
 * // result = 80499149343908132326491548897246987792410240503053732367044713070598981699n
 * ```
 */
function hashByteCodeSegments(casm) {
    var _a;
    var byteCode = casm.bytecode.map(function (n) { return BigInt(n); });
    var bytecodeSegmentLengths = (_a = casm.bytecode_segment_lengths) !== null && _a !== void 0 ? _a : [];
    var segmentStart = 0;
    var hashLeaves = bytecodeSegmentLengths.flatMap(function (len) {
        var segment = byteCode.slice(segmentStart, (segmentStart += len));
        return [BigInt(len), (0, starknet_1.poseidonHashMany)(segment)];
    });
    return 1n + (0, starknet_1.poseidonHashMany)(hashLeaves);
}
/**
 * Compute compiled class hash for contract (Cairo 1)
 * @param {CompiledSierraCasm} casm Cairo 1 compiled contract content
 * @returns {string} hex-string of class hash
 * @example
 * ```typescript
 * const compiledCasm = json.parse(fs.readFileSync("./cairo260.casm.json").toString("ascii"));
 * const result = hash.computeCompiledClassHash(compiledCasm);
 * // result = "0x4087905743b4fa2b3affc1fc71333f1390c8c5d1e8ea47d6ba70786de3fc01a"
```
 */
function computeCompiledClassHash(casm) {
    var COMPILED_CLASS_VERSION = 'COMPILED_CLASS_V1';
    // Hash compiled class version
    var compiledClassVersion = BigInt((0, shortString_1.encodeShortString)(COMPILED_CLASS_VERSION));
    // Hash external entry points.
    var externalEntryPointsHash = hashEntryPoint(casm.entry_points_by_type.EXTERNAL);
    // Hash L1 handler entry points.
    var l1Handlers = hashEntryPoint(casm.entry_points_by_type.L1_HANDLER);
    // Hash constructor entry points.
    var constructor = hashEntryPoint(casm.entry_points_by_type.CONSTRUCTOR);
    // Hash bytecode.
    var bytecode = casm.bytecode_segment_lengths
        ? hashByteCodeSegments(casm)
        : (0, starknet_1.poseidonHashMany)(casm.bytecode.map(function (it) { return BigInt(it); }));
    return (0, num_1.toHex)((0, starknet_1.poseidonHashMany)([
        compiledClassVersion,
        externalEntryPointsHash,
        l1Handlers,
        constructor,
        bytecode,
    ]));
}
function hashEntryPointSierra(data) {
    var base = data.flatMap(function (it) {
        return [BigInt(it.selector), BigInt(it.function_idx)];
    });
    return (0, starknet_1.poseidonHashMany)(base);
}
function hashAbi(sierra) {
    var indentString = formatSpaces((0, json_1.stringify)(sierra.abi, null));
    return BigInt((0, encode_1.addHexPrefix)(ec_1.starkCurve.keccak((0, encode_1.utf8ToArray)(indentString)).toString(16)));
}
/**
 * Compute sierra contract class hash (Cairo 1)
 * @param {CompiledSierra} sierra Cairo 1 Sierra contract content
 * @returns {string} hex-string of class hash
 * @example
 * ```typescript
 * const compiledSierra = json.parse(fs.readFileSync("./cairo260.sierra.json").toString("ascii"));
 * const result = hash.computeSierraContractClassHash(compiledSierra);
 * // result = "0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba"
```
 */
function computeSierraContractClassHash(sierra) {
    var CONTRACT_CLASS_VERSION = 'CONTRACT_CLASS_V0.1.0';
    // Hash class version
    var compiledClassVersion = BigInt((0, shortString_1.encodeShortString)(CONTRACT_CLASS_VERSION));
    // Hash external entry points.
    var externalEntryPointsHash = hashEntryPointSierra(sierra.entry_points_by_type.EXTERNAL);
    // Hash L1 handler entry points.
    var l1Handlers = hashEntryPointSierra(sierra.entry_points_by_type.L1_HANDLER);
    // Hash constructor entry points.
    var constructor = hashEntryPointSierra(sierra.entry_points_by_type.CONSTRUCTOR);
    // Hash abi_hash.
    var abiHash = hashAbi(sierra);
    // Hash Sierra program.
    var sierraProgram = (0, starknet_1.poseidonHashMany)(sierra.sierra_program.map(function (it) { return BigInt(it); }));
    return (0, num_1.toHex)((0, starknet_1.poseidonHashMany)([
        compiledClassVersion,
        externalEntryPointsHash,
        l1Handlers,
        constructor,
        abiHash,
        sierraProgram,
    ]));
}
/**
 * Compute ClassHash (sierra or legacy) based on provided contract
 * @param {CompiledContract | string} contract Cairo 1 contract content
 * @returns {string} hex-string of class hash
 * @example
 * ```typescript
 * const compiledSierra = json.parse(fs.readFileSync("./cairo260.sierra.json").toString("ascii"));
 * const result = hash.computeContractClassHash(compiledSierra);
 * // result = "0x67b6b4f02baded46f02feeed58c4f78e26c55364e59874d8abfd3532d85f1ba"
```
 */
function computeContractClassHash(contract) {
    var compiledContract = (0, shortString_1.isString)(contract) ? (0, json_1.parse)(contract) : contract;
    if ('sierra_program' in compiledContract) {
        return computeSierraContractClassHash(compiledContract);
    }
    return computeLegacyContractClassHash(compiledContract);
}

},{"../../constants":102,"../calldata":152,"../calldata/cairo":146,"../ec":162,"../encode":163,"../json":173,"../num":175,"../shortString":180,"@scure/starknet":43}],168:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.poseidon = void 0;
/**
 * Hashes Exports
 */
exports.poseidon = require("@noble/curves/abstract/poseidon");
__exportStar(require("./selector"), exports); // Preserve legacy export structure
__exportStar(require("./transactionHash"), exports);
__exportStar(require("./classHash"), exports);

},{"./classHash":167,"./selector":169,"./transactionHash":170,"@noble/curves/abstract/poseidon":30}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccakBn = keccakBn;
exports.starknetKeccak = starknetKeccak;
exports.getSelectorFromName = getSelectorFromName;
exports.getSelector = getSelector;
var starknet_1 = require("@scure/starknet");
var constants_1 = require("../../constants");
var encode_1 = require("../encode");
var num_1 = require("../num");
/**
 * Calculate the hex-string Keccak hash for a given BigNumberish
 *
 * @param value value to hash
 * @returns hex-string Keccak hash
 * @example
 * ```typescript
 * const result = keccakBn('0xabc');
 * // result = '0x11cf08aac85935e32397f410e48217a127b6855d41b1e3877eb4179c0904b77'
 * ```
 */
function keccakBn(value) {
    var hexWithoutPrefix = (0, encode_1.removeHexPrefix)((0, num_1.toHex)(BigInt(value)));
    var evenHex = hexWithoutPrefix.length % 2 === 0 ? hexWithoutPrefix : "0".concat(hexWithoutPrefix);
    return (0, encode_1.addHexPrefix)((0, starknet_1.keccak)((0, num_1.hexToBytes)((0, encode_1.addHexPrefix)(evenHex))).toString(16));
}
/**
 * [internal]
 * Calculate hex-string Keccak hash for a given string
 *
 * String -> hex-string Keccak hash
 * @returns format: hex-string
 */
function keccakHex(str) {
    return (0, encode_1.addHexPrefix)((0, starknet_1.keccak)((0, encode_1.utf8ToArray)(str)).toString(16));
}
/**
 * Calculate the BigInt Starknet Keccak hash for a given string
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L38)
 *
 * @param str value to hash
 * @returns BigInt Keccak hash
 * @example
 * ```typescript
 * const result = starknetKeccak('test').toString();
 * // result = '61835310290161785288773114225739080147441215596947647498723774891619563096'
 * ```
 */
function starknetKeccak(str) {
    var hash = BigInt(keccakHex(str));
    // eslint-disable-next-line no-bitwise
    return hash & constants_1.MASK_250;
}
/**
 * Calculate the hex-string selector for a given abi function name
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/public/abi.py#L46)
 *
 * @param funcName abi function name
 * @returns hex-string selector
 * @example
 * ```typescript
 * const result = getSelectorFromName('myFunction');
 * // result = '0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8'
 * ```
 */
function getSelectorFromName(funcName) {
    // sometimes BigInteger pads the hex string with zeros, which is not allowed in the starknet api
    return (0, num_1.toHex)(starknetKeccak(funcName));
}
/**
 * Calculate the hex-string selector from a given abi function name, decimal string or hex string
 *
 * @param value hex-string | dec-string | ascii-string
 * @returns hex-string selector
 * @example
 * ```typescript
 * const selector1: string = getSelector("myFunction");
 * // selector1 = "0xc14cfe23f3fa7ce7b1f8db7d7682305b1692293f71a61cc06637f0d8d8b6c8"
 *
 * const selector2: string = getSelector("0x123abc");
 * // selector2 = "0x123abc"
 *
 * const selector3: string = getSelector("123456");
 * // selector3 = "0x1e240"
 * ```
 */
function getSelector(value) {
    if ((0, num_1.isHex)(value)) {
        return value;
    }
    if ((0, num_1.isStringWholeNumber)(value)) {
        return (0, num_1.toHexString)(value);
    }
    return getSelectorFromName(value);
}

},{"../../constants":102,"../encode":163,"../num":175,"@scure/starknet":43}],170:[function(require,module,exports){
"use strict";
/**
 * Transaction Hash based on Transaction Version
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateInvokeTransactionHash = calculateInvokeTransactionHash;
exports.calculateDeclareTransactionHash = calculateDeclareTransactionHash;
exports.calculateDeployAccountTransactionHash = calculateDeployAccountTransactionHash;
var api_1 = require("../../../types/api");
var v2_1 = require("./v2");
var v3_1 = require("./v3");
function isV3InvokeTx(args) {
    return [api_1.ETransactionVersion.V3, api_1.ETransactionVersion.F3].includes(args.version);
}
function calculateInvokeTransactionHash(args) {
    if (isV3InvokeTx(args)) {
        return (0, v3_1.calculateInvokeTransactionHash)(args.senderAddress, args.version, args.compiledCalldata, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
    }
    return (0, v2_1.calculateTransactionHash)(args.senderAddress, args.version, args.compiledCalldata, args.maxFee, args.chainId, args.nonce);
}
/*
 * DECLARE TX HASH
 */
function isV3DeclareTx(args) {
    return [api_1.ETransactionVersion.V3, api_1.ETransactionVersion.F3].includes(args.version);
}
function calculateDeclareTransactionHash(args) {
    if (isV3DeclareTx(args)) {
        return (0, v3_1.calculateDeclareTransactionHash)(args.classHash, args.compiledClassHash, args.senderAddress, args.version, args.chainId, args.nonce, args.accountDeploymentData, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
    }
    return (0, v2_1.calculateDeclareTransactionHash)(args.classHash, args.senderAddress, args.version, args.maxFee, args.chainId, args.nonce, args.compiledClassHash);
}
/*
 * DEPLOY ACCOUNT TX HASH
 */
function isV3DeployAccountTx(args) {
    return [api_1.ETransactionVersion.V3, api_1.ETransactionVersion.F3].includes(args.version);
}
function calculateDeployAccountTransactionHash(args) {
    if (isV3DeployAccountTx(args)) {
        return (0, v3_1.calculateDeployAccountTransactionHash)(args.contractAddress, args.classHash, args.compiledConstructorCalldata, args.salt, args.version, args.chainId, args.nonce, args.nonceDataAvailabilityMode, args.feeDataAvailabilityMode, args.resourceBounds, args.tip, args.paymasterData);
    }
    return (0, v2_1.calculateDeployAccountTransactionHash)(args.contractAddress, args.classHash, args.constructorCalldata, args.salt, args.version, args.maxFee, args.chainId, args.nonce);
}

},{"../../../types/api":119,"./v2":171,"./v3":172}],171:[function(require,module,exports){
"use strict";

/**
 * Calculate Hashes for v0 - v2 transactions
 */
var __spreadArray = void 0 && (void 0).__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeHashOnElements = computeHashOnElements;
exports.calculateTransactionHashCommon = calculateTransactionHashCommon;
exports.calculateDeclareTransactionHash = calculateDeclareTransactionHash;
exports.calculateDeployAccountTransactionHash = calculateDeployAccountTransactionHash;
exports.calculateTransactionHash = calculateTransactionHash;
/* eslint-disable no-param-reassign */
/* eslint-disable import/extensions */
var constants_1 = require("../../../constants");
var ec_1 = require("../../ec");
var num_1 = require("../../num");
/**
 * Compute pedersen hash from data
 * @returns format: hex-string - pedersen hash
 */
function computeHashOnElements(data) {
  return __spreadArray(__spreadArray([], data, true), [data.length], false).reduce(function (x, y) {
    return ec_1.starkCurve.pedersen((0, num_1.toBigInt)(x), (0, num_1.toBigInt)(y));
  }, 0).toString();
}
/**
 * Calculate transaction pedersen hash for common properties
 *
 * Following implementation is based on this python [implementation #](https://github.com/starkware-libs/cairo-lang/blob/b614d1867c64f3fb2cf4a4879348cfcf87c3a5a7/src/starkware/starknet/core/os/transaction_hash/transaction_hash.py)
 * @returns format: hex-string
 */
function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData) {
  if (additionalData === void 0) {
    additionalData = [];
  }
  var calldataHash = computeHashOnElements(calldata);
  var dataToHash = __spreadArray([txHashPrefix, version, contractAddress, entryPointSelector, calldataHash, maxFee, chainId], additionalData, true);
  return computeHashOnElements(dataToHash);
}
/**
 * Calculate declare transaction hash
 * @param classHash hex-string
 * @param compiledClassHash hex-string
 * @returns format: hex-string
 */
function calculateDeclareTransactionHash(classHash, senderAddress, version, maxFee, chainId, nonce, compiledClassHash) {
  return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DECLARE, version, senderAddress, 0, [classHash], maxFee, chainId, __spreadArray([nonce], compiledClassHash ? [compiledClassHash] : [], true));
}
/**
 * Calculate deploy_account transaction hash
 * @returns format: hex-string
 */
function calculateDeployAccountTransactionHash(contractAddress, classHash, constructorCalldata, salt, version, maxFee, chainId, nonce) {
  var calldata = __spreadArray([classHash, salt], constructorCalldata, true);
  return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DEPLOY_ACCOUNT, version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
}
/**
 * Calculate invoke transaction hash
 * @returns format: hex-string
 */
function calculateTransactionHash(contractAddress, version, calldata, maxFee, chainId, nonce) {
  return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.INVOKE, version, contractAddress, 0, calldata, maxFee, chainId, [nonce]);
}

},{"../../../constants":102,"../../ec":162,"../../num":175}],172:[function(require,module,exports){
"use strict";
/**
 * Calculate Hashes for v3 transactions
 */
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashDAMode = hashDAMode;
exports.hashFeeField = hashFeeField;
exports.calculateTransactionHashCommon = calculateTransactionHashCommon;
exports.calculateDeployAccountTransactionHash = calculateDeployAccountTransactionHash;
exports.calculateDeclareTransactionHash = calculateDeclareTransactionHash;
exports.calculateInvokeTransactionHash = calculateInvokeTransactionHash;
var starknet_1 = require("@scure/starknet");
var constants_1 = require("../../../constants");
var num_1 = require("../../num");
var shortString_1 = require("../../shortString");
var AToBI = function (array) { return array.map(function (it) { return BigInt(it); }); };
/* eslint-disable no-bitwise */
var DATA_AVAILABILITY_MODE_BITS = 32n;
var MAX_AMOUNT_BITS = 64n;
var MAX_PRICE_PER_UNIT_BITS = 128n;
var RESOURCE_VALUE_OFFSET = MAX_AMOUNT_BITS + MAX_PRICE_PER_UNIT_BITS;
var L1_GAS_NAME = BigInt((0, shortString_1.encodeShortString)('L1_GAS'));
var L2_GAS_NAME = BigInt((0, shortString_1.encodeShortString)('L2_GAS'));
function hashDAMode(nonceDAMode, feeDAMode) {
    return (BigInt(nonceDAMode) << DATA_AVAILABILITY_MODE_BITS) + BigInt(feeDAMode);
}
function hashFeeField(tip, bounds) {
    var L1Bound = (L1_GAS_NAME << RESOURCE_VALUE_OFFSET) +
        (BigInt(bounds.l1_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +
        BigInt(bounds.l1_gas.max_price_per_unit);
    var L2Bound = (L2_GAS_NAME << RESOURCE_VALUE_OFFSET) +
        (BigInt(bounds.l2_gas.max_amount) << MAX_PRICE_PER_UNIT_BITS) +
        BigInt(bounds.l2_gas.max_price_per_unit);
    return (0, starknet_1.poseidonHashMany)([BigInt(tip), L1Bound, L2Bound]);
}
function calculateTransactionHashCommon(txHashPrefix, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, additionalData) {
    if (additionalData === void 0) { additionalData = []; }
    var feeFieldHash = hashFeeField(tip, resourceBounds);
    var dAModeHash = hashDAMode(nonceDataAvailabilityMode, feeDataAvailabilityMode);
    var dataToHash = AToBI(__spreadArray([
        txHashPrefix,
        version,
        senderAddress,
        feeFieldHash,
        (0, starknet_1.poseidonHashMany)(AToBI(paymasterData)),
        chainId,
        nonce,
        dAModeHash
    ], AToBI(additionalData), true));
    return (0, num_1.toHex)((0, starknet_1.poseidonHashMany)(dataToHash));
}
/**
 * Calculate v3 deploy_account transaction hash
 * @returns format: hex-string
 */
function calculateDeployAccountTransactionHash(contractAddress, classHash, compiledConstructorCalldata, salt, version, chainId, nonce, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DEPLOY_ACCOUNT, version, contractAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, starknet_1.poseidonHashMany)(AToBI(compiledConstructorCalldata)), classHash, salt]);
}
/**
 * Calculate v3 declare transaction hash
 * @returns format: hex-string
 */
function calculateDeclareTransactionHash(classHash, compiledClassHash, senderAddress, version, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DECLARE, version, senderAddress, chainId, nonce, tip, AToBI(paymasterData), nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, starknet_1.poseidonHashMany)(AToBI(accountDeploymentData)), classHash, compiledClassHash]);
}
/**
 * Calculate v3 invoke transaction hash
 * @returns format: hex-string
 */
function calculateInvokeTransactionHash(senderAddress, version, compiledCalldata, chainId, nonce, accountDeploymentData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, tip, paymasterData) {
    return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.INVOKE, version, senderAddress, chainId, nonce, tip, paymasterData, nonceDataAvailabilityMode, feeDataAvailabilityMode, resourceBounds, [(0, starknet_1.poseidonHashMany)(AToBI(accountDeploymentData)), (0, starknet_1.poseidonHashMany)(AToBI(compiledCalldata))]);
}

},{"../../../constants":102,"../../num":175,"../../shortString":180,"@scure/starknet":43}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyAlwaysAsBig = exports.stringify = exports.parseAlwaysAsBig = exports.parse = void 0;
var json = require("lossless-json");
/**
 * Helper to convert string to number or bigint based on size
 */
var parseIntAsNumberOrBigInt = function (str) {
    if (!json.isInteger(str))
        return parseFloat(str);
    var num = parseInt(str, 10);
    return Number.isSafeInteger(num) ? num : BigInt(str);
};
/**
 * Convert JSON string to JSON object
 *
 * NOTE: the String() wrapping is used so the behavior conforms to JSON.parse()
 * which can accept simple data types but is not represented in the default typing
 *
 * @param str JSON string
 * @return {object} Parsed json object
 * @example
 * ```typescript
 * const str = '[123, 12.3, 11223344556677889900]';
 * const result = parse(str);
 * // result = [123, 12.3, 11223344556677890048n]
 * ```
 */
var parse = function (str) {
    return json.parse(String(str), undefined, parseIntAsNumberOrBigInt);
};
exports.parse = parse;
/**
 * Convert JSON string to JSON object with all numbers as bigint
 * @param str JSON string
 * @return {object} Parsed json object
 * @example
 * ```typescript
 * const str = '[123, 12.3, 1234567890]';
 * const result = parseAlwaysAsBig(str);
 * // result = [123n, 12.3, 1234567890n]
 * ```
 */
var parseAlwaysAsBig = function (str) {
    return json.parse(String(str), undefined, json.parseNumberAndBigInt);
};
exports.parseAlwaysAsBig = parseAlwaysAsBig;
/**
 * Convert JSON object to JSON string
 *
 * NOTE: the not-null assertion is used so the return type conforms to JSON.stringify()
 * which can also return undefined but is not represented in the default typing
 *
 * @param value JSON object
 * @param [replacer] Function that alters the behavior of the stringification process
 * @param [space] Used to insert white space into the output JSON string
 * @param [numberStringifiers] Function used to stringify numbers (returning undefined will delete the property from the object)
 * @return {string} JSON string
 * @example
 * ```typescript
 * const value = [123, 12.3, 1234567890];
 * const result = stringify(value);
 * // result = '[123,12.3,1234567890]'
 * ```
 */
var stringify = function (value, replacer, space, numberStringifiers) { return json.stringify(value, replacer, space, numberStringifiers); };
exports.stringify = stringify;
/** @deprecated equivalent to 'stringify', alias will be removed */
exports.stringifyAlwaysAsBig = exports.stringify;

},{"lossless-json":60}],174:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTree = void 0;
exports.proofMerklePath = proofMerklePath;
var hash_1 = require("./hash");
var MerkleTree = /** @class */ (function () {
    /**
     * Create a Merkle tree
     *
     * @param leafHashes hex-string array
     * @param hashMethod hash method to use, default: Pedersen
     * @returns created Merkle tree
     * @example
     * ```typescript
     * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];
     * const tree = new MerkleTree(leaves);
     * // tree = {
     * //   branches: [['0x5bb9440e2...', '0x262697b88...', ...], ['0x38118a340...', ...], ...],
     * //   leaves: ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'],
     * //   root: '0x7f748c75e5bdb7ae28013f076b8ab650c4e01d3530c6e5ab665f9f1accbe7d4',
     * //   hashMethod: [Function computePedersenHash],
     * // }
     * ```
     */
    function MerkleTree(leafHashes, hashMethod) {
        if (hashMethod === void 0) { hashMethod = hash_1.computePedersenHash; }
        this.branches = [];
        this.hashMethod = hashMethod;
        this.leaves = leafHashes;
        this.root = this.build(leafHashes);
    }
    /** @ignore */
    MerkleTree.prototype.build = function (leaves) {
        if (leaves.length === 1) {
            return leaves[0];
        }
        if (leaves.length !== this.leaves.length) {
            this.branches.push(leaves);
        }
        var newLeaves = [];
        for (var i = 0; i < leaves.length; i += 2) {
            if (i + 1 === leaves.length) {
                newLeaves.push(MerkleTree.hash(leaves[i], '0x0', this.hashMethod));
            }
            else {
                newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));
            }
        }
        return this.build(newLeaves);
    };
    /**
     * Calculate hash from ordered a and b, Pedersen hash default
     *
     * @param a first value
     * @param b second value
     * @param hashMethod hash method to use, default: Pedersen
     * @returns result of the hash function
     * @example
     * ```typescript
     * const result1 = MerkleTree.hash('0xabc', '0xdef');
     * // result1 = '0x484f029da7914ada038b1adf67fc83632364a3ebc2cd9349b41ab61626d9e82'
     *
     * const customHashMethod = (a, b) => `custom_${a}_${b}`;
     * const result2 = MerkleTree.hash('0xabc', '0xdef', customHashMethod);
     * // result2 = 'custom_2748_3567'
     * ```
     */
    MerkleTree.hash = function (a, b, hashMethod) {
        if (hashMethod === void 0) { hashMethod = hash_1.computePedersenHash; }
        var _a = [BigInt(a), BigInt(b)].sort(function (x, y) { return (x >= y ? 1 : -1); }), aSorted = _a[0], bSorted = _a[1];
        return hashMethod(aSorted, bSorted);
    };
    /**
     * Calculates the merkle membership proof path
     *
     * @param leaf hex-string
     * @param branch hex-string array
     * @param hashPath hex-string array
     * @returns collection of merkle proof hex-string hashes
     * @example
     * ```typescript
     * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];
     * const tree = new MerkleTree(leaves);
     * const result = tree.getProof('0x3');
     * // result = [
     * //   '0x4',
     * //   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',
     * //   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',
     * // ]
     * ```
     */
    MerkleTree.prototype.getProof = function (leaf, branch, hashPath) {
        var _a, _b;
        if (branch === void 0) { branch = this.leaves; }
        if (hashPath === void 0) { hashPath = []; }
        var index = branch.indexOf(leaf);
        if (index === -1) {
            throw new Error('leaf not found');
        }
        if (branch.length === 1) {
            return hashPath;
        }
        var isLeft = index % 2 === 0;
        var neededBranch = (_a = (isLeft ? branch[index + 1] : branch[index - 1])) !== null && _a !== void 0 ? _a : '0x0';
        var newHashPath = __spreadArray(__spreadArray([], hashPath, true), [neededBranch], false);
        var currentBranchLevelIndex = this.leaves.length === branch.length
            ? -1
            : this.branches.findIndex(function (b) { return b.length === branch.length; });
        var nextBranch = (_b = this.branches[currentBranchLevelIndex + 1]) !== null && _b !== void 0 ? _b : [this.root];
        return this.getProof(MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod), nextBranch, newHashPath);
    };
    return MerkleTree;
}());
exports.MerkleTree = MerkleTree;
/**
 * Tests a Merkle tree path
 *
 * @param root hex-string
 * @param leaf hex-string
 * @param path hex-string array
 * @param hashMethod hash method to use, default: Pedersen
 * @returns true if the path is valid, false otherwise
 * @example
 * ```typescript
 * const leaves = ['0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7'];
 * const tree = new MerkleTree(leaves);
 * const result = proofMerklePath(tree.root, '0x3', [
 *   '0x4',
 *   '0x5bb9440e27889a364bcb678b1f679ecd1347acdedcbf36e83494f857cc58026',
 *   '0x8c0e46dd2df9aaf3a8ebfbc25408a582ad7fa7171f0698ddbbc5130b4b4e60',
 * ]);
 * // result = true
 * ```
 */
function proofMerklePath(root, leaf, path, hashMethod) {
    if (hashMethod === void 0) { hashMethod = hash_1.computePedersenHash; }
    if (path.length === 0) {
        return root === leaf;
    }
    var next = path[0], rest = path.slice(1);
    return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);
}

},{"./hash":168}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHexString = void 0;
exports.isHex = isHex;
exports.toBigInt = toBigInt;
exports.isBigInt = isBigInt;
exports.toHex = toHex;
exports.toStorageKey = toStorageKey;
exports.hexToDecimalString = hexToDecimalString;
exports.cleanHex = cleanHex;
exports.assertInRange = assertInRange;
exports.bigNumberishArrayToDecimalStringArray = bigNumberishArrayToDecimalStringArray;
exports.bigNumberishArrayToHexadecimalStringArray = bigNumberishArrayToHexadecimalStringArray;
exports.isStringWholeNumber = isStringWholeNumber;
exports.getDecimalString = getDecimalString;
exports.getHexString = getHexString;
exports.getHexStringArray = getHexStringArray;
exports.toCairoBool = toCairoBool;
exports.hexToBytes = hexToBytes;
exports.addPercent = addPercent;
exports.isNumber = isNumber;
exports.isBoolean = isBoolean;
var utils_1 = require("@noble/curves/abstract/utils");
var assert_1 = require("./assert");
var encode_1 = require("./encode");
/**
 * Test if string is hex-string
 *
 * @param hex hex-string
 * @returns {boolean} true if the input string is a hexadecimal string, false otherwise
 * @example
 * ```typescript
 * const hexString1 = "0x2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914";
 * const result1 = isHex(hexString1);
 * // result1 = true
 *
 * const hexString2 = "2fd23d9182193775423497fc0c472e156c57c69e4089a1967fb288a2d84e914";
 * const result2 = isHex(hexString2);
 * // result2 = false
 * ```
 */
function isHex(hex) {
    return /^0x[0-9a-f]*$/i.test(hex);
}
/**
 * Convert BigNumberish to bigint
 *
 * @param {BigNumberish} value value to convert
 * @returns {BigInt} converted value
 * @example
 * ```typescript
 * const str = '123';
 * const result = toBigInt(str);
 * // result = 123n
 * ```
 */
function toBigInt(value) {
    return BigInt(value);
}
/**
 * Test if value is bigint
 *
 * @param value value to test
 * @returns {boolean} true if value is bigint, false otherwise
 * @example
 * ```typescript
 * isBigInt(10n); // true
 * isBigInt(BigInt('10')); // true
 * isBigInt(10); // false
 * isBigInt('10'); // false
 * isBigInt(null); // false
 * ```
 */
function isBigInt(value) {
    return typeof value === 'bigint';
}
/**
 * Convert BigNumberish to hex-string
 *
 * @param {BigNumberish} value value to convert
 * @returns {string} converted number in hex-string format
 * @example
 * ```typescript
 * toHex(100); // '0x64'
 * toHex('200'); // '0xc8'
 * ```
 */
function toHex(value) {
    return (0, encode_1.addHexPrefix)(toBigInt(value).toString(16));
}
/**
 * Alias of ToHex
 */
exports.toHexString = toHex;
/**
 * Convert BigNumberish to storage-key-string
 *
 * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.
 *
 * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:
 * `0x0 + [0-7] + 62 hex = 0x + 64 hex`
 * @returns format: storage-key-string
 */
function toStorageKey(number) {
    return (0, encode_1.addHexPrefix)(toBigInt(number).toString(16).padStart(64, '0'));
}
/**
 * Convert hexadecimal string to decimal string
 *
 * @param {string} hex hex-string to convert
 * @returns {string} converted number in decimal string format
 * @example
 * ```typescript
 * hexToDecimalString('64'); // '100'
 * hexToDecimalString('c8'); // '200'
 * ```
 */
function hexToDecimalString(hex) {
    return BigInt((0, encode_1.addHexPrefix)(hex)).toString(10);
}
/**
 * Remove hex-string leading zeroes and lowercase it
 *
 * @param {string} hex hex-string
 * @returns {string} updated string in hex-string format
 * @example
 * ```typescript
 * cleanHex('0x00023AB'); // '0x23ab'
 * ```
 */
function cleanHex(hex) {
    return hex.toLowerCase().replace(/^(0x)0+/, '$1');
}
/**
 * Asserts input is equal to or greater then lowerBound and lower then upperBound.
 *
 * The `inputName` parameter is used in the assertion message.
 * @param input Value to check
 * @param lowerBound Lower bound value
 * @param upperBound Upper bound value
 * @param inputName Name of the input for error message
 * @throws Error if input is out of range
 * @example
 * ```typescript
 * const input1:BigNumberish = 10;
 * assertInRange(input1, 5, 20, 'value')
 *
 * const input2: BigNumberish = 25;
 * assertInRange(input2, 5, 20, 'value');
 * // throws Error: Message not signable, invalid value length.
 * ```
 */
function assertInRange(input, lowerBound, upperBound, inputName) {
    if (inputName === void 0) { inputName = ''; }
    var messageSuffix = inputName === '' ? 'invalid length' : "invalid ".concat(inputName, " length");
    var inputBigInt = BigInt(input);
    var lowerBoundBigInt = BigInt(lowerBound);
    var upperBoundBigInt = BigInt(upperBound);
    (0, assert_1.default)(inputBigInt >= lowerBoundBigInt && inputBigInt <= upperBoundBigInt, "Message not signable, ".concat(messageSuffix, "."));
}
/**
 * Convert BigNumberish array to decimal string array
 *
 * @param {BigNumberish[]} data array of big-numberish elements
 * @returns {string[]} array of decimal strings
 * @example
 * ```typescript
 * const data = [100, 200n];
 * const result = bigNumberishArrayToDecimalStringArray(data);
 * // result = ['100', '200']
 * ```
 */
function bigNumberishArrayToDecimalStringArray(data) {
    return data.map(function (x) { return toBigInt(x).toString(10); });
}
/**
 * Convert BigNumberish array to hexadecimal string array
 *
 * @param {BigNumberish[]} data array of big-numberish elements
 * @returns array of hex-strings
 * @example
 * ```typescript
 * const data = [100, 200n];
 * const result = bigNumberishArrayToHexadecimalStringArray(data);
 * // result = ['0x64', '0xc8']
 * ```
 */
function bigNumberishArrayToHexadecimalStringArray(data) {
    return data.map(function (x) { return toHex(x); });
}
/**
 * Test if string is a whole number (0, 1, 2, 3...)
 *
 * @param {string} str string to test
 * @returns {boolean}: true if string is a whole number, false otherwise
 * @example
 * ```typescript
 * isStringWholeNumber('100'); // true
 * isStringWholeNumber('10.0'); // false
 * isStringWholeNumber('test'); // false
 * ```
 */
function isStringWholeNumber(str) {
    return /^\d+$/.test(str);
}
/**
 * Convert string to decimal string
 *
 * @param {string} str string to convert
 * @returns converted string in decimal format
 * @throws str needs to be a number string in hex or whole number format
 * @example
 * ```typescript
 * const result = getDecimalString("0x1a");
 * // result = "26"
 *
 * const result2 = getDecimalString("Hello");
 * // throws Error: "Hello needs to be a hex-string or whole-number-string"
 * ```
 */
function getDecimalString(str) {
    if (isHex(str)) {
        return hexToDecimalString(str);
    }
    if (isStringWholeNumber(str)) {
        return str;
    }
    throw new Error("".concat(str, " needs to be a hex-string or whole-number-string"));
}
/**
 * Convert string to hexadecimal string
 *
 * @param {string} str string to convert
 * @returns converted hex-string
 * @throws str needs to be a number string in hex or whole number format
 * @example
 * ```typescript
 * const result = getHexString("123");
 * // result = "0x7b"
 *
 * const result2 = getHexString("Hello");
 * // throws Error: Hello needs to be a hex-string or whole-number-string
 * ```
 */
function getHexString(str) {
    if (isHex(str)) {
        return str;
    }
    if (isStringWholeNumber(str)) {
        return (0, exports.toHexString)(str);
    }
    throw new Error("".concat(str, " needs to be a hex-string or whole-number-string"));
}
/**
 * Convert string array to hex-string array
 *
 * @param {Array<string>} array array of string elements
 * @returns array of converted elements in hex-string format
 * @example
 * ```typescript
 * const data = ['100', '200', '0xaa'];
 * const result = getHexStringArray(data);
 * // result = ['0x64', '0xc8', '0xaa']
 * ```
 */
function getHexStringArray(array) {
    return array.map(getHexString);
}
/**
 * Convert boolean to "0" or "1"
 *
 * @param value The boolean value to be converted.
 * @returns {boolean} Returns true if the value is a number, otherwise returns false.
 * @example
 * ```typescript
 * const result = toCairoBool(true);
 * // result ="1"
 *
 * const result2 = toCairoBool(false);
 * // result2 = "0"
 * ```
 */
function toCairoBool(value) {
    return (+value).toString();
}
/**
 * Convert hex-string to an array of Bytes (Uint8Array)
 *
 * @param {string} str hex-string
 * @returns {Uint8Array} array containing the converted elements
 * @throws str must be a hex-string
 * @example
 * ```typescript
 * let result;
 *
 * result = hexToBytes('0x64');
 * // result = [100]
 *
 * result = hexToBytes('test');
 * // throws Error: test needs to be a hex-string
 * ```
 */
function hexToBytes(str) {
    if (!isHex(str))
        throw new Error("".concat(str, " needs to be a hex-string"));
    var adaptedValue = (0, encode_1.removeHexPrefix)(str);
    if (adaptedValue.length % 2 !== 0) {
        adaptedValue = "0".concat(adaptedValue);
    }
    return (0, utils_1.hexToBytes)(adaptedValue);
}
/**
 * Adds a percentage amount to the value
 *
 * @param number value to be modified
 * @param percent integer as percent ex. 50 for 50%
 * @returns {BigInt} modified value
 * @example
 * ```typescript
 * addPercent(100, 50); // 150n
 * addPercent(100, 100); // 200n
 * addPercent(200, 50); // 300n
 * addPercent(200, -50); // 100n
 * addPercent(200, -100); // 0n
 * addPercent(200, -150); // -100n
 * ```
 */
function addPercent(number, percent) {
    var bigIntNum = BigInt(number);
    return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;
}
/**
 * Check if a value is a number.
 *
 * @param {unknown} value - The value to check.
 * @returns {boolean} Returns true if the value is a number, otherwise returns false.
 * @example
 * ```typescript
 * const result = isNumber(123);
 * // result = true
 *
 * const result2 = isNumber("123");
 * // result2 = false
 * ```
 * @return {boolean} Returns true if the value is a number, otherwise returns false.
 */
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * Checks if a given value is of boolean type.
 *
 * @param {unknown} value - The value to check.
 * @returns {boolean} - True if the value is of boolean type, false otherwise.
 * @example
 * ```typescript
 * const result = isBoolean(true);
 * // result = true
 *
 * const result2 = isBoolean(false);
 * // result2 = false
 * ```
 * @return {boolean} - True if the value is of boolean type, false otherwise.
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}

},{"./assert":141,"./encode":163,"@noble/curves/abstract/utils":31}],176:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = exports.validBlockTags = exports.getDefaultNodeUrl = void 0;
exports.wait = wait;
exports.createSierraContractClass = createSierraContractClass;
exports.parseContract = parseContract;
exports.isV3Tx = isV3Tx;
exports.isVersion = isVersion;
exports.isPendingBlock = isPendingBlock;
exports.isPendingTransaction = isPendingTransaction;
exports.isPendingStateUpdate = isPendingStateUpdate;
var constants_1 = require("../constants");
var types_1 = require("../types");
var api_1 = require("../types/api");
var contract_1 = require("./contract");
var hash_1 = require("./hash");
var json_1 = require("./json");
var num_1 = require("./num");
var shortString_1 = require("./shortString");
var stark_1 = require("./stark");
/**
 * Helper - Async Sleep for 'delay' time
 *
 * @param {number} delay - Number of milliseconds to delay
 * @returns {Promise<unknown>}
 * @example
 * ```typescript
 * await provider.wait(1000) // 1000 milliseconds == 1 second
 * ```
 */
function wait(delay) {
    return new Promise(function (res) {
        setTimeout(res, delay);
    });
}
/**
 * Create Sierra compressed Contract Class from a given Compiled Sierra
 *
 * CompiledSierra -> SierraContractClass
 *
 * @param {CompiledSierra} contract sierra code from the Cairo compiler
 * @returns {SierraContractClass} compressed Sierra
 * @example
 * ```typescript
 * const result = provider.createSierraContractClass({
    "sierra_program": [
        "0x1",
        "0x4",
        "0x0",
        "0x2",
        "0x4",
        "0x1",
        "0x3b4",
        "0x4c",
        "0x65",
        "0x52616e6765436865636b",...})
 * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}
 * ```
 */
function createSierraContractClass(contract) {
    var result = __assign({}, contract);
    delete result.sierra_program_debug_info;
    result.abi = (0, hash_1.formatSpaces)((0, json_1.stringify)(contract.abi));
    result.sierra_program = (0, hash_1.formatSpaces)((0, json_1.stringify)(contract.sierra_program));
    result.sierra_program = (0, stark_1.compressProgram)(result.sierra_program);
    return result;
}
/**
 * Create a compressed contract from a given compiled Cairo 0 & 1 contract or a string.
 * @param {CompiledContract | string} contract - Compiled Cairo 0 or Cairo 1 contract, or string
 * @returns {ContractClass} Cairo 0 or Cairo 1 compressed contract
 * @example
 * ```typescript
 * const result = provider.parseContract({
    "sierra_program": [
        "0x1",
        "0x4",
        "0x0",
        "0x2",
        "0x4",
        "0x1",
        "0x3b4",
        "0x4c",
        "0x65",
        "0x52616e6765436865636b",...})
 * // result = {sierra_program: 'H4sIAAAAAAAAA6x9WZbsrI7uVGqd53qgb8ZynwzYY7jDv5JAAmxHZuQ+96yq/L0jIzEINZ8axP/5j/q/+j//+z/wH9f/o/p/zPbh+Iot49+u9v8G3//rTdDhDDF4Z0MKPthQ+m+S2v6n1S//638VvdXW2PQ6RvxuDG+jiybCXKJ7Hef6ZRi9E+Q89WmKLilfqbrsL6PUCf8...}
 * ```
 */
function parseContract(contract) {
    var parsedContract = (0, shortString_1.isString)(contract) ? (0, json_1.parse)(contract) : contract;
    if (!(0, contract_1.isSierra)(contract)) {
        return __assign(__assign({}, parsedContract), ('program' in parsedContract && { program: (0, stark_1.compressProgram)(parsedContract.program) }));
    }
    return createSierraContractClass(parsedContract);
}
/**
 * Return randomly select available public node
 * @param {NetworkName} networkName NetworkName
 * @param {boolean} mute mute public node warning
 * @returns {string} default node url
 * @example
 * ```typescript
 * const result= provider.getDefaultNodeUrl(constants.NetworkName.SN_MAIN,false);
 * // console : "Using default public node url, please provide nodeUrl in provider options!"
 * // result = "https://starknet-mainnet.public.blastapi.io/rpc/v0_7"
 * ```
 */
var getDefaultNodeUrl = function (networkName, mute) {
    if (mute === void 0) { mute = false; }
    if (!mute) {
        // eslint-disable-next-line no-console
        console.warn('Using default public node url, please provide nodeUrl in provider options!');
    }
    var nodes = constants_1.RPC_NODES[networkName !== null && networkName !== void 0 ? networkName : constants_1.NetworkName.SN_SEPOLIA];
    var randIdx = Math.floor(Math.random() * nodes.length);
    return nodes[randIdx];
};
exports.getDefaultNodeUrl = getDefaultNodeUrl;
exports.validBlockTags = Object.values(types_1.BlockTag);
/**
 * This class is formatting the identifier of a block.
 *
 * hex string and BigInt are detected as block hashes. identifier return { block_hash: hash }
 *
 * decimal string and number are detected as block numbers. identifier return { block_number: number }
 *
 * text string are detected as block tag. identifier return tag
 *
 * null is detected as 'pending' block tag. identifier return 'pending'
 * @example
 * ```typescript
 * const result = new provider.Block(null).identifier;
 * // result = "pending"
 * ```
 */
var Block = /** @class */ (function () {
    /**
     * Create a Block instance
     * @param {BlockIdentifier} _identifier  hex string and BigInt are detected as block hashes.
     * decimal string and number are detected as block numbers.
     * text string are detected as block tag.
     * null is considered as a 'pending' block tag.
     */
    function Block(_identifier) {
        var _this = this;
        /**
         * @param {BlockIdentifier} hash if not null, contains the block hash
         */
        this.hash = null;
        /**
         * @param {BlockIdentifier} number if not null, contains the block number
         */
        this.number = null;
        /**
         * @param {BlockIdentifier} tag if not null, contains "pending" or "latest"
         */
        this.tag = null;
        this.valueOf = function () { return _this.number; };
        this.toString = function () { return _this.hash; };
        this.setIdentifier(_identifier);
    }
    Block.prototype.setIdentifier = function (__identifier) {
        if ((0, shortString_1.isString)(__identifier)) {
            if ((0, shortString_1.isDecimalString)(__identifier)) {
                this.number = parseInt(__identifier, 10);
            }
            else if ((0, num_1.isHex)(__identifier)) {
                this.hash = __identifier;
            }
            else if (exports.validBlockTags.includes(__identifier)) {
                this.tag = __identifier;
            }
            else {
                throw TypeError("Block identifier unmanaged: ".concat(__identifier));
            }
        }
        else if ((0, num_1.isBigInt)(__identifier)) {
            this.hash = (0, num_1.toHex)(__identifier);
        }
        else if ((0, num_1.isNumber)(__identifier)) {
            this.number = __identifier;
        }
        else {
            this.tag = types_1.BlockTag.PENDING;
        }
        if ((0, num_1.isNumber)(this.number) && this.number < 0) {
            throw TypeError("Block number (".concat(this.number, ") can't be negative"));
        }
    };
    Object.defineProperty(Block.prototype, "queryIdentifier", {
        // TODO: fix any
        /**
         * @returns {any} the identifier as a string
         * @example
         * ```typescript
         * const result = new provider.Block(123456n).queryIdentifier;
         * // result = "blockHash=0x1e240"
         * ```
         */
        get: function () {
            if (this.number !== null) {
                return "blockNumber=".concat(this.number);
            }
            if (this.hash !== null) {
                return "blockHash=".concat(this.hash);
            }
            return "blockNumber=".concat(this.tag);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Block.prototype, "identifier", {
        // TODO: fix any
        /**
         * @returns {any} the identifier as an object
         * @example
         * ```typescript
         * const result = new provider.Block(56789).identifier;
         * // result = { block_number: 56789 }
         * ```
         */
        get: function () {
            if (this.number !== null) {
                return { block_number: this.number };
            }
            if (this.hash !== null) {
                return { block_hash: this.hash };
            }
            return this.tag;
        },
        /**
         * change the identifier of an existing Block instance
         * @example
         * ```typescript
         * const myBlock = new provider.Block("latest");
         * myBlock.identifier ="0x3456789abc";
         * const result = myBlock.identifier;
         * // result = { block_hash: '0x3456789abc' }
         * ```
         */
        set: function (_identifier) {
            this.setIdentifier(_identifier);
        },
        enumerable: false,
        configurable: true
    });
    return Block;
}());
exports.Block = Block;
/**
 * Check if the given transaction details is a V3 transaction.
 *
 * @param {InvocationsDetailsWithNonce} details The transaction details to be checked.
 * @return {boolean} Returns true if the transaction is a V3 transaction, otherwise false.
 * @example
 * ```typescript
 * const invocation: InvocationsDetailsWithNonce = {
 *   nonce: 1,
 *   version: 3,
 *   maxFee: 10 ** 15,
 *   feeDataAvailabilityMode: RPC.EDataAvailabilityMode.L1,
 *   tip: 10 ** 13,
 *   paymasterData: [],
 *   resourceBounds: {
 *       l1_gas: { max_amount: num.toHex(10 ** 14), max_price_per_unit: num.toHex(50) },
 *       l2_gas: { max_amount: num.toHex(0), max_price_per_unit: num.toHex(0) }}};
 * const result = provider.isV3Tx(invocation);
 * // result = true
 * ```
 */
function isV3Tx(details) {
    var version = details.version ? (0, num_1.toHex)(details.version) : api_1.ETransactionVersion.V3;
    return version === api_1.ETransactionVersion.V3 || version === api_1.ETransactionVersion.F3;
}
/**
 * Determines if the given response matches the specified version.
 *
 * @param {('0.5' | '0.6' | '0.7')} version The version to compare against the response.
 * @param {string} response The response to check against the version.
 * @returns {boolean} True if the response matches the version, false otherwise.
 * @example
 * ``` typescript
 * const result = provider.isVersion("0.7","0_7");
 * // result = false
 * ```
 */
function isVersion(version, response) {
    var _a = version.split('.'), majorS = _a[0], minorS = _a[1];
    var _b = response.split('.'), majorR = _b[0], minorR = _b[1];
    return majorS === majorR && minorS === minorR;
}
/**
 * Guard Pending Block
 * @param {GetBlockResponse} response answer of myProvider.getBlock()
 * @return {boolean} true if block is the pending block
 * @example
 * ```typescript
 * const block = await myProvider.getBlock("pending");
 * const result = provider.isPendingBlock(block);
 * // result = true
 * ```
 */
function isPendingBlock(response) {
    return response.status === 'PENDING';
}
/**
 * Guard Pending Transaction
 * @param {GetTransactionReceiptResponse} response transaction Receipt
 * @return {boolean} true if the transaction is part of the pending block
 * @example
 * ```typescript
 * const block = await myProvider.getBlockWithTxs("pending");
 * const txR = await myProvider.getTransactionReceipt(block.transactions[0].transaction_hash);
 * const result = provider.isPendingTransaction(txR);
 * // result = true
 * ```
 */
function isPendingTransaction(response) {
    return !('block_hash' in response);
}
/**
 * Guard Pending State Update
 * @param {StateUpdateResponse} response State of a block
 * @return {boolean} true if the block is pending
 * @example
 * ```typescript
 * const state: StateUpdateResponse = await myProvider.getStateUpdate("pending");
 * const result = provider.isPendingStateUpdate(state);
 * // result = true
 * ```
 */
function isPendingStateUpdate(response) {
    return !('block_hash' in response);
}

},{"../constants":102,"../types":128,"../types/api":119,"./contract":161,"./hash":168,"./json":173,"./num":175,"./shortString":180,"./stark":181}],177:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./interface"), exports);
__exportStar(require("./rpc"), exports);

},{"./interface":178,"./rpc":179}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseParser = void 0;
var ResponseParser = /** @class */ (function () {
    function ResponseParser() {
    }
    return ResponseParser;
}());
exports.ResponseParser = ResponseParser;

},{}],179:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCResponseParser = void 0;
var num_1 = require("../num");
var shortString_1 = require("../shortString");
var stark_1 = require("../stark");
var RPCResponseParser = /** @class */ (function () {
    function RPCResponseParser(margin) {
        this.margin = margin;
    }
    RPCResponseParser.prototype.estimatedFeeToMaxFee = function (estimatedFee) {
        var _a;
        return (0, stark_1.estimatedFeeToMaxFee)(estimatedFee, (_a = this.margin) === null || _a === void 0 ? void 0 : _a.maxFee);
    };
    RPCResponseParser.prototype.estimateFeeToBounds = function (estimate) {
        var _a, _b;
        return (0, stark_1.estimateFeeToBounds)(estimate, (_a = this.margin) === null || _a === void 0 ? void 0 : _a.l1BoundMaxAmount, (_b = this.margin) === null || _b === void 0 ? void 0 : _b.l1BoundMaxPricePerUnit);
    };
    RPCResponseParser.prototype.parseGetBlockResponse = function (res) {
        return __assign({ status: 'PENDING' }, res);
    };
    RPCResponseParser.prototype.parseTransactionReceipt = function (res) {
        // HOTFIX RPC 0.5 to align with RPC 0.6
        // This case is RPC 0.5. It can be only v2 thx with FRI units
        if ('actual_fee' in res && (0, shortString_1.isString)(res.actual_fee)) {
            return __assign(__assign({}, res), { actual_fee: {
                    amount: res.actual_fee,
                    unit: 'FRI',
                } });
        }
        return res;
    };
    RPCResponseParser.prototype.parseFeeEstimateResponse = function (res) {
        var val = res[0];
        return {
            overall_fee: (0, num_1.toBigInt)(val.overall_fee),
            gas_consumed: (0, num_1.toBigInt)(val.gas_consumed),
            gas_price: (0, num_1.toBigInt)(val.gas_price),
            unit: val.unit,
            suggestedMaxFee: this.estimatedFeeToMaxFee(val.overall_fee),
            resourceBounds: this.estimateFeeToBounds(val),
            data_gas_consumed: val.data_gas_consumed ? (0, num_1.toBigInt)(val.data_gas_consumed) : 0n,
            data_gas_price: val.data_gas_price ? (0, num_1.toBigInt)(val.data_gas_price) : 0n,
        };
    };
    RPCResponseParser.prototype.parseFeeEstimateBulkResponse = function (res) {
        var _this = this;
        return res.map(function (val) { return ({
            overall_fee: (0, num_1.toBigInt)(val.overall_fee),
            gas_consumed: (0, num_1.toBigInt)(val.gas_consumed),
            gas_price: (0, num_1.toBigInt)(val.gas_price),
            unit: val.unit,
            suggestedMaxFee: _this.estimatedFeeToMaxFee(val.overall_fee),
            resourceBounds: _this.estimateFeeToBounds(val),
            data_gas_consumed: val.data_gas_consumed ? (0, num_1.toBigInt)(val.data_gas_consumed) : 0n,
            data_gas_price: val.data_gas_price ? (0, num_1.toBigInt)(val.data_gas_price) : 0n,
        }); });
    };
    RPCResponseParser.prototype.parseSimulateTransactionResponse = function (
    // TODO: revisit
    // set as 'any' to avoid a mapped type circular recursion error stemming from
    // merging src/types/api/rpcspec*/components/FUNCTION_INVOCATION.calls
    //
    // res: SimulateTransactionResponse
    res) {
        var _this = this;
        return res.map(function (it) {
            return __assign(__assign({}, it), { suggestedMaxFee: _this.estimatedFeeToMaxFee(it.fee_estimation.overall_fee), resourceBounds: _this.estimateFeeToBounds(it.fee_estimation) });
        });
    };
    RPCResponseParser.prototype.parseContractClassResponse = function (res) {
        return __assign(__assign({}, res), { abi: (0, shortString_1.isString)(res.abi) ? JSON.parse(res.abi) : res.abi });
    };
    RPCResponseParser.prototype.parseL1GasPriceResponse = function (res) {
        return res.l1_gas_price.price_in_wei;
    };
    return RPCResponseParser;
}());
exports.RPCResponseParser = RPCResponseParser;

},{"../num":175,"../shortString":180,"../stark":181}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLongText = exports.isShortText = void 0;
exports.isASCII = isASCII;
exports.isShortString = isShortString;
exports.isDecimalString = isDecimalString;
exports.isString = isString;
exports.isText = isText;
exports.splitLongString = splitLongString;
exports.encodeShortString = encodeShortString;
exports.decodeShortString = decodeShortString;
var constants_1 = require("../constants");
var encode_1 = require("./encode");
var num_1 = require("./num");
/**
 * Test if string contains only ASCII characters (string can be ascii text)
 * @param {string} str The string to test
 * @returns {boolean} Returns true if the string contains only ASCII characters, otherwise false
 * @example
 * ```typescript
 * const result = shortString.isASCII("Hello, world!");
 * // result = true
 * const result = shortString.isASCII("Hello, !");
 * // result = false
 * ```
 */
function isASCII(str) {
    // eslint-disable-next-line no-control-regex
    return /^[\x00-\x7F]*$/.test(str);
}
/**
 * Test if a string is a Cairo short string (string with less or equal 31 characters)
 * @param {string} str the string to test
 * @returns {boolean} Returns true if the string has less than or equal to 31 characters, otherwise false.
 * @example
 * ```typescript
 * const result = shortString.isShortString("Hello, world!");
 * // result = true
 * ```
 */
function isShortString(str) {
    return str.length <= constants_1.TEXT_TO_FELT_MAX_LEN;
}
/**
 * Test if string contains only numbers (string can be converted to decimal integer number)
 * @param {string} str the string to test.
 * @returns {boolean} Returns true if the string contains only numbers, otherwise false.
 * @example
 * ```typescript
 * const result = shortString.isDecimalString("12345");
 * // result = true
 * const result = shortString.isDecimalString("12a45");
 * // result = false
 * ```
 */
function isDecimalString(str) {
    return /^[0-9]*$/i.test(str);
}
/**
 * Checks if a given value is a string.
 * @param {unknown} value the value to be checked.
 * @return {boolean} returns true if the value is a string, false otherwise.
 * @example
 * ```typescript
 * const result = shortString.isString("12345");
 * // result = true
 * ```
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Test if value is a pure string text, and not a hex string or number string
 * @param {any} val the value to test
 * @returns {boolean} returns true if the value is a free-form string text, otherwise false
 * @example
 * ```typescript
 * const result = shortString.isText("Hello, world!");
 * // result = true
 * const result = shortString.isText("0x7aec92f706");
 * // result = false
 * ```
 */
function isText(val) {
    return isString(val) && !(0, num_1.isHex)(val) && !(0, num_1.isStringWholeNumber)(val);
}
/**
 * Test if value is short text
 * @param {any} val - The item to test
 * @returns {boolean} Returns true if the value is a short text (string has less or equal 31 characters), otherwise false
 * @example
 * ```typescript
 * const result = shortString.isShortText("Hello, world!");
 * // result = true
 * ```
 */
var isShortText = function (val) { return isText(val) && isShortString(val); };
exports.isShortText = isShortText;
/**
 * Test if value is long text
 * @param {any} val the value to test
 * @returns {boolean} returns true if the value is a long text(string has more than 31 characters), otherwise false.
 * @example
 * ```typescript
 * const result = shortString.isLongText("Hello, world! this is some random long string to enable you test isLongText function.");
 * // result = true
 * ```
 */
var isLongText = function (val) { return isText(val) && !isShortString(val); };
exports.isLongText = isLongText;
/**
 * Split long text (string greater than 31 characters) into short strings (string lesser or equal 31 characters)
 * @param {string} longStr the long text (string greater than 31 characters) to split
 * @returns {string[]} an array of short strings (string lesser or equal 31 characters).
 * @example
 * ```typescript
 * const result = shortString.splitLongString("Hello, world! we just testing splitLongString function.");
 * // result = [ 'Hello, world! we just testing s', 'plitLongString function.' ]
 * ```
 */
function splitLongString(longStr) {
    var regex = RegExp("[^]{1,".concat(constants_1.TEXT_TO_FELT_MAX_LEN, "}"), 'g');
    return longStr.match(regex) || [];
}
/**
 * Convert an ASCII short string to a hexadecimal string.
 * @param {string} str short string (ASCII string, 31 characters max)
 * @returns {string} hex-string with 248 bits max
 * @example
 * ```typescript
 * const result = shortString.encodeShortString("uri/pict/t38.jpg");
 * // result = "0x7572692f706963742f7433382e6a7067"
 * ```
 */
function encodeShortString(str) {
    if (!isASCII(str))
        throw new Error("".concat(str, " is not an ASCII string"));
    if (!isShortString(str))
        throw new Error("".concat(str, " is too long"));
    return (0, encode_1.addHexPrefix)(str.replace(/./g, function (char) { return char.charCodeAt(0).toString(16); }));
}
/**
 * Convert a hexadecimal or decimal string to an ASCII string.
 * @param {string} str representing a 248 bit max number (ex. "0x1A4F64EA56" or "236942575435676423")
 * @returns {string} short string; 31 characters max
 * @example
 * ```typescript
 * const result = shortString.decodeShortString("0x7572692f706963742f7433382e6a7067");
 * // result = "uri/pict/t38.jpg"
 * ```
 */
function decodeShortString(str) {
    if (!isASCII(str))
        throw new Error("".concat(str, " is not an ASCII string"));
    if ((0, num_1.isHex)(str)) {
        return (0, encode_1.removeHexPrefix)(str).replace(/.{2}/g, function (hex) { return String.fromCharCode(parseInt(hex, 16)); });
    }
    if (isDecimalString(str)) {
        return decodeShortString('0X'.concat(BigInt(str).toString(16)));
    }
    throw new Error("".concat(str, " is not Hex or decimal"));
}

},{"../constants":102,"./encode":163,"./num":175}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressProgram = compressProgram;
exports.decompressProgram = decompressProgram;
exports.randomAddress = randomAddress;
exports.makeAddress = makeAddress;
exports.formatSignature = formatSignature;
exports.signatureToDecimalArray = signatureToDecimalArray;
exports.signatureToHexArray = signatureToHexArray;
exports.estimatedFeeToMaxFee = estimatedFeeToMaxFee;
exports.estimateFeeToBounds = estimateFeeToBounds;
exports.intDAM = intDAM;
exports.toTransactionVersion = toTransactionVersion;
exports.toFeeVersion = toFeeVersion;
exports.v3Details = v3Details;
exports.reduceV2 = reduceV2;
var starknet_1 = require("@scure/starknet");
var pako_1 = require("pako");
var constants_1 = require("../constants");
var api_1 = require("../types/api");
var encode_1 = require("./encode");
var json_1 = require("./json");
var num_1 = require("./num");
var shortString_1 = require("./shortString");
/**
 * Compress compiled Cairo 0 program
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)
 * @param {Program | string} jsonProgram Representing the compiled Cairo 0 program
 * @return {CompressedProgram} Compressed Cairo 0 program
 * @example
 * ```typescript
 * const contractCairo0 = json.parse(fs.readFileSync("./cairo0contract.json").toString("ascii"));
 * const result = stark.compressProgram(contractCairo0);
 * // result = "H4sIAAAAAAAAA+1dC4/bOJL+K4aBu01me7r5EEUyixzQk/TuB..."
 * ```
 */
function compressProgram(jsonProgram) {
    var stringified = (0, shortString_1.isString)(jsonProgram) ? jsonProgram : (0, json_1.stringify)(jsonProgram);
    var compressedProgram = (0, pako_1.gzip)(stringified);
    return (0, encode_1.btoaUniversal)(compressedProgram);
}
/**
 * Decompress compressed compiled Cairo 0 program
 * @param {CompressedProgram} base64 Compressed Cairo 0 program
 * @returns {Object | CompressedProgram} Parsed decompressed compiled Cairo 0 program
 * @example
 * ```typescript
 * const contractCairo0 = json.parse(fs.readFileSync("./cairo0contract.json").toString("ascii"));
 * const compressedCairo0 = stark.compressProgram(contractCairo0);
 * const result = stark.decompressProgram(compressedCairo0);
 * // result = {
 * //   abi: [
 * //     {
 * //       inputs: [Array],
 * //       name: 'increase_balance',
 * //       outputs: [],
 * //       type: 'function'
 * //     }
 * //   ],
 * //   entry_points_by_type: { CONSTRUCTOR: [], EXTERNAL: [ [Object], [Object] ], L1_HANDLER: [] },
 * //   program: {
 * //     attributes: [],
 * //     builtins: [ 'pedersen', 'range_check' ],
 * //     compiler_version: '0.10.2',
 * //     data: [
 * //       '0x480680017fff8000',
 * // ...
 * ```
 */
function decompressProgram(base64) {
    if (Array.isArray(base64))
        return base64;
    var decompressed = (0, encode_1.arrayBufferToString)((0, pako_1.ungzip)((0, encode_1.atobUniversal)(base64)));
    return (0, json_1.parse)(decompressed);
}
/**
 * Random Address based on random keyPair
 * @returns {string} an hex string of a random Starknet address
 * @example
 * ```typescript
 * const result = stark.randomAddress();
 * // result = "0x51fc8126a13cd5ddb29a71ca399cb1e814f086f5af1b502d7151c14929554f"
 * ```
 */
function randomAddress() {
    var randomKeyPair = starknet_1.utils.randomPrivateKey();
    return (0, starknet_1.getStarkKey)(randomKeyPair);
}
/**
 * Lowercase and hex prefix string
 *
 * @deprecated Not used internally, naming is confusing based on functionality
 */
function makeAddress(input) {
    return (0, encode_1.addHexPrefix)(input).toLowerCase();
}
/**
 * Format Signature to standard type (hex array)
 * @param {Signature} [sig]
 * @returns {ArraySignatureType} Custom hex string array
 * @throws {Error} if sig not defined, or wrong format
 * @example
 * ```typescript
 * const signature = ec.starkCurve.sign("0x12de34", "0x3487123eac");
 * const result = stark.formatSignature(signature);
 * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',
 * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']
 * ```
 */
function formatSignature(sig) {
    if (!sig)
        throw Error('formatSignature: provided signature is undefined');
    if (Array.isArray(sig)) {
        return sig.map(function (it) { return (0, num_1.toHex)(it); });
    }
    try {
        var r = sig.r, s = sig.s;
        return [(0, num_1.toHex)(r), (0, num_1.toHex)(s)];
    }
    catch (e) {
        throw new Error('Signature need to be weierstrass.SignatureType or an array for custom');
    }
}
/**
 * Format Signature to decimal string array
 * @param {Signature} [sig]
 * @returns {ArraySignatureType} Custom hex string array
 * @throws {Error} if sig not defined, or wrong format
 * @example
 * ```typescript
 * const signature = ec.starkCurve.sign("0x12de34", "0x3487123eac");
 * const result = stark.signatureToDecimalArray(signature);
 * // result = ['329619989660444495690615805546674399714973829707166906185976654753023887767',
 * //  '2994745480203297689255012826403147585778741462125743754529207781488706428188']
 * ```
 */
function signatureToDecimalArray(sig) {
    return (0, num_1.bigNumberishArrayToDecimalStringArray)(formatSignature(sig));
}
/**
 * Format Signature to hex string array
 * @param {Signature} [sig]
 * @returns {ArraySignatureType} Custom hex string array
 * @throws {Error} if sig not defined, or wrong format
 * @example
 * ```typescript
 * const signature = ec.starkCurve.sign("0x12de34", "0x3487123eac");
 * const result = stark.signatureToHexArray(signature);
 * // result = ['0xba8eecee2d69c417e8c6a20cf331c821f716b58ba9e47166c7476afdb38997',
 * //  '0x69ef7438c94104839a6e2aa2385482a77399d2f46e894ae4f50ab6d69239d1c']
 * ```
 */
function signatureToHexArray(sig) {
    return (0, num_1.bigNumberishArrayToHexadecimalStringArray)(formatSignature(sig));
}
/**
 * Convert estimated fee to max fee including a margin
 * @param {BigNumberish} estimatedFee - The estimated fee
 * @param {number} [overhead = feeMarginPercentage.MAX_FEE] - The overhead added to the gas
 * @returns {bigint} The maximum fee with the margin
 * @example
 * ```typescript
 * const result = stark.estimatedFeeToMaxFee("8982300000000", 50);
 * // result = "13473450000000n"
 * ```
 */
function estimatedFeeToMaxFee(estimatedFee, overhead) {
    if (overhead === void 0) { overhead = 50 /* FeeMarginPercentage.MAX_FEE */; }
    return (0, num_1.addPercent)(estimatedFee, overhead);
}
/**
 * Calculates the maximum resource bounds for fee estimation.
 *
 * @param {FeeEstimate | 0n} estimate The estimate for the fee. If a BigInt is provided, the returned bounds will be set to '0x0'.
 * @param {number} [amountOverhead = feeMarginPercentage.L1_BOUND_MAX_AMOUNT] - The percentage overhead added to the gas consumed or overall fee amount.
 * @param {number} [priceOverhead = feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT] The percentage overhead added to the gas price per unit.
 * @returns {ResourceBounds} The maximum resource bounds for fee estimation.
 * @throws {Error} If the estimate object is undefined or does not have the required properties.
 * @example
 * ```typescript
 * const feeEstimated: FeeEstimate = {
  gas_consumed: "0x3456a",
  gas_price: "0xa45567567567ae4",
  overall_fee: "0x2198F463A77A899A5668",
  unit: "WEI"
};
const result = stark.estimateFeeToBounds(feeEstimated, 70, 50);
 * // result = {
 * //   l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },
 * //   l1_gas: { max_amount: '0x58f9a', max_price_per_unit: '0xf6801b01b01b856' }
 * // }
 * ```
 */
function estimateFeeToBounds(estimate, amountOverhead, priceOverhead) {
    if (amountOverhead === void 0) { amountOverhead = 50 /* FeeMarginPercentage.L1_BOUND_MAX_AMOUNT */; }
    if (priceOverhead === void 0) { priceOverhead = 50 /* FeeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT */; }
    if ((0, num_1.isBigInt)(estimate)) {
        return {
            l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },
            l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },
        };
    }
    if (typeof estimate.gas_consumed === 'undefined' || typeof estimate.gas_price === 'undefined') {
        throw Error('estimateFeeToBounds: estimate is undefined');
    }
    var maxUnits = estimate.data_gas_consumed !== undefined && estimate.data_gas_price !== undefined // RPC v0.7
        ? (0, num_1.toHex)((0, num_1.addPercent)(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead))
        : (0, num_1.toHex)((0, num_1.addPercent)(estimate.gas_consumed, amountOverhead));
    var maxUnitPrice = (0, num_1.toHex)((0, num_1.addPercent)(estimate.gas_price, priceOverhead));
    return {
        l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },
        l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice },
    };
}
/**
 * Converts the data availability mode from EDataAvailabilityMode to EDAMode.
 *
 * @param {EDataAvailabilityMode} dam The data availability mode to be converted.
 * @return {EDAMode} The converted data availability mode.
 * @throws {Error} If the data availability mode is not a valid value.
 * @example
 * ```typescript
 * const result = stark.intDAM(RPC.EDataAvailabilityMode.L1);
 * // result = 0
 * ```
 */
function intDAM(dam) {
    if (dam === api_1.EDataAvailabilityMode.L1)
        return api_1.EDAMode.L1;
    if (dam === api_1.EDataAvailabilityMode.L2)
        return api_1.EDAMode.L2;
    throw Error('EDAM conversion');
}
/**
 * Convert to ETransactionVersion or throw an error.
 * Return providedVersion is specified else return defaultVersion
 * @param {BigNumberish} defaultVersion default estimate transaction version
 * @param {BigNumberish} [providedVersion] estimate transaction version
 * @returns {ETransactionVersion} if providedVersion is not provided, returns the default estimate version, else return the provided version
 * @throws {Error} if estimate transaction version or default estimate transaction version is unknown
 * @example
 * ```typescript
 * const result = stark.toTransactionVersion("0x100000000000000000000000000000003", stark.toFeeVersion(2));
 * // result = "0x100000000000000000000000000000002"
 * ```
 */
function toTransactionVersion(defaultVersion, providedVersion) {
    var providedVersion0xs = providedVersion ? (0, num_1.toHex)(providedVersion) : undefined;
    var defaultVersion0xs = (0, num_1.toHex)(defaultVersion);
    if (providedVersion && !Object.values(api_1.ETransactionVersion).includes(providedVersion0xs)) {
        throw Error("providedVersion ".concat(providedVersion, " is not ETransactionVersion"));
    }
    if (!Object.values(api_1.ETransactionVersion).includes(defaultVersion0xs)) {
        throw Error("defaultVersion ".concat(defaultVersion, " is not ETransactionVersion"));
    }
    return (providedVersion ? providedVersion0xs : defaultVersion0xs);
}
/**
 * Convert Transaction version to Fee version or throw an error
 * @param {BigNumberish} [providedVersion] 0..3 number representing the transaction version
 * @returns {ETransactionVersion} the fee estimation version corresponding to the transaction version provided
 * @throws {Error} if the transaction version is unknown
 * @example
 * ```typescript
 * const result = stark.toFeeVersion(2);
 * // result = "0x100000000000000000000000000000002"
 * ```
 */
function toFeeVersion(providedVersion) {
    if (!providedVersion)
        return undefined;
    var version = (0, num_1.toHex)(providedVersion);
    if (version === api_1.ETransactionVersion.V0)
        return api_1.ETransactionVersion.F0;
    if (version === api_1.ETransactionVersion.V1)
        return api_1.ETransactionVersion.F1;
    if (version === api_1.ETransactionVersion.V2)
        return api_1.ETransactionVersion.F2;
    if (version === api_1.ETransactionVersion.V3)
        return api_1.ETransactionVersion.F3;
    throw Error("toFeeVersion: ".concat(version, " is not supported"));
}
/**
 * Return provided or default v3 tx details
 * @param {UniversalDetails} details details of the transaction
 * @return {} an object including the V3 transaction details.
 * @example
 * ```typescript
 * const detail: UniversalDetails = { tip: 3456n };
 * const result = stark.v3Details(detail);
 * // result = {
 * //   tip: 3456n,
 * //   paymasterData: [],
 * //   accountDeploymentData: [],
 * //   nonceDataAvailabilityMode: 'L1',
 * //   feeDataAvailabilityMode: 'L1',
 * //   resourceBounds: {
 * //     l2_gas: { max_amount: '0x0', max_price_per_unit: '0x0' },
 * //     l1_gas: { max_amount: '0x0', max_price_per_unit: '0x0' }
 * //   }
 * // }
 * ```
 */
function v3Details(details) {
    var _a;
    return {
        tip: details.tip || 0,
        paymasterData: details.paymasterData || [],
        accountDeploymentData: details.accountDeploymentData || [],
        nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || api_1.EDataAvailabilityMode.L1,
        feeDataAvailabilityMode: details.feeDataAvailabilityMode || api_1.EDataAvailabilityMode.L1,
        resourceBounds: (_a = details.resourceBounds) !== null && _a !== void 0 ? _a : estimateFeeToBounds(constants_1.ZERO),
    };
}
/**
 * It will reduce V2 to V1, else (V3) stay the same
 * F2 -> F1
 * V2 -> V1
 * F3 -> F3
 * V3 -> V3
 * @param {ETransactionVersion} providedVersion
 * @returns {ETransactionVersion} if v2 then returns v1. if v3 then return v3
 * @example
 * ```typescript
 * const result = stark.reduceV2(constants.TRANSACTION_VERSION.V2);
 * // result = "0x1"
 * ```
 */
function reduceV2(providedVersion) {
    if (providedVersion === api_1.ETransactionVersion.F2)
        return api_1.ETransactionVersion.F1;
    if (providedVersion === api_1.ETransactionVersion.V2)
        return api_1.ETransactionVersion.V1;
    return providedVersion;
}

},{"../constants":102,"../types/api":119,"./encode":163,"./json":173,"./num":175,"./shortString":180,"@scure/starknet":43,"pako":61}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetIdPopContract = exports.StarknetIdPfpContract = exports.StarknetIdVerifierContract = exports.StarknetIdMulticallContract = exports.StarknetIdIdentityContract = exports.StarknetIdContract = void 0;
exports.useDecoded = useDecoded;
exports.useEncoded = useEncoded;
exports.getStarknetIdContract = getStarknetIdContract;
exports.getStarknetIdIdentityContract = getStarknetIdIdentityContract;
exports.getStarknetIdMulticallContract = getStarknetIdMulticallContract;
exports.getStarknetIdVerifierContract = getStarknetIdVerifierContract;
exports.getStarknetIdPfpContract = getStarknetIdPfpContract;
exports.getStarknetIdPopContract = getStarknetIdPopContract;
exports.execution = execution;
exports.dynamicFelt = dynamicFelt;
exports.dynamicCallData = dynamicCallData;
var constants_1 = require("../constants");
var cairo_1 = require("./calldata/cairo");
var CairoCustomEnum_1 = require("./calldata/enum/CairoCustomEnum");
/* eslint-disable no-param-reassign */
var basicAlphabet = 'abcdefghijklmnopqrstuvwxyz0123456789-';
var basicSizePlusOne = BigInt(basicAlphabet.length + 1);
var bigAlphabet = '';
var basicAlphabetSize = BigInt(basicAlphabet.length);
var bigAlphabetSize = BigInt(bigAlphabet.length);
var bigAlphabetSizePlusOne = BigInt(bigAlphabet.length + 1);
function extractStars(str) {
    var k = 0;
    while (str.endsWith(bigAlphabet[bigAlphabet.length - 1])) {
        str = str.substring(0, str.length - 1);
        k += 1;
    }
    return [str, k];
}
/**
 * Decodes an array of BigInts into a string using the given algorithm.
 * @param {bigint[]} encoded The encoded array of BigInts.
 * @return {string} The decoded string.
 * @example
 * ```typescript
 * const result = starknetId.useDecoded([3015206943634620n]);
 * // result = "starknetjs.stark"
 * ```
 */
function useDecoded(encoded) {
    var decoded = '';
    encoded.forEach(function (subdomain) {
        while (subdomain !== constants_1.ZERO) {
            var code = subdomain % basicSizePlusOne;
            subdomain /= basicSizePlusOne;
            if (code === BigInt(basicAlphabet.length)) {
                var nextSubdomain = subdomain / bigAlphabetSizePlusOne;
                if (nextSubdomain === constants_1.ZERO) {
                    var code2 = subdomain % bigAlphabetSizePlusOne;
                    subdomain = nextSubdomain;
                    if (code2 === constants_1.ZERO)
                        decoded += basicAlphabet[0];
                    else
                        decoded += bigAlphabet[Number(code2) - 1];
                }
                else {
                    var code2 = subdomain % bigAlphabetSize;
                    decoded += bigAlphabet[Number(code2)];
                    subdomain /= bigAlphabetSize;
                }
            }
            else
                decoded += basicAlphabet[Number(code)];
        }
        var _a = extractStars(decoded), str = _a[0], k = _a[1];
        if (k)
            decoded =
                str +
                    (k % 2 === 0
                        ? bigAlphabet[bigAlphabet.length - 1].repeat(k / 2 - 1) +
                            bigAlphabet[0] +
                            basicAlphabet[1]
                        : bigAlphabet[bigAlphabet.length - 1].repeat((k - 1) / 2 + 1));
        decoded += '.';
    });
    if (!decoded) {
        return decoded;
    }
    return decoded.concat('stark');
}
/**
 * Encodes a string into a bigint value.
 *
 * @param {string} decoded The string to be encoded.
 * @returns {bigint} The encoded bigint value.
 * @example
 * ```typescript
 * const result = starknetId.useEncoded("starknet.js");
 * // result = 3015206943634620n
 * ```
 */
function useEncoded(decoded) {
    var encoded = BigInt(0);
    var multiplier = BigInt(1);
    if (decoded.endsWith(bigAlphabet[0] + basicAlphabet[1])) {
        var _a = extractStars(decoded.substring(0, decoded.length - 2)), str = _a[0], k = _a[1];
        decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(2 * (k + 1));
    }
    else {
        var _b = extractStars(decoded), str = _b[0], k = _b[1];
        if (k)
            decoded = str + bigAlphabet[bigAlphabet.length - 1].repeat(1 + 2 * (k - 1));
    }
    for (var i = 0; i < decoded.length; i += 1) {
        var char = decoded[i];
        var index = basicAlphabet.indexOf(char);
        var bnIndex = BigInt(basicAlphabet.indexOf(char));
        if (index !== -1) {
            // add encoded + multiplier * index
            if (i === decoded.length - 1 && decoded[i] === basicAlphabet[0]) {
                encoded += multiplier * basicAlphabetSize;
                multiplier *= basicSizePlusOne;
                // add 0
                multiplier *= basicSizePlusOne;
            }
            else {
                encoded += multiplier * bnIndex;
                multiplier *= basicSizePlusOne;
            }
        }
        else if (bigAlphabet.indexOf(char) !== -1) {
            // add encoded + multiplier * (basicAlphabetSize)
            encoded += multiplier * basicAlphabetSize;
            multiplier *= basicSizePlusOne;
            // add encoded + multiplier * index
            var newid = (i === decoded.length - 1 ? 1 : 0) + bigAlphabet.indexOf(char);
            encoded += multiplier * BigInt(newid);
            multiplier *= bigAlphabetSize;
        }
    }
    return encoded;
}
var StarknetIdContract;
(function (StarknetIdContract) {
    StarknetIdContract["MAINNET"] = "0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678";
    StarknetIdContract["TESTNET_SEPOLIA"] = "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474";
})(StarknetIdContract || (exports.StarknetIdContract = StarknetIdContract = {}));
/**
 * Returns the Starknet ID contract address based on the provided chain ID.
 *
 * @param {StarknetChainId} chainId The chain ID of the Starknet network.
 * @return {string} The Starknet ID contract address.
 * @throws {Error} Throws an error if the Starknet ID contract is not deployed on the network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x154bc2e1af9260b9e66af0e9c46fc757ff893b3ff6a85718a810baf1474"
 * ```
 */
function getStarknetIdContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return StarknetIdContract.MAINNET;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return StarknetIdContract.TESTNET_SEPOLIA;
        default:
            throw new Error('Starknet.id is not yet deployed on this network');
    }
}
var StarknetIdIdentityContract;
(function (StarknetIdIdentityContract) {
    StarknetIdIdentityContract["MAINNET"] = "0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af";
    StarknetIdIdentityContract["TESTNET_SEPOLIA"] = "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda";
})(StarknetIdIdentityContract || (exports.StarknetIdIdentityContract = StarknetIdIdentityContract = {}));
/**
 * Returns the Starknet ID identity contract address for the given chain ID.
 *
 * @param {StarknetChainId} chainId The chain ID for the specified network.
 *
 * @return {string} The Starknet ID identity contract address for the specified network.
 *
 * @throws {Error} If the Starknet ID verifier contract is not deployed on the network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdIdentityContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x3697660a0981d734780731949ecb2b4a38d6a58fc41629ed611e8defda"
 * ```
 */
function getStarknetIdIdentityContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return StarknetIdIdentityContract.MAINNET;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return StarknetIdIdentityContract.TESTNET_SEPOLIA;
        default:
            throw new Error('Starknet.id verifier contract is not yet deployed on this network');
    }
}
exports.StarknetIdMulticallContract = '0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970';
/**
 * Returns the Starknet.id multicall contract address based on the provided chainId.
 *
 * @param {StarknetChainId} chainId - The chainId of the network.
 * @return {string} - The address of the Starknet.id multicall contract.
 * @throws {Error} - If the Starknet.id multicall contract is not deployed on the network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdMulticallContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970"
 * ```
 */
function getStarknetIdMulticallContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return exports.StarknetIdMulticallContract;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return exports.StarknetIdMulticallContract;
        default:
            throw new Error('Starknet.id multicall contract is not yet deployed on this network');
    }
}
var StarknetIdVerifierContract;
(function (StarknetIdVerifierContract) {
    StarknetIdVerifierContract["MAINNET"] = "0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf";
    StarknetIdVerifierContract["TESTNET_SEPOLIA"] = "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566";
})(StarknetIdVerifierContract || (exports.StarknetIdVerifierContract = StarknetIdVerifierContract = {}));
/**
 * Returns the address of the Starknet ID Verifier contract based on the specified chain ID.
 *
 * @param {StarknetChainId} chainId - The ID of the Starknet chain.
 * @return {string} - The address of the Starknet ID Verifier contract.
 * @throws {Error} - If the Starknet ID Verifier contract is not deployed on the specified network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdVerifierContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x60B94fEDe525f815AE5E8377A463e121C787cCCf3a36358Aa9B18c12c4D566"
 * ```
 */
function getStarknetIdVerifierContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return StarknetIdVerifierContract.MAINNET;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return StarknetIdVerifierContract.TESTNET_SEPOLIA;
        default:
            throw new Error('Starknet.id verifier contract is not yet deployed on this network');
    }
}
var StarknetIdPfpContract;
(function (StarknetIdPfpContract) {
    StarknetIdPfpContract["MAINNET"] = "0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7";
    StarknetIdPfpContract["TESTNET_SEPOLIA"] = "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02";
})(StarknetIdPfpContract || (exports.StarknetIdPfpContract = StarknetIdPfpContract = {}));
/**
 * Retrieves the contract address of the Starknet.id profile picture verifier contract based on the given chain ID.
 *
 * @param {StarknetChainId} chainId - The chain ID of the network.
 * @returns {string} - The contract address of the Starknet.id profile picture verifier contract.
 * @throws {Error} - Throws an error if the Starknet.id profile picture verifier contract is not yet deployed on the network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdPfpContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x9e7bdb8dabd02ea8cfc23b1d1c5278e46490f193f87516ed5ff2dfec02"
 * ```
 */
function getStarknetIdPfpContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return StarknetIdPfpContract.MAINNET;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return StarknetIdPfpContract.TESTNET_SEPOLIA;
        default:
            throw new Error('Starknet.id profile picture verifier contract is not yet deployed on this network');
    }
}
var StarknetIdPopContract;
(function (StarknetIdPopContract) {
    StarknetIdPopContract["MAINNET"] = "0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4";
    StarknetIdPopContract["TESTNET_SEPOLIA"] = "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a";
})(StarknetIdPopContract || (exports.StarknetIdPopContract = StarknetIdPopContract = {}));
/**
 * Retrieves the Starknet ID Proof of Personhood (IdPop) verifier contract address for the given chain ID.
 *
 * @param {StarknetChainId} chainId - The chain ID of the Starknet network.
 * @return {string} - The Starknet ID Pop contract address.
 * @throws {Error} - If the Starknet ID Pop contract is not deployed on the specified network.
 * @example
 * ```typescript
 * const result = starknetId.getStarknetIdPopContract(constants.StarknetChainId.SN_SEPOLIA);
 * // result = "0x15ae88ae054caa74090b89025c1595683f12edf7a4ed2ad0274de3e1d4a"
 * ```
 */
function getStarknetIdPopContract(chainId) {
    switch (chainId) {
        case constants_1.StarknetChainId.SN_MAIN:
            return StarknetIdPopContract.MAINNET;
        case constants_1.StarknetChainId.SN_SEPOLIA:
            return StarknetIdPopContract.TESTNET_SEPOLIA;
        default:
            throw new Error('Starknet.id proof of personhood verifier contract is not yet deployed on this network');
    }
}
/**
 * Returns a CairoCustomEnum object.
 *
 * Functions to build CairoCustomEnum for multiCall contracts
 * @param {Object} [staticEx] An optional object defining the "Static" value of the CairoCustomEnum.
 * @param {number[]} [ifEqual] An optional array defining the "IfEqual" value of the CairoCustomEnum.
 * @param {number[]} [ifNotEqual] An optional array defining the "IfNotEqual" value of the CairoCustomEnum.
 * @return {CairoCustomEnum} - The created CairoCustomEnum object.
 * @example
 * ```typescript
 * const result: CairoCustomEnum = starknetId.execution(undefined, [1, 2, 3], undefined);
 * // result = CairoCustomEnum {
 * //   variant: {
 * //     Static: undefined,
 * //     IfEqual: { '0': 1, '1': 2, '2': 3 },
 * //     IfNotEqual: undefined
 * //   }
 * // }
 * ```
 */
function execution(staticEx, ifEqual, ifNotEqual) {
    if (ifEqual === void 0) { ifEqual = undefined; }
    if (ifNotEqual === void 0) { ifNotEqual = undefined; }
    return new CairoCustomEnum_1.CairoCustomEnum({
        Static: staticEx,
        IfEqual: ifEqual ? (0, cairo_1.tuple)(ifEqual[0], ifEqual[1], ifEqual[2]) : undefined,
        IfNotEqual: ifNotEqual ? (0, cairo_1.tuple)(ifNotEqual[0], ifNotEqual[1], ifNotEqual[2]) : undefined,
    });
}
/**
 * Creates a new instance of CairoCustomEnum.
 *
 * @param {BigNumberish} [hardcoded] The hardcoded value for the CairoCustomEnum.
 * @param {number[]} [reference] The reference array for the CairoCustomEnum.
 * @returns {CairoCustomEnum} The new instance of CairoCustomEnum.
 * @example
 * ```typescript
 * const result: CairoCustomEnum = starknetId.dynamicFelt(undefined, [1, 2]);
 * // result = CairoCustomEnum {
 * //  variant: { Hardcoded: undefined, Reference: { '0': 1, '1': 2 } }
 * // }
 * ```
 */
function dynamicFelt(hardcoded, reference) {
    if (reference === void 0) { reference = undefined; }
    return new CairoCustomEnum_1.CairoCustomEnum({
        Hardcoded: hardcoded,
        Reference: reference ? (0, cairo_1.tuple)(reference[0], reference[1]) : undefined,
    });
}
/**
 * Creates a new instance of CairoCustomEnum with the given parameters.
 * @param {BigNumberish} [hardcoded] The hardcoded value.
 * @param {BigNumberish[]} [reference] The reference value (optional).
 * @param {BigNumberish[]} [arrayReference] The array reference value (optional).
 * @return {CairoCustomEnum} The new instance of CairoCustomEnum.
 * @example
 * ```typescript
 * const result: CairoCustomEnum = starknetId.dynamicCallData(undefined, [1, 2], undefined);
 * // result = CairoCustomEnum {
 * //   variant: {
 * //     Hardcoded: undefined,
 * //     Reference: { '0': 1, '1': 2 },
 * //     ArrayReference: undefined
 * //   }
 * // }
 * ```
 */
function dynamicCallData(hardcoded, reference, arrayReference) {
    if (reference === void 0) { reference = undefined; }
    if (arrayReference === void 0) { arrayReference = undefined; }
    return new CairoCustomEnum_1.CairoCustomEnum({
        Hardcoded: hardcoded,
        Reference: reference ? (0, cairo_1.tuple)(reference[0], reference[1]) : undefined,
        ArrayReference: arrayReference ? (0, cairo_1.tuple)(arrayReference[0], arrayReference[1]) : undefined,
    });
}

},{"../constants":102,"./calldata/cairo":146,"./calldata/enum/CairoCustomEnum":147}],183:[function(require,module,exports){
"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExecuteCalldata = exports.fromCallsToExecuteCalldata_cairo1 = exports.transformCallsToMulticallArrays_cairo1 = exports.fromCallsToExecuteCalldataWithNonce = exports.fromCallsToExecuteCalldata = exports.transformCallsToMulticallArrays = void 0;
exports.buildUDCCall = buildUDCCall;
exports.getVersionsByType = getVersionsByType;
var constants_1 = require("../constants");
var api_1 = require("../types/api");
var calldata_1 = require("./calldata");
var ec_1 = require("./ec");
var hash_1 = require("./hash");
var num_1 = require("./num");
var stark_1 = require("./stark");
/**
 * Transforms a list of Calls, each with their own calldata, into
 * two arrays: one with the entry points, and one with the concatenated calldata
 * @param {Call[]} calls the list of calls to transform.
 * @returns {callArray: ParsedStruct[], calldata: BigNumberish[]} An object containing two arrays: callArray and calldata.
 * @example
 * ```typescript
 * const calls: Call[] = [
 * 	{
 * 		contractAddress: "0x1234567890123456789012345678901234567890",
 * 		entrypoint: "functionName",
 * 		calldata: [1,2,3]
 * 	},
 * 	{
 * 		contractAddress: "0x0987654321098765432109876543210987654321",
 * 		entrypoint: "anotherFunction",
 * 		calldata: [4,5,6]
 * 	}
 * ];
 * const result = transaction.transformCallsToMulticallArrays(calls);
 * // result = {
 * // callArray: [
 * // { to: "0x1234567890123456789012345678901234567890", selector: "1234567890",
 * // data_offset: "0", data_len: "3" },
 * // { to: "0x0987654321098765432109876543210987654321", selector: "1234567890",
 * // data_offset: "0987654321", data_offset: "3", data_len: "3"}
 * // ], calldata: [1, 2, 3, 4, 5, 6]
 * // }
 * ```
 */
var transformCallsToMulticallArrays = function (calls) {
    var callArray = [];
    var calldata = [];
    calls.forEach(function (call) {
        var data = calldata_1.CallData.compile(call.calldata || []);
        callArray.push({
            to: (0, num_1.toBigInt)(call.contractAddress).toString(10),
            selector: (0, num_1.toBigInt)((0, hash_1.getSelectorFromName)(call.entrypoint)).toString(10),
            data_offset: calldata.length.toString(),
            data_len: data.length.toString(),
        });
        calldata.push.apply(calldata, data);
    });
    return {
        callArray: callArray,
        calldata: calldata_1.CallData.compile({ calldata: calldata }),
    };
};
exports.transformCallsToMulticallArrays = transformCallsToMulticallArrays;
/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata.
 * @param {Call[]} calls the list of calls to transform
 * @returns {Calldata} the Cairo 0 `__execute__` calldata
 * @example
 * ```typescript
 * const calls: Call[] = [
 * 	{
 * 		contractAddress: "0x1234567890123456789012345678901234567890",
 * 		entrypoint: "functionName",
 * 		calldata: [1, 2, 3]
 * 	},
 * 	{
 * 		contractAddress: "0x0987654321098765432109876543210987654321",
 * 		entrypoint: "anotherFunction",
 * 		calldata: [4, 5, 6]
 * 	}
 * ];
 * const result = transaction.fromCallsToExecuteCalldata(calls);
 * // result = ['2', '103929005307130220006098923584552504982110632080',
 * //   '784552248838722632831848474045274978537388011177294206940059575485454596699', '0',
 * //   '3', '54400338722927882010739357306608455014511100705',
 * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',
 * //   '3', '3', '6', '1', '2', '3', '4', '5', '6']
 * ```
 */
var fromCallsToExecuteCalldata = function (calls) {
    var _a = (0, exports.transformCallsToMulticallArrays)(calls), callArray = _a.callArray, calldata = _a.calldata;
    var compiledCalls = calldata_1.CallData.compile({ callArray: callArray });
    return __spreadArray(__spreadArray([], compiledCalls, true), calldata, true);
};
exports.fromCallsToExecuteCalldata = fromCallsToExecuteCalldata;
/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.
 * @deprecated
 */
var fromCallsToExecuteCalldataWithNonce = function (calls, nonce) {
    return __spreadArray(__spreadArray([], (0, exports.fromCallsToExecuteCalldata)(calls), true), [(0, num_1.toBigInt)(nonce).toString()], false);
};
exports.fromCallsToExecuteCalldataWithNonce = fromCallsToExecuteCalldataWithNonce;
/**
 * Format Data inside Calls
 * @deprecated Not required for getting execute Calldata
 */
var transformCallsToMulticallArrays_cairo1 = function (calls) {
    var callArray = calls.map(function (call) { return ({
        to: (0, num_1.toBigInt)(call.contractAddress).toString(10),
        selector: (0, num_1.toBigInt)((0, hash_1.getSelectorFromName)(call.entrypoint)).toString(10),
        calldata: calldata_1.CallData.compile(call.calldata || []),
    }); });
    return callArray;
};
exports.transformCallsToMulticallArrays_cairo1 = transformCallsToMulticallArrays_cairo1;
/**
 * Transforms a list of calls into the Cairo 1 `__execute__` calldata.
 * @param {Call[]} calls the list of calls to transform.
 * @returns {Calldata} the Cairo 1 `__execute__` calldata.
 * @example
 * ```typescript
 * const calls: Call[] = [
 * 	{
 * 		contractAddress: "0x1234567890123456789012345678901234567890",
 * 		entrypoint: "functionName",
 * 		calldata: [1, 2, 3]
 * 	},
 * 	{
 * 		contractAddress: "0x0987654321098765432109876543210987654321",
 * 		entrypoint: "anotherFunction",
 * 		calldata: [4, 5, 6]
 * 	}
 * ];
 * const result = transaction.fromCallsToExecuteCalldata_cairo1(calls);
 * // result = ['2', '103929005307130220006098923584552504982110632080',
 * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',
 * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',
 * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',
 * //   '3', '4', '5', '6']
 * ```
 */
var fromCallsToExecuteCalldata_cairo1 = function (calls) {
    // ensure property order
    var orderCalls = calls.map(function (call) { return ({
        contractAddress: call.contractAddress,
        entrypoint: call.entrypoint,
        calldata: Array.isArray(call.calldata) && '__compiled__' in call.calldata
            ? call.calldata // Calldata type
            : calldata_1.CallData.compile(call.calldata), // RawArgsObject | RawArgsArray type
    }); });
    return calldata_1.CallData.compile({ orderCalls: orderCalls });
};
exports.fromCallsToExecuteCalldata_cairo1 = fromCallsToExecuteCalldata_cairo1;
/**
 * Create `__execute__` Calldata from Calls based on Cairo versions.
 * @param {Call[]} calls the list of calls to transform
 * @param {CairoVersion} cairoVersion the Cairo version
 * @returns {Calldata} the `__execute__` calldata.
 * @example
 * ```typescript
 * const calls: Call[] = [
 * 	{
 * 		contractAddress: "0x1234567890123456789012345678901234567890",
 * 		entrypoint: "functionName",
 * 		calldata: [1, 2, 3]
 * 	},
 * 	{
 * 		contractAddress: "0x0987654321098765432109876543210987654321",
 * 		entrypoint: "anotherFunction",
 * 		calldata: [4, 5, 6]
 * 	}
 * ];
 * const result = transaction.getExecuteCalldata(calls, '1');
 * // result = ['2', '103929005307130220006098923584552504982110632080',
 * //   '784552248838722632831848474045274978537388011177294206940059575485454596699',
 * //   '3', '1', '2', '3', '54400338722927882010739357306608455014511100705',
 * //   '836430224577382061379420368022192503799782058803937958828224424676927281484',
 * //   '3', '4', '5', '6']
 * ```
 */
var getExecuteCalldata = function (calls, cairoVersion) {
    if (cairoVersion === void 0) { cairoVersion = '0'; }
    if (cairoVersion === '1') {
        return (0, exports.fromCallsToExecuteCalldata_cairo1)(calls);
    }
    return (0, exports.fromCallsToExecuteCalldata)(calls);
};
exports.getExecuteCalldata = getExecuteCalldata;
/**
 * Builds a UDCCall object.
 *
 * @param {UniversalDeployerContractPayload | UniversalDeployerContractPayload[]} payload the payload data for the UDCCall. Can be a single payload object or an array of payload objects.
 * @param {string} address the address to be used in the UDCCall
 * @returns { calls: Call[], addresses: string[] } the UDCCall object containing an array of calls and an array of addresses.
 * @example
 * ```typescript
 * const payload: UniversalDeployerContractPayload = {
 * classHash: "0x1234567890123456789012345678901234567890",
 * salt: "0x0987654321098765432109876543210987654321",
 * unique:true,
 * constructorCalldata: [1, 2, 3]
 * };
 * const address = "0xABCDEF1234567890ABCDEF1234567890ABCDEF12";
 * const result  = transaction.buildUDCCall(payload, address);
 * // result = {
 * // 	calls: [
 * //			{
 * //			contractAddress: "0xABCDEF1234567890ABCDEF1234567890ABCDEF12",
 * //			entrypoint: "functionName",
 * //			calldata: [classHash, salt, true, 3, 1, 2, 3]
 * //		}],
 * //	addresses: ["0x6fD084B56a7EDc5C06B3eB40f97Ae5A0C707A865"]
 * // }
 * ```
 */
function buildUDCCall(payload, address) {
    var params = [].concat(payload).map(function (it) {
        var _a = it, classHash = _a.classHash, salt = _a.salt, _b = _a.unique, unique = _b === void 0 ? true : _b, _c = _a.constructorCalldata, constructorCalldata = _c === void 0 ? [] : _c;
        var compiledConstructorCallData = calldata_1.CallData.compile(constructorCalldata);
        var deploySalt = salt !== null && salt !== void 0 ? salt : (0, stark_1.randomAddress)();
        return {
            call: {
                contractAddress: constants_1.UDC.ADDRESS,
                entrypoint: constants_1.UDC.ENTRYPOINT,
                calldata: __spreadArray([
                    classHash,
                    deploySalt,
                    (0, num_1.toCairoBool)(unique),
                    compiledConstructorCallData.length
                ], compiledConstructorCallData, true),
            },
            address: (0, hash_1.calculateContractAddressFromHash)(unique ? ec_1.starkCurve.pedersen(address, deploySalt) : deploySalt, classHash, compiledConstructorCallData, unique ? constants_1.UDC.ADDRESS : 0),
        };
    });
    return {
        calls: params.map(function (it) { return it.call; }),
        addresses: params.map(function (it) { return it.address; }),
    };
}
/**
 * Return transaction versions based on version type, default version type is 'transaction'.
 * @param {'fee' | 'transaction'} [versionType] the type of version ("fee" or "transaction")
 * @returns {v1: ETransactionVersion, v2: ETransactionVersion, v3: ETransactionVersion} an object containing the transaction versions.
 * @example
 * ```typescript
 * const result = transaction.getVersionsByType('fee');
 * // result = {
 * //   v1: '0x100000000000000000000000000000001',
 * //   v2: '0x100000000000000000000000000000002',
 * //   v3: '0x100000000000000000000000000000003'
 * // }
 * ```
 */
function getVersionsByType(versionType) {
    return versionType === 'fee'
        ? {
            v1: api_1.ETransactionVersion.F1,
            v2: api_1.ETransactionVersion.F2,
            v3: api_1.ETransactionVersion.F3,
        }
        : { v1: api_1.ETransactionVersion.V1, v2: api_1.ETransactionVersion.V2, v3: api_1.ETransactionVersion.V3 };
}

},{"../constants":102,"../types/api":119,"./calldata":152,"./ec":162,"./hash":168,"./num":175,"./stark":181}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptTx = void 0;
/* eslint-disable no-nested-ternary */
var types_1 = require("../types");
/**
 * Utility that analyses transaction receipt response and provides helpers to process it
 * @example
 * ```typescript
 * const responseTx = new ReceiptTx(receipt);
 * responseTx.match({
 *   success: (txR: SuccessfulTransactionReceiptResponse) => { },
 *   rejected: (txR: RejectedTransactionReceiptResponse) => { },
 *   reverted: (txR: RevertedTransactionReceiptResponse) => { },
 *   error: (err: Error) => { },
 * });
 * responseTx.match({
 *   success: (txR: SuccessfulTransactionReceiptResponse) => { },
 *   _: () => { },
 * }
 * ```
 */
var ReceiptTx = /** @class */ (function () {
    function ReceiptTx(receipt) {
        var _a;
        _a = ReceiptTx.isSuccess(receipt)
            ? ['success', receipt]
            : ReceiptTx.isReverted(receipt)
                ? ['reverted', receipt]
                : ReceiptTx.isRejected(receipt)
                    ? ['rejected', receipt]
                    : ['error', new Error('Unknown response type')], this.statusReceipt = _a[0], this.value = _a[1];
        // eslint-disable-next-line no-restricted-syntax
        for (var _i = 0, _b = Object.entries(this); _i < _b.length; _i++) {
            var key = _b[_i][0];
            Object.defineProperty(this, key, {
                enumerable: false,
            });
        }
        // eslint-disable-next-line no-restricted-syntax
        for (var _c = 0, _d = Object.entries(receipt); _c < _d.length; _c++) {
            var _e = _d[_c], key = _e[0], value = _e[1];
            Object.defineProperty(this, key, {
                enumerable: true,
                writable: false,
                value: value,
            });
        }
    }
    ReceiptTx.prototype.match = function (callbacks) {
        if (this.statusReceipt in callbacks) {
            return callbacks[this.statusReceipt](this.value);
        }
        return callbacks._();
    };
    ReceiptTx.prototype.isSuccess = function () {
        return this.statusReceipt === 'success';
    };
    ReceiptTx.prototype.isReverted = function () {
        return this.statusReceipt === 'reverted';
    };
    ReceiptTx.prototype.isRejected = function () {
        return this.statusReceipt === 'rejected';
    };
    ReceiptTx.prototype.isError = function () {
        return this.statusReceipt === 'error';
    };
    ReceiptTx.isSuccess = function (transactionReceipt) {
        return (transactionReceipt.execution_status ===
            types_1.TransactionExecutionStatus.SUCCEEDED);
    };
    ReceiptTx.isReverted = function (transactionReceipt) {
        return (transactionReceipt.execution_status ===
            types_1.TransactionExecutionStatus.REVERTED);
    };
    ReceiptTx.isRejected = function (transactionReceipt) {
        return (transactionReceipt.status ===
            types_1.TransactionExecutionStatus.REJECTED);
    };
    return ReceiptTx;
}());
exports.ReceiptTx = ReceiptTx;

},{"../types":128}],185:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSelector = prepareSelector;
exports.isMerkleTreeType = isMerkleTreeType;
exports.getDependencies = getDependencies;
exports.encodeType = encodeType;
exports.getTypeHash = getTypeHash;
exports.encodeValue = encodeValue;
exports.encodeData = encodeData;
exports.getStructHash = getStructHash;
exports.getMessageHash = getMessageHash;
/* eslint-disable no-param-reassign */
var constants_1 = require("../constants");
var types_1 = require("../types");
var assert_1 = require("./assert");
var byteArray_1 = require("./calldata/byteArray");
var hash_1 = require("./hash");
var merkle_1 = require("./merkle");
var num_1 = require("./num");
var shortString_1 = require("./shortString");
/** @deprecated prefer importing from 'types' over 'typedData' */
__exportStar(require("../types/typedData"), exports);
var presetTypes = {
    u256: JSON.parse('[{ "name": "low", "type": "u128" }, { "name": "high", "type": "u128" }]'),
    TokenAmount: JSON.parse('[{ "name": "token_address", "type": "ContractAddress" }, { "name": "amount", "type": "u256" }]'),
    NftId: JSON.parse('[{ "name": "collection_address", "type": "ContractAddress" }, { "name": "token_id", "type": "u256" }]'),
};
var revisionConfiguration = (_a = {},
    _a[types_1.TypedDataRevision.ACTIVE] = {
        domain: 'StarknetDomain',
        hashMethod: hash_1.computePoseidonHashOnElements,
        hashMerkleMethod: hash_1.computePoseidonHash,
        escapeTypeString: function (s) { return "\"".concat(s, "\""); },
        presetTypes: presetTypes,
    },
    _a[types_1.TypedDataRevision.LEGACY] = {
        domain: 'StarkNetDomain',
        hashMethod: hash_1.computePedersenHashOnElements,
        hashMerkleMethod: hash_1.computePedersenHash,
        escapeTypeString: function (s) { return s; },
        presetTypes: {},
    },
    _a);
function assertRange(data, type, _a) {
    var min = _a.min, max = _a.max;
    var value = BigInt(data);
    (0, assert_1.default)(value >= min && value <= max, "".concat(value, " (").concat(type, ") is out of bounds [").concat(min, ", ").concat(max, "]"));
}
function identifyRevision(_a) {
    var _b;
    var types = _a.types, domain = _a.domain;
    if (revisionConfiguration[types_1.TypedDataRevision.ACTIVE].domain in types && domain.revision === types_1.TypedDataRevision.ACTIVE)
        return types_1.TypedDataRevision.ACTIVE;
    if (revisionConfiguration[types_1.TypedDataRevision.LEGACY].domain in types &&
        ((_b = domain.revision) !== null && _b !== void 0 ? _b : types_1.TypedDataRevision.LEGACY) === types_1.TypedDataRevision.LEGACY)
        return types_1.TypedDataRevision.LEGACY;
    return undefined;
}
function getHex(value) {
    try {
        return (0, num_1.toHex)(value);
    }
    catch (e) {
        if ((0, shortString_1.isString)(value)) {
            return (0, num_1.toHex)((0, shortString_1.encodeShortString)(value));
        }
        throw new Error("Invalid BigNumberish: ".concat(value));
    }
}
/**
 * Validates that `data` matches the EIP-712 JSON schema.
 */
function validateTypedData(data) {
    var typedData = data;
    return Boolean(typedData.message && typedData.primaryType && typedData.types && identifyRevision(typedData));
}
/**
 * Prepares the selector for use.
 *
 * @param {string} selector - The selector to be prepared.
 * @returns {string} The prepared selector.
 */
function prepareSelector(selector) {
    return (0, num_1.isHex)(selector) ? selector : (0, hash_1.getSelectorFromName)(selector);
}
/**
 * Checks if the given Starknet type is a Merkle tree type.
 *
 * @param {StarknetType} type - The StarkNet type to check.
 *
 * @returns {boolean} - True if the type is a Merkle tree type, false otherwise.
 */
function isMerkleTreeType(type) {
    return type.type === 'merkletree';
}
/**
 * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once
 * in the resulting array.
 */
function getDependencies(types, type, dependencies, contains, revision) {
    if (dependencies === void 0) { dependencies = []; }
    if (contains === void 0) { contains = ''; }
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    // Include pointers (struct arrays)
    if (type[type.length - 1] === '*') {
        type = type.slice(0, -1);
    }
    else if (revision === types_1.TypedDataRevision.ACTIVE) {
        // enum base
        if (type === 'enum') {
            type = contains;
        }
        // enum element types
        else if (type.match(/^\(.*\)$/)) {
            type = type.slice(1, -1);
        }
    }
    if (dependencies.includes(type) || !types[type]) {
        return dependencies;
    }
    return __spreadArray([
        type
    ], types[type].reduce(function (previous, t) { return __spreadArray(__spreadArray([], previous, true), getDependencies(types, t.type, previous, t.contains, revision).filter(function (dependency) { return !previous.includes(dependency); }), true); }, []), true);
}
function getMerkleTreeType(types, ctx) {
    if (ctx.parent && ctx.key) {
        var parentType = types[ctx.parent];
        var merkleType = parentType.find(function (t) { return t.name === ctx.key; });
        var isMerkleTree = isMerkleTreeType(merkleType);
        if (!isMerkleTree) {
            throw new Error("".concat(ctx.key, " is not a merkle tree"));
        }
        if (merkleType.contains.endsWith('*')) {
            throw new Error("Merkle tree contain property must not be an array but was given ".concat(ctx.key));
        }
        return merkleType.contains;
    }
    return 'raw';
}
/**
 * Encode a type to a string. All dependent types are alphabetically sorted.
 */
function encodeType(types, type, revision) {
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    var allTypes = revision === types_1.TypedDataRevision.ACTIVE
        ? __assign(__assign({}, types), revisionConfiguration[revision].presetTypes) : types;
    var _a = getDependencies(allTypes, type, undefined, undefined, revision), primary = _a[0], dependencies = _a.slice(1);
    var newTypes = !primary ? [] : __spreadArray([primary], dependencies.sort(), true);
    var esc = revisionConfiguration[revision].escapeTypeString;
    return newTypes
        .map(function (dependency) {
        var dependencyElements = allTypes[dependency].map(function (t) {
            var targetType = t.type === 'enum' && revision === types_1.TypedDataRevision.ACTIVE
                ? t.contains
                : t.type;
            // parentheses handling for enum variant types
            var typeString = targetType.match(/^\(.*\)$/)
                ? "(".concat(targetType
                    .slice(1, -1)
                    .split(',')
                    .map(function (e) { return (e ? esc(e) : e); })
                    .join(','), ")")
                : esc(targetType);
            return "".concat(esc(t.name), ":").concat(typeString);
        });
        return "".concat(esc(dependency), "(").concat(dependencyElements, ")");
    })
        .join('');
}
/**
 * Get a type string as hash.
 */
function getTypeHash(types, type, revision) {
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    return (0, hash_1.getSelectorFromName)(encodeType(types, type, revision));
}
/**
 * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of
 * an array of ABI compatible types, and an array of corresponding values.
 */
function encodeValue(types, type, data, ctx, revision) {
    if (ctx === void 0) { ctx = {}; }
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    if (types[type]) {
        return [type, getStructHash(types, type, data, revision)];
    }
    if (revisionConfiguration[revision].presetTypes[type]) {
        return [
            type,
            getStructHash(revisionConfiguration[revision].presetTypes, type, data, revision),
        ];
    }
    if (type.endsWith('*')) {
        var hashes = data.map(function (entry) { return encodeValue(types, type.slice(0, -1), entry, undefined, revision)[1]; });
        return [type, revisionConfiguration[revision].hashMethod(hashes)];
    }
    switch (type) {
        case 'enum': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                var _a = Object.entries(data)[0], variantKey_1 = _a[0], variantData_1 = _a[1];
                var parentType = types[ctx.parent][0];
                var enumType = types[parentType.contains];
                var variantType = enumType.find(function (t) { return t.name === variantKey_1; });
                var variantIndex = enumType.indexOf(variantType);
                var encodedSubtypes = variantType.type
                    .slice(1, -1)
                    .split(',')
                    .map(function (subtype, index) {
                    if (!subtype)
                        return subtype;
                    var subtypeData = variantData_1[index];
                    return encodeValue(types, subtype, subtypeData, undefined, revision)[1];
                });
                return [
                    type,
                    revisionConfiguration[revision].hashMethod(__spreadArray([variantIndex], encodedSubtypes, true)),
                ];
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'merkletree': {
            var merkleTreeType_1 = getMerkleTreeType(types, ctx);
            var structHashes = data.map(function (struct) {
                return encodeValue(types, merkleTreeType_1, struct, undefined, revision)[1];
            });
            var root = new merkle_1.MerkleTree(structHashes, revisionConfiguration[revision].hashMerkleMethod).root;
            return ['felt', root];
        }
        case 'selector': {
            return ['felt', prepareSelector(data)];
        }
        case 'string': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                var byteArray = (0, byteArray_1.byteArrayFromString)(data);
                var elements = __spreadArray(__spreadArray([
                    byteArray.data.length
                ], byteArray.data, true), [
                    byteArray.pending_word,
                    byteArray.pending_word_len,
                ], false);
                return [type, revisionConfiguration[revision].hashMethod(elements)];
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'i128': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                var value = BigInt(data);
                assertRange(value, type, constants_1.RANGE_I128);
                return [type, getHex(value < 0n ? constants_1.PRIME + value : value)];
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'timestamp':
        case 'u128': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                assertRange(data, type, constants_1.RANGE_U128);
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'felt':
        case 'shortstring': {
            // TODO: should 'shortstring' diverge into directly using encodeShortString()?
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                assertRange(getHex(data), type, constants_1.RANGE_FELT);
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'ClassHash':
        case 'ContractAddress': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                assertRange(data, type, constants_1.RANGE_FELT);
            } // else fall through to default
            return [type, getHex(data)];
        }
        case 'bool': {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                (0, assert_1.default)(typeof data === 'boolean', "Type mismatch for ".concat(type, " ").concat(data));
            } // else fall through to default
            return [type, getHex(data)];
        }
        default: {
            if (revision === types_1.TypedDataRevision.ACTIVE) {
                throw new Error("Unsupported type: ".concat(type));
            }
            return [type, getHex(data)];
        }
    }
}
/**
 * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values.
 * All dependent types are automatically encoded.
 */
function encodeData(types, type, data, revision) {
    var _a;
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    var targetType = (_a = types[type]) !== null && _a !== void 0 ? _a : revisionConfiguration[revision].presetTypes[type];
    var _b = targetType.reduce(function (_a, field) {
        var ts = _a[0], vs = _a[1];
        if (data[field.name] === undefined ||
            (data[field.name] === null && field.type !== 'enum')) {
            throw new Error("Cannot encode data: missing data for '".concat(field.name, "'"));
        }
        var value = data[field.name];
        var ctx = { parent: type, key: field.name };
        var _b = encodeValue(types, field.type, value, ctx, revision), t = _b[0], encodedValue = _b[1];
        return [
            __spreadArray(__spreadArray([], ts, true), [t], false),
            __spreadArray(__spreadArray([], vs, true), [encodedValue], false),
        ];
    }, [['felt'], [getTypeHash(types, type, revision)]]), returnTypes = _b[0], values = _b[1];
    return [returnTypes, values];
}
/**
 * Get encoded data as a hash. The data should be a key -> value object with all the required values.
 * All dependent types are automatically encoded.
 */
function getStructHash(types, type, data, revision) {
    if (revision === void 0) { revision = types_1.TypedDataRevision.LEGACY; }
    return revisionConfiguration[revision].hashMethod(encodeData(types, type, data, revision)[1]);
}
/**
 * Get the SNIP-12 encoded message to sign, from the typedData object.
 */
function getMessageHash(typedData, account) {
    if (!validateTypedData(typedData)) {
        throw new Error('Typed data does not match JSON schema');
    }
    var revision = identifyRevision(typedData);
    var _a = revisionConfiguration[revision], domain = _a.domain, hashMethod = _a.hashMethod;
    var message = [
        (0, shortString_1.encodeShortString)('StarkNet Message'),
        getStructHash(typedData.types, domain, typedData.domain, revision),
        account,
        getStructHash(typedData.types, typedData.primaryType, typedData.message, revision),
    ];
    return hashMethod(message);
}

},{"../constants":102,"../types":128,"../types/typedData":139,"./assert":141,"./calldata/byteArray":145,"./hash":168,"./merkle":174,"./num":175,"./shortString":180}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UINT_256_MAX = exports.UINT_128_MAX = void 0;
exports.uint256ToBN = uint256ToBN;
exports.isUint256 = isUint256;
exports.bnToUint256 = bnToUint256;
var uint256_1 = require("./cairoDataTypes/uint256");
Object.defineProperty(exports, "UINT_128_MAX", { enumerable: true, get: function () { return uint256_1.UINT_128_MAX; } });
Object.defineProperty(exports, "UINT_256_MAX", { enumerable: true, get: function () { return uint256_1.UINT_256_MAX; } });
/**
 * Convert Uint256 to bigint
 * Legacy support Export
 * @param {Uint256} uint256 Uint256 value to convert to bigint
 * @returns {bigint} BigInt representation of the input Uint256
 * @example
 * ```typescript
 * const uint256Value: Uint256 = {low: 1234567890, high: 1};
 * const result = uint256.uint256ToBN(uint256Value);
 * // result = 340282366920938463463374607433002779346n
 * ```
 */
function uint256ToBN(uint256) {
    return new uint256_1.CairoUint256(uint256).toBigInt();
}
/**
 * Test BigNumberish is in the range[0, 2**256-1]
 * Legacy support Export
 * @param {BigNumberish} bn value to test
 * @returns {boolean} True if the input value is in the range[0, 2**256-1], false otherwise
 * @example
 * ```typescript
 * const result = uint256.isUint256(12345n);
 * // result = true
 * const result1 = uint256.isUint256(-1);
 * // result1 = false
 * ```
 */
function isUint256(bn) {
    return uint256_1.CairoUint256.is(bn);
}
/**
 * Convert BigNumberish (string | number | bigint) to Uint256
 * Legacy support Export
 * @param {BigNumberish} bn value to convert to Uint256
 * @returns {Uint256} Uint256 object representing the BigNumberish value
 * @example
 * ```typescript
 * const result = uint256.bnToUint256(1000000000n);
 * // result = {"low": "0x3b9aca00", "high": "0x0"}
 * ```
 */
function bnToUint256(bn) {
    return new uint256_1.CairoUint256(bn).toUint256HexString();
}

},{"./cairoDataTypes/uint256":143}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUrl = isUrl;
exports.buildUrl = buildUrl;
var url_join_1 = require("url-join");
/**
 * Inspired from https://github.com/segmentio/is-url
 */
/**
 * RegExps.
 * A URL must match #1 and then at least one of #2/#3.
 * Use two levels of REs to avoid REDOS.
 */
var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
/**
 * Loosely validate a URL `string`.
 *
 * @param {string} s - The URL to check for
 * @return {boolean} `true` if url is valid, `false` otherwise
 * @example
 * ```typescript
 * const s = "https://starknetjs.com/docs";
 * const result = isUrl(s);
 * // result == true
 */
function isUrl(s) {
    if (!s) {
        return false;
    }
    if (typeof s !== 'string') {
        return false;
    }
    var match = s.match(protocolAndDomainRE);
    if (!match) {
        return false;
    }
    var everythingAfterProtocol = match[1];
    if (!everythingAfterProtocol) {
        return false;
    }
    if (localhostDomainRE.test(everythingAfterProtocol) ||
        nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
    }
    return false;
}
/**
 * Builds a URL using the provided base URL, default path, and optional URL or path.
 *
 * @param {string} baseUrl - The base URL of the URL being built.
 * @param {string} defaultPath - The default path to use if no URL or path is provided.
 * @param {string} [urlOrPath] - The optional URL or path to append to the base URL.
 * @return {string} The built URL.
 * @example
 * ```typescript
 * const baseUrl = "https://starknetjs.com";
 * const defaultPath = "/";
 * const urlOrPath = "/docs";
 * const result = buildUrl(baseUrl, defaultPath, urlOrPath);
 *
 * result = "https://starknetjs.com/docs"
 */
function buildUrl(baseUrl, defaultPath, urlOrPath) {
    return isUrl(urlOrPath) ? urlOrPath : (0, url_join_1.default)(baseUrl, urlOrPath !== null && urlOrPath !== void 0 ? urlOrPath : defaultPath);
}

},{"url-join":93}],188:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletAccount = void 0;
var account_1 = require("../account");
var contract_1 = require("../utils/contract");
var json_1 = require("../utils/json");
var transaction_1 = require("../utils/transaction");
var connect_1 = require("./connect");
// Represent 'Selected Active' Account inside Connected Wallet
var WalletAccount = /** @class */ (function (_super) {
    __extends(WalletAccount, _super);
    function WalletAccount(providerOrOptions, walletProvider, cairoVersion) {
        var _this = _super.call(this, providerOrOptions, '', '', cairoVersion) || this; // At this point unknown address
        _this.address = '';
        _this.walletProvider = walletProvider;
        // Update Address on change
        _this.walletProvider.on('accountsChanged', function (res) {
            if (!res)
                return;
            _this.address = res[0].toLowerCase();
        });
        // Update Channel chainId on Network change
        _this.walletProvider.on('networkChanged', function (res) {
            if (!res)
                return;
            // Determine is it better to set chainId or replace channel with new one
            // At the moment channel is stateless but it could change
            _this.channel.setChainId(res);
        });
        // Get and Set Address !!! Post constructor initial empty string
        walletProvider
            .request({
            type: 'wallet_requestAccounts',
            params: {
                silent_mode: false,
            },
        })
            .then(function (res) {
            _this.address = res[0].toLowerCase();
        });
        return _this;
    }
    /**
     * WALLET EVENTS
     */
    WalletAccount.prototype.onAccountChange = function (callback) {
        (0, connect_1.onAccountChange)(this.walletProvider, callback);
    };
    WalletAccount.prototype.onNetworkChanged = function (callback) {
        (0, connect_1.onNetworkChanged)(this.walletProvider, callback);
    };
    /**
     * WALLET SPECIFIC METHODS
     */
    WalletAccount.prototype.requestAccounts = function (silentMode) {
        if (silentMode === void 0) { silentMode = false; }
        return (0, connect_1.requestAccounts)(this.walletProvider, silentMode);
    };
    WalletAccount.prototype.getPermissions = function () {
        return (0, connect_1.getPermissions)(this.walletProvider);
    };
    WalletAccount.prototype.switchStarknetChain = function (chainId) {
        return (0, connect_1.switchStarknetChain)(this.walletProvider, chainId);
    };
    WalletAccount.prototype.watchAsset = function (asset) {
        return (0, connect_1.watchAsset)(this.walletProvider, asset);
    };
    WalletAccount.prototype.addStarknetChain = function (chain) {
        return (0, connect_1.addStarknetChain)(this.walletProvider, chain);
    };
    /**
     * ACCOUNT METHODS
     */
    WalletAccount.prototype.execute = function (calls) {
        var txCalls = [].concat(calls).map(function (it) {
            var contractAddress = it.contractAddress, entrypoint = it.entrypoint, calldata = it.calldata;
            return {
                contract_address: contractAddress,
                entry_point: entrypoint,
                calldata: calldata,
            };
        });
        var params = {
            calls: txCalls,
        };
        return (0, connect_1.addInvokeTransaction)(this.walletProvider, params);
    };
    WalletAccount.prototype.declare = function (payload) {
        var declareContractPayload = (0, contract_1.extractContractHashes)(payload);
        // DISCUSS: HOTFIX: Adapt Abi format
        var pContract = payload.contract;
        var cairo1Contract = __assign(__assign({}, pContract), { abi: (0, json_1.stringify)(pContract.abi) });
        // Check FIx
        if (!declareContractPayload.compiledClassHash) {
            throw Error('compiledClassHash is required');
        }
        var params = {
            compiled_class_hash: declareContractPayload.compiledClassHash,
            contract_class: cairo1Contract,
        };
        return (0, connect_1.addDeclareTransaction)(this.walletProvider, params);
    };
    WalletAccount.prototype.deploy = function (payload) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, calls, addresses, invokeResponse;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = (0, transaction_1.buildUDCCall)(payload, this.address), calls = _a.calls, addresses = _a.addresses;
                        return [4 /*yield*/, this.execute(calls)];
                    case 1:
                        invokeResponse = _b.sent();
                        return [2 /*return*/, __assign(__assign({}, invokeResponse), { contract_address: addresses })];
                }
            });
        });
    };
    WalletAccount.prototype.signMessage = function (typedData) {
        return (0, connect_1.signMessage)(this.walletProvider, typedData);
    };
    return WalletAccount;
}(account_1.Account));
exports.WalletAccount = WalletAccount;

},{"../account":97,"../utils/contract":161,"../utils/json":173,"../utils/transaction":183,"./connect":189}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestAccounts = requestAccounts;
exports.getPermissions = getPermissions;
exports.watchAsset = watchAsset;
exports.addStarknetChain = addStarknetChain;
exports.switchStarknetChain = switchStarknetChain;
exports.requestChainId = requestChainId;
exports.deploymentData = deploymentData;
exports.addInvokeTransaction = addInvokeTransaction;
exports.addDeclareTransaction = addDeclareTransaction;
exports.signMessage = signMessage;
exports.supportedSpecs = supportedSpecs;
exports.onAccountChange = onAccountChange;
exports.onNetworkChanged = onNetworkChanged;
/**
 * Request Permission for wallet account, return addresses that are allowed by user
 * @param {boolean} [silent_mode=false] false: request user interaction allowance. true: return only pre-allowed
 * @returns allowed accounts addresses
 */
function requestAccounts(swo, silent_mode) {
    if (silent_mode === void 0) { silent_mode = false; }
    return swo.request({
        type: 'wallet_requestAccounts',
        params: {
            silent_mode: silent_mode,
        },
    });
}
/**
 * Request Permission for wallet account
 * @returns allowed accounts addresses
 */
function getPermissions(swo) {
    return swo.request({ type: 'wallet_getPermissions' });
}
/**
 * Request adding ERC20 Token to Wallet List
 * @param asset WatchAssetParameters
 * @returns boolean
 */
function watchAsset(swo, asset) {
    return swo.request({
        type: 'wallet_watchAsset',
        params: asset,
    });
}
/**
 * Request adding custom Starknet chain
 * @param chain AddStarknetChainParameters
 * @returns boolean
 */
function addStarknetChain(swo, chain) {
    // TODO: This should set custom RPC endpoint ?
    return swo.request({
        type: 'wallet_addStarknetChain',
        params: chain,
    });
}
/**
 * Request Wallet Network change
 * @param chainId StarknetChainId
 * @returns boolean
 */
function switchStarknetChain(swo, chainId) {
    return swo.request({
        type: 'wallet_switchStarknetChain',
        params: {
            chainId: chainId,
        },
    });
}
/**
 * Request the current chain ID from the wallet.
 * @returns The current Starknet chain ID.
 */
function requestChainId(swo) {
    return swo.request({ type: 'wallet_requestChainId' });
}
/**
 * Get deployment data for a contract.
 * @returns The deployment data result.
 */
function deploymentData(swo) {
    return swo.request({ type: 'wallet_deploymentData' }); // TODO: test
}
/**
 * Add an invoke transaction to the wallet.
 * @param params The parameters required for the invoke transaction.
 * @returns The result of adding the invoke transaction.
 */
function addInvokeTransaction(swo, params) {
    return swo.request({
        type: 'wallet_addInvokeTransaction',
        params: params,
    });
}
/**
 * Add a declare transaction to the wallet.
 * @param params The parameters required for the declare transaction.
 * @returns The result of adding the declare transaction.
 */
function addDeclareTransaction(swo, params) {
    return swo.request({
        type: 'wallet_addDeclareTransaction',
        params: params,
    });
}
/**
 * Sign typed data using the wallet.
 * @param swo the starknet (wallet) window object to request the signature.
 * @param typedData The typed data to sign.
 * @returns An array of signatures as strings.
 */
function signMessage(swo, typedData) {
    return swo.request({
        type: 'wallet_signTypedData',
        params: typedData,
    });
}
/**
 * Get the list of supported specifications.
 * @returns An array of supported specification strings.
 */
function supportedSpecs(swo) {
    return swo.request({ type: 'wallet_supportedSpecs' });
}
/**
 * Attaches an event handler function to the "accountsChanged" event of a StarknetWindowObject.
 * When the accounts are changed, the specified callback function will be called.
 *
 * @param {StarknetWindowObject} swo - The StarknetWindowObject to attach the event handler to.
 * @param {AccountChangeEventHandler} callback - The function to be called when the accounts are changed.
 *                                              It will receive the changed accounts as a parameter.
 * @returns {void}
 */
function onAccountChange(swo, callback) {
    swo.on('accountsChanged', callback);
}
/**
 * Register a callback function to be called when the network is changed.
 *
 * @param {StarknetWindowObject} swo - The StarknetWindowObject instance.
 * @param {NetworkChangeEventHandler} callback - The callback function to be called when the network is changed.
 * @return {void}
 */
function onNetworkChanged(swo, callback) {
    swo.on('networkChanged', callback);
}

},{}],190:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./account"), exports);

},{"./account":188}],191:[function(require,module,exports){
const starknet = require("./src/index.js");
const argentXSessions = require("@argent/x-sessions");
module.exports = {starknet, argentXSessions};
},{"./src/index.js":107,"@argent/x-sessions":25}]},{},[191])(191)
});
